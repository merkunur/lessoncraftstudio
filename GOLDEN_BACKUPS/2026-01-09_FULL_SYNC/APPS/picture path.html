<!DOCTYPE html>
<!--
  ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
  ‚ïë  üîí PROTECTED: LPF MAZE ALGORITHM v1.0 - IMPLEMENTED 2026-01-09          ‚ïë
  ‚ïë                                                                          ‚ïë
  ‚ïë  This file contains the PROFESSIONAL maze generation algorithm using     ‚ïë
  ‚ïë  Longest Path First (LPF) / Two-Pass Farthest Point Algorithm.           ‚ïë
  ‚ïë                                                                          ‚ïë
  ‚ïë  ‚õî DO NOT OVERWRITE WITH OLDER VERSIONS!                                 ‚ïë
  ‚ïë                                                                          ‚ïë
  ‚ïë  Before ANY deployment, verify this marker exists. If deploying from     ‚ïë
  ‚ïë  another source, it MUST contain "generatePerfectMaze" and               ‚ïë
  ‚ïë  "findLongestMazePath" functions.                                        ‚ïë
  ‚ïë                                                                          ‚ïë
  ‚ïë  Verification command:                                                   ‚ïë
  ‚ïë  grep "LPF MAZE ALGORITHM" "REFERENCE APPS\picture path.html"            ‚ïë
  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
-->
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title data-translate="picture.pathway.page.title">Picture Pathway</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="js/translations-picture-pathway.js?v=3"></script>
  <script src="js/bulletproof-loader.js"></script>
  <script src="js/unified-language-manager.js"></script>
  <script src="js/border-background-sizer.js"></script>
  <script src="js/auto-fix-system.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;700&family=Fredoka:wght@400;500;600&family=Lexend+Deca&family=Nunito:wght@400;700&family=Quicksand:wght@300..700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" xintegrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
        /* New Theme Colors */
        --app-font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --app-bg-dark: #2c2c2e; /* Sidebar background */
        --app-surface-dark: #3a3a3e; /* Sidebar input backgrounds */
        --app-border-dark: #4a4a4a; /* Sidebar borders */
        --app-text-primary-dark-theme: #e0e0e0; /* Primary text on dark */
        --app-text-secondary-dark-theme: #a0a0a0; /* Secondary text/labels on dark */

        --app-bg-light: #f0f2f5; /* Main content area background */
        --app-surface-light: #ffffff; /* Canvas, cards on light bg */
        --app-border-light: #dce1e6; /* Borders on light bg */
        --app-text-primary-light-theme: #1c1c1e; /* Primary text on light */
        --app-text-secondary-light-theme: #545458; /* Secondary text on light */

        --app-accent-primary: #007aff; /* New primary accent (blue) */
        --app-accent-primary-hover: #005ecb;
        --app-accent-secondary: #5856d6; /* Example for a different accent if needed */
        --app-accent-danger: #ff3b30;
        --app-accent-danger-hover: #d92c23;

        --sidebar-width: 340px;
    }

    /* Global Reset & Layout */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--app-font-stack);
      display: flex;
      margin: 0;
      height: 100vh;
      background-color: var(--app-bg-light);
      overflow: hidden;
      color: var(--app-text-primary-light-theme);
      position: relative;
    }
    .layout {
        display: flex;
        flex: 1;
        overflow: hidden;
        height: 100vh;
        position: relative;
    }

    /* Sidebar Panel */
    .panel {
      width: var(--sidebar-width);
      min-width: var(--sidebar-width);
      background-color: var(--app-bg-dark);
      color: var(--app-text-primary-dark-theme);
      box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      overflow-y: hidden;
      z-index: 10;
      padding: 0;
      transition: transform 0.3s ease-in-out;
    }

    .panel-header {
        padding: 20px 25px;
        text-align: left;
        border-bottom: 1px solid var(--app-border-dark);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .panel-header h2 {
        font-size: 22px;
        font-weight: 600;
        color: var(--app-text-primary-dark-theme);
        margin: 0;
    }

    .panel-content {
        overflow-y: auto;
        flex-grow: 1;
        padding: 10px 15px;
    }

    /* Accordion Styles */
    .accordion-item {
        background-color: transparent;
        border: none;
        border-bottom: 1px solid var(--app-border-dark);
        margin-bottom: 0;
        border-radius: 0;
        overflow: hidden;
    }
    .accordion-item:last-child {
        border-bottom: none;
    }
    .accordion-button {
        background-color: transparent;
        color: var(--app-text-primary-dark-theme);
        width: 100%;
        border: none;
        text-align: left;
        padding: 18px 10px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background-color 0.15s ease;
    }
    .accordion-button:hover {
        color: var(--app-text-primary-dark-theme);
        background-color: rgba(255,255,255,0.05);
    }
    .accordion-button::after {
        content: '\f078'; /* FontAwesome chevron-down */
        font-family: 'Font Awesome 5 Free';
        font-weight: 900;
        font-size: 12px;
        transition: transform 0.2s ease-in-out;
    }
    .accordion-button.active::after {
        transform: rotate(-180deg);
    }
    .accordion-content {
        padding: 10px 10px 20px 10px;
        display: none;
        background-color: transparent;
        border-top: none;
    }
    .accordion-content.active {
        display: block;
    }
     .accordion-content h4 {
        font-size: 13px;
        color: var(--app-text-secondary-dark-theme);
        margin-top: 15px;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--app-border-dark);
        padding-bottom: 6px;
        font-weight: 500;
    }
     .accordion-content h4:first-child {
        margin-top: 0;
     }

    .accordion-content label {
        display: block;
        font-size: 13px;
        font-weight: 400;
        color: var(--app-text-secondary-dark-theme);
        margin-bottom: 6px;
    }
    .accordion-content input[type="text"],
    .accordion-content input[type="number"],
    .accordion-content textarea,
    .accordion-content select {
        width: 100%;
        padding: 8px 10px;
        font-size: 13px;
        border-radius: 5px;
        border: 1px solid var(--app-border-dark);
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        box-sizing: border-box;
        margin-bottom: 12px;
    }
     .accordion-content input[type="file"] {
      display: none;
    }
    .custom-file-input-wrapper {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-bottom: 12px;
        width: 100%;
    }
    .custom-file-button {
        padding: 8px 16px;
        background-color: var(--app-accent-primary);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 13px;
        white-space: nowrap;
        transition: background-color 0.2s;
    }
    .custom-file-button:hover {
        background-color: var(--app-accent-primary-hover);
    }
    .custom-file-status {
        color: var(--app-text-secondary-dark-theme);
        font-size: 13px;
        flex: 1;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
    }
    .accordion-content input[type="color"] {
         width: 100%; padding: 2px; height: 38px; margin-bottom: 12px; border-radius: 5px; border-color: var(--app-border-dark);
    }
    .accordion-content input[type="range"] { width:100%; padding: 0; margin-bottom: 12px;}

    .accordion-content input[type="number"] {
        -moz-appearance: textfield;
    }
    .accordion-content input[type="number"]::-webkit-outer-spin-button,
    .accordion-content input[type="number"]::-webkit-inner-spin-button {
        -webkit-appearance: none;
        margin: 0;
    }
    .accordion-content input[type="checkbox"] {
        width: auto;
        margin-right: 8px;
        vertical-align: middle;
        accent-color: var(--app-accent-primary);
    }
    .accordion-content label.checkbox-label {
        display: flex;
        align-items: center;
        font-size: 13px;
        font-weight: 400;
        margin-bottom: 12px;
        cursor: pointer;
        color: var(--app-text-secondary-dark-theme);
    }

    /* Buttons within accordion (sidebar) */
    .accordion-content button {
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        border: 1px solid var(--app-border-dark);
        font-weight: 500;
        width: 100%;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 5px;
        margin-bottom: 10px;
    }
    .accordion-content button:hover {
        background-color: rgba(255,255,255,0.1);
        border-color: rgba(255,255,255,0.2);
    }
     .accordion-content button:active { transform: scale(0.98); }
     .accordion-content button:disabled {
        background-color: var(--app-surface-dark) !important;
        color: var(--app-text-secondary-dark-theme) !important;
        border-color: var(--app-border-dark) !important;
        opacity: 0.6;
        cursor: not-allowed;
     }

    .dictionary, #uploadedImagesPreview {
        border: 1px solid var(--app-border-dark);
        min-height: 150px;
        max-height: 150px;
        overflow-y: auto;
        background-color: var(--app-surface-dark);
        padding: 4px;
        font-size: 14px;
        border-radius: 5px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
    }
    .dictionary-item {
        padding: 8px;
        cursor: pointer;
        border: 1px solid transparent;
        font-size: 13px;
        transition: background-color .15s ease, border-color .15s ease;
        display: flex;
        flex-direction: column;
        align-items: center;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.05);
    }
    .dictionary-item:hover {
        background-color: rgba(255,255,255,0.1);
        border-color: var(--app-accent-primary);
        color: var(--app-text-primary-dark-theme);
    }
    .dictionary-item.selected {
        border-color: var(--app-accent-primary);
        background-color: rgba(0, 122, 255, 0.15);
    }
    .dictionary-item img {
        width: 50px; height: 50px;
        object-fit: contain;
        border:1px solid var(--app-border-dark);
        border-radius:3px;
        background-color: var(--app-surface-light);
        margin-bottom: 5px;
    }
    .dictionary-item span {
        font-size: 10px; text-align: center; word-break: break-word; max-width: 50px;
        color: var(--app-text-secondary-dark-theme);
    }
    .dictionary-item:hover span, .dictionary-item.selected span {
        color: var(--app-text-primary-dark-theme);
    }

    .selection-panel {
        border: 1px solid var(--app-border-dark);
        background: var(--app-surface-dark);
        padding: 6px;
        min-height: 50px;
        border-radius: 5px;
        margin-bottom: 10px;
    }
    .selection-panel h4 {
        margin-bottom: 4px;
        font-size: 13px;
        text-align: center;
        color: var(--app-text-secondary-dark-theme);
        border-bottom: 1px solid var(--app-border-dark);
        padding-bottom: 4px;
    }
    .selected-images {
        display: flex;
        gap: 4px;
        flex-wrap: wrap;
        min-height: 40px;
        align-items: center;
        justify-content: center;
    }
    .selected-images img {
        width: 40px;
        height: 40px;
        object-fit: contain;
        border: 1px solid var(--app-accent-primary);
        border-radius: 3px;
        cursor: pointer;
    }
    .dictionary-message {
        width: 100%;
        text-align: center;
        padding: 10px;
        font-size: 12px;
        color: var(--app-text-secondary-dark-theme);
        margin: 0;
        align-self: center;
    }
    
    #borderDictionary, #backgroundDictionary {
        border: 1px solid var(--app-border-dark);
        padding: 8px;
        max-height: 140px;
        overflow-y: auto;
        background-color: var(--app-surface-dark);
        border-radius: 5px;
        margin-top: 8px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
    }
    .border-thumbnail-item {
        cursor: pointer;
        border: 2px solid transparent;
        border-radius: 4px;
        padding: 2px;
        transition: border-color .15s ease;
        width: 60px;
        height: 60px;
    }
    .border-thumbnail-item:hover, .border-thumbnail-item.selected {
        border-color: var(--app-accent-primary);
    }
    .border-thumbnail-item img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background-color: var(--app-surface-light);
        border-radius: 2px;
    }


    .panel-footer {
        padding: 15px 25px;
        border-top: 1px solid var(--app-border-dark);
        margin-top: auto;
        background-color: var(--app-bg-dark);
    }
    .message-area {
        padding: 10px 15px;
        border-radius: 5px;
        font-size: 13px;
        text-align: center;
        min-height: 20px;
        font-weight: 500;
        display: none;
        margin-bottom: 0;
        border-width: 1px;
        border-style: solid;
    }
    .message-area.error {background-color:rgba(255, 59, 48, 0.2); color: var(--app-accent-danger); border-color: var(--app-accent-danger); display: block;}
    .message-area.warning {background-color:rgba(255, 159, 10, 0.2); color: #ff9f0a; border-color: #ff9f0a; display: block;}
    .message-area.info {background-color:rgba(0, 122, 255, 0.15); color:var(--app-accent-primary); border-color: var(--app-accent-primary); display: block;}
    .message-area.success {background-color:rgba(52, 199, 89, 0.2); color: #34c759; border-color: #34c759; display: block;}


    /* Main Content Area */
    .main {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
      padding: 0;
      background-color: var(--app-bg-light);
    }
    
    /* --- Responsive Controls --- */
    .menu-toggle-btn {
        display: none; /* Hidden by default on desktop */
        position: absolute;
        top: 12px;
        left: 20px;
        z-index: 20;
        background-color: var(--app-surface-light);
        color: var(--app-text-primary-light-theme);
        border: 1px solid var(--app-border-light);
        border-radius: 6px;
        width: 38px;
        height: 38px;
        font-size: 18px;
        cursor: pointer;
        align-items: center;
        justify-content: center;
    }
     .menu-toggle-btn:hover {
        background-color: #e8e8ed;
    }

    .menu-close-btn {
        display: none; /* Hidden by default on desktop */
        background: none;
        border: none;
        color: var(--app-text-secondary-dark-theme);
        font-size: 28px;
        line-height: 1;
        cursor: pointer;
        padding: 0 5px;
    }
    .menu-close-btn:hover {
        color: var(--app-text-primary-dark-theme);
    }

    .menu-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.4);
        z-index: 998;
    }
    .menu-overlay.is-active {
        display: block;
    }

    /* --- Top Right Actions Area --- */
    .top-right-actions {
        position: absolute;
        top: 12px;
        right: 20px;
        z-index: 20;
        display: flex;
        gap: 10px;
        align-items: center;
    }
    .top-right-actions .action-button {
        padding: 7px 14px;
        font-size: 13px;
        font-weight: 500;
        border-radius: 6px;
        border: none;
        color: white;
        cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
    }
    .top-right-actions .action-button:active { transform: scale(0.98); }

    .top-right-actions .action-button.accent { background-color: var(--app-accent-primary); }
    .top-right-actions .action-button.accent:hover { background-color: var(--app-accent-primary-hover); }

    .top-right-actions .action-button.danger {
        background-color: var(--app-surface-light);
        color: var(--app-text-primary-light-theme);
        border: 1px solid var(--app-border-light);
    }
    .top-right-actions .action-button.danger:hover {
        background-color: #e8e8ed;
    }

    .top-right-actions .action-button.secondary {
        background-color: var(--app-surface-light);
        color: var(--app-text-primary-light-theme);
        border: 1px solid var(--app-border-light);
    }
    .top-right-actions .action-button.secondary:hover { background-color: #e8e8ed; }
    .top-right-actions .action-button:disabled {
        background-color: #cccccc !important;
        color: #888888 !important;
        border-color: #cccccc !important;
        cursor: not-allowed;
        transform: none;
    }

    .dropdown-container {
        position: relative;
        display: inline-block;
    }
    .dropdown-content {
        display: none;
        position: absolute;
        right: 0;
        top: calc(100% + 5px);
        background-color: var(--app-surface-light);
        min-width: 200px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15);
        border: 1px solid var(--app-border-light);
        border-radius: 6px;
        padding: 8px;
        z-index: 25;
    }
    .dropdown-content button {
        width: 100%;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 4px;
        box-sizing: border-box;
        margin-bottom: 6px;
        background-color: transparent;
        color: var(--app-text-primary-light-theme);
        border: none;
        cursor: pointer;
        text-align: left;
        font-weight: 400;
        transition: background-color 0.15s ease;
    }
    .dropdown-content button:last-of-type { margin-bottom: 0; }
    .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content button:disabled {
        background-color: transparent !important;
        color: var(--app-text-secondary-light-theme) !important;
        opacity: 0.6;
        cursor: not-allowed;
    }

    .dropdown-content .checkbox-label {
        display: flex;
        align-items: center;
        font-size: 13px;
        font-weight: 400;
        padding: 6px 12px;
        margin-top: 4px;
        margin-bottom: 0;
        cursor: pointer;
        color: var(--app-text-primary-light-theme);
        border-radius: 4px;
    }
     .dropdown-content .checkbox-label:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content .checkbox-label input[type="checkbox"] {
        width: auto;
        margin-right: 8px;
        vertical-align: middle;
        accent-color: var(--app-accent-primary);
    }

    .tab-row {
      display: flex;
      gap: 0;
      justify-content: flex-start;
      padding: 0 20px;
      border-bottom: 1px solid var(--app-border-light);
      background-color: var(--app-surface-light);
      margin-top: 60px;
    }
    .tab-button {
      padding: 12px 18px;
      background: transparent;
      border: none;
      border-bottom: 2px solid transparent;
      color: var(--app-text-secondary-light-theme);
      font-size: 14px;
      font-weight: 500;
      border-radius: 0;
      cursor: pointer;
      transition: color 0.2s ease, border-color 0.2s ease;
      margin-right: 10px;
      margin-bottom: -1px;
    }
    .tab-button:hover {
        color: var(--app-text-primary-light-theme);
    }
    .tab-button.active {
        color: var(--app-accent-primary);
        border-bottom: 2px solid var(--app-accent-primary);
    }

    .tab-content-wrapper {
        flex-grow: 1;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 25px;
        overflow-y: auto;
    }

    .tab {
      display: none;
      width: 100%;
      height: 100%;
      margin: 0 auto;
      flex-direction: column;
      align-items: center;
    }
    .tab.active { display: flex; }

    .canvas-container-wrapper {
        border: none;
        background-color: var(--app-surface-light);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: visible !important;  /* CRITICAL: Changed from hidden to prevent clipping */
        margin: auto;
    }
    
    /* Ensure Fabric.js container doesn't clip */
    .canvas-container { 
        overflow: visible !important;
        position: relative !important;
    }
    canvas { display: block; }
    
    /* Original Picture Pathway specific styles - ADAPTED */
    .instruction { /* This might still exist for other purposes, but is not used for title/desc on canvas anymore */
      font-size: 22.4px;
      text-align: center;
      margin-bottom: 10px;
      line-height: 1.4;
      color: var(--app-text-primary-light-theme);
    }
    /* Note: .grid-container and .grid-wrapper CSS is no longer used for dynamic canvas content */
    /* Only for PDF export of answer key which uses cloned DOM */

    #exportArea { position: absolute; left: -9999px; top: 0; width: auto; height: auto;}
    
    /* --- RESPONSIVE STYLES FOR TABLET --- */
    @media (max-width: 1024px) {
        :root {
            --sidebar-width: 300px;
        }
        .panel {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 1000;
            transform: translateX(-100%);
        }
        .panel.is-open {
            transform: translateX(0);
        }
        .menu-toggle-btn {
            display: flex;
        }
        .menu-close-btn {
            display: block;
        }
        .tab-row {
            padding: 0 15px 0 70px;
        }
    }
    /* START: Contextual Toolbar CSS */
    #object-context-toolbar {
        position: absolute;
        top: 72px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--app-surface-light);
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        padding: 5px;
        display: flex;
        flex-direction: row;
        gap: 4px;
        z-index: 100;
        align-items: center;
        border: 1px solid var(--app-border-light);
    }
    .toolbar-group {
        display: flex;
        gap: 2px;
        align-items: center;
        padding: 0 4px;
    }
    .toolbar-group + .toolbar-group {
        border-left: 1px solid var(--app-border-light);
    }
    .toolbar-item {
        position: relative;
    }
    .context-btn {
        background: none;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 5px 7px;
        cursor: pointer;
        font-size: 15px; 
        color: var(--app-text-secondary-light-theme);
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        transition: background-color 0.2s, color 0.2s;
    }
    .context-btn:disabled {
        color: #c5c5c7;
        cursor: not-allowed;
    }
    .context-btn:not(:disabled):hover {
        background-color: #e8e8ed;
        color: var(--app-text-primary-light-theme);
    }
    .context-btn.active-dropdown {
        background-color: #ddeeff;
        color: var(--app-accent-primary);
    }
    #toolbarDeleteBtn:not(:disabled) {
        color: var(--app-accent-danger);
    }
    #object-context-toolbar .dropdown-content {
        display: none;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--app-surface-light);
        min-width: 150px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15);
        border: 1px solid var(--app-border-light);
        border-radius: 6px;
        padding: 8px;
        z-index: 101;
    }
    #object-context-toolbar .dropdown-content button {
        width: 100%;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 4px;
        box-sizing: border-box;
        margin-bottom: 6px;
        background-color: transparent;
        color: var(--app-text-primary-light-theme);
        border: none;
        cursor: pointer;
        text-align: left;
        font-weight: 400;
        transition: background-color 0.15s ease;
    }
    #object-context-toolbar .dropdown-content button:last-of-type {
        margin-bottom: 0;
    }
    #object-context-toolbar .dropdown-content button:hover {
        background-color: rgba(0,0,0,0.05);
    }
    /* END: Contextual Toolbar CSS */

    /* ============================================
       MODERN UNIFIED HEADER STYLES
       Exact implementation from wordsearch.html lines 251-450
       ============================================ */

    .tab-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 14px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        position: relative;
        z-index: 15;
        border-radius: 0;
        margin: 0;
        gap: 16px;
    }

    .tab-buttons-container {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .tab-button {
        padding: 10px 24px;
        font-size: 14px;
        font-weight: 600;
        border: none;
        background: rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(10px);
        position: relative;
    }

    .tab-button:hover {
        background: rgba(255, 255, 255, 0.25);
        color: white;
        transform: translateY(-1px);
    }

    .tab-button.active {
        background: rgba(255, 255, 255, 0.95);
        color: #667eea;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Header Actions Container */
    .header-actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-shrink: 0;
    }

    /* --- Zoom Controls --- */
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 6px;
        padding: 5px 10px;
        backdrop-filter: blur(10px);
    }

    .zoom-btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        color: white;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .zoom-btn:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .zoom-btn:active {
        background-color: rgba(255, 255, 255, 0.15);
    }

    .zoom-percentage {
        min-width: 45px;
        text-align: center;
        font-size: 13px;
        font-weight: 600;
        color: white;
        user-select: none;
    }

    /* --- Undo/Redo Controls --- */
    .history-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 6px;
        padding: 5px 10px;
        backdrop-filter: blur(10px);
    }

    .history-btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        color: white;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .history-btn:hover:not(:disabled) {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .history-btn:active:not(:disabled) {
        background-color: rgba(255, 255, 255, 0.15);
    }

    .history-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }

    /* Unlock All Button */
    .unlock-all-controls {
        display: none; /* Hidden by default */
        align-items: center;
        gap: 6px;
        padding: 4px 12px;
        background: rgba(255, 165, 0, 0.25);
        border-radius: 8px;
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 165, 0, 0.4);
    }

    .unlock-all-controls.visible {
        display: flex;
    }

    .unlock-all-btn {
        display: flex;
        align-items: center;
        gap: 6px;
        padding: 4px 10px;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 500;
        transition: all 0.2s ease;
        white-space: nowrap;
    }

    .unlock-all-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.05);
    }

    .unlock-all-btn i {
        font-size: 14px;
    }

    /* --- Dropdown Containers --- */
    .dropdown-container {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        background-color: white;
        min-width: 200px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        z-index: 1000;
        margin-top: 8px;
        padding: 8px 0;
    }

    .dropdown-content.show {
        display: block;
    }

    .dropdown-content button {
        display: block;
        width: 100%;
        padding: 10px 16px;
        border: none;
        background: none;
        text-align: left;
        cursor: pointer;
        font-size: 14px;
        color: #333;
        transition: background-color 0.2s;
    }

    .dropdown-content button:hover:not(:disabled) {
        background-color: #f5f5f5;
    }

    .dropdown-content button:disabled {
        color: #ccc;
        cursor: not-allowed;
    }

    /* --- Action Buttons --- */
    .action-button {
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .action-button.accent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .action-button.accent:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .action-button.download-btn {
        background: rgba(255, 255, 255, 0.95);
        color: #667eea;
        border: 2px solid rgba(255, 255, 255, 0.5);
    }

    .action-button.download-btn:hover {
        background: white;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .action-button.danger {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .action-button.danger:hover {
        background: rgba(255, 59, 48, 0.9);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
    }

  </style>
</head>
<body>
<div class="layout">
  <div id="menuOverlay" class="menu-overlay"></div>
  <div class="panel">
    <div class="panel-header">
      <h2 data-translate="picture.pathway.settings">Pathway Settings</h2>
      <button id="menuCloseBtn" class="menu-close-btn">&times;</button>
    </div>
    
    <div class="panel-content">
      
      <!-- Language Settings Accordion -->
      <div class="accordion-item">
          <button class="accordion-button" data-translate="picture.pathway.language.settings">Language Settings</button>
          <div class="accordion-content">
              <label for="languageSelect" data-translate="picture.pathway.language.label">Language:</label>
              <select id="languageSelect">
                  <option value="en" data-translate="language.english">English</option>
                  <option value="de" data-translate="language.german">Deutsch</option>
                  <option value="fr" data-translate="language.french">Fran√ßais</option>
                  <option value="es" data-translate="language.spanish">Espa√±ol</option>
                  <option value="pt" data-translate="language.portuguese">Portugu√™s</option>
                  <option value="it" data-translate="language.italian">Italiano</option>
                  <option value="nl" data-translate="language.dutch">Nederlands</option>
                  <option value="sv" data-translate="language.swedish">Svenska</option>
                  <option value="da" data-translate="language.danish">Dansk</option>
                  <option value="no" data-translate="language.norwegian">Norsk</option>
                  <option value="fi" data-translate="language.finnish">Suomi</option>
              </select>
              <p style="font-size: 12px; color: var(--app-text-secondary-dark-theme); margin-top: 10px;" data-translate="picture.pathway.language.description">
                  Selects the language for image library content only. UI language is controlled by the main language selector in the header.
              </p>
          </div>
      </div>
      <div class="accordion-item">
        <button class="accordion-button" data-translate="picture.pathway.page.setup">Page Setup</button>
        <div class="accordion-content">
          <label for="pageSizeSelect" data-translate="picture.pathway.page.size">Page Size:</label>
          <select id="pageSizeSelect">
            <option value="612x792" data-translate="page.size.letter.portrait">Letter Portrait (8.5√ó11")</option>
            <option value="792x612" data-translate="page.size.letter.landscape">Letter Landscape (11√ó8.5")</option>
            <option value="595x842" data-translate="page.size.a4.portrait">A4 Portrait (210√ó297mm)</option>
            <option value="842x595" data-translate="page.size.a4.landscape">A4 Landscape (297√ó210mm)</option>
            <option value="1200x1200" data-translate="page.size.square">Square (1200x1200)</option>
            <option value="custom" data-translate="page.size.custom">Custom</option>
          </select>
          <div id="customPageSizeInputs" style="display:none;">
            <label for="pageWidth" data-translate="picture.pathway.width.label">Width (px):</label>
            <input type="number" id="pageWidth" value="612">
            <label for="pageHeight" data-translate="picture.pathway.height.label">Height (px):</label>
            <input type="number" id="pageHeight" value="792">
          </div>
          <label for="pageColor" data-translate="picture.pathway.page.color">Page Color:</label>
          <input type="color" id="pageColor" value="#FFFFFF">
          <button id="setPageSizeBtn" data-translate="picture.pathway.apply.size">Apply Size</button>

          <h4 data-translate="picture.pathway.background.title">Background</h4>
          <label for="backgroundThemeSelect" data-translate="picture.pathway.background.theme">Background Theme:</label>
          <select id="backgroundThemeSelect">
            <option value="none" data-translate="none">None</option>
          </select>
          <div id="backgroundDictionary"><p class="dictionary-message" data-translate="picture.pathway.background.message">Select a theme for backgrounds.</p></div>
          <label for="backgroundOpacitySlider" data-translate="picture.pathway.background.opacity">Background Opacity:</label>
          <input type="range" id="backgroundOpacitySlider" min="0" max="1" step="0.05" value="1" disabled>

          <h4 data-translate="picture.pathway.border.title">Border</h4>
          <label for="borderThemeSelect" data-translate="picture.pathway.border.theme">Border Theme:</label>
          <select id="borderThemeSelect">
            <option value="none" data-translate="none">None</option>
          </select>
          <div id="borderDictionary">
            <p class="dictionary-message" data-translate="picture.pathway.border.message">Select a theme to see borders.</p>
          </div>
          <label for="borderOpacitySlider" data-translate="picture.pathway.border.opacity">Border Opacity:</label>
          <input type="range" id="borderOpacitySlider" min="0" max="1" value="1" step="0.05" disabled>
        </div>
      </div>

      <div class="accordion-item">
        <button class="accordion-button" data-translate="picture.pathway.text.tools">Text Tools</button>
        <div class="accordion-content">
          <h4 data-translate="picture.pathway.text.add.new">Add New Text</h4>
          <label for="textInput" data-translate="picture.pathway.text.content">Content:</label><input type="text" id="textInput" data-translate-placeholder="picture.pathway.text.placeholder" placeholder="Hello!">
          <button id="addTextBtn" data-translate="picture.pathway.text.add.button">Add Text</button>
          <h4 data-translate="picture.pathway.text.properties">Selected Text Properties</h4>
          <label for="textColor" data-translate="picture.pathway.text.color">Color:</label><input type="color" id="textColor" value="#333333" disabled>
          <label for="fontSize" data-translate="picture.pathway.text.size">Size:</label><input type="number" id="fontSize" value="48" min="8" disabled>
          <label for="fontFamily" data-translate="picture.pathway.text.font">Font:</label>
          <select id="fontFamily" disabled>
            <option value="Lexend Deca" data-translate="font.lexend">Lexend Deca</option>
            <option value="Baloo 2" data-translate="font.baloo">Baloo 2</option>
            <option value="Nunito" data-translate="font.nunito">Nunito</option>
            <option value="Quicksand" data-translate="font.quicksand">Quicksand</option>
            <option value="Fredoka" data-translate="font.fredoka">Fredoka</option>
            <option value="Arial" data-translate="font.arial">Arial</option>
            <option value="Verdana" data-translate="font.verdana">Verdana</option>
          </select>
          <label for="textStrokeColor" data-translate="picture.pathway.text.outline.color">Outline Color:</label><input type="color" id="textStrokeColor" value="#000000" disabled>
          <label for="textStrokeWidth" data-translate="picture.pathway.text.outline.width">Outline (0-10):</label><input type="range" id="textStrokeWidth" min="0" max="10" value="0" step="0.5" disabled>
        </div>
      </div>

      <div class="accordion-item">
        <button class="accordion-button" data-translate="picture.pathway.config">Pathway Configuration</button>
        <div class="accordion-content">
          <label for="gameModeSelect" data-translate="picture.pathway.game.mode"><strong>Game Mode:</strong></label>
          <select id="gameModeSelect">
            <option value="pathway" data-translate="picture.pathway.mode.pathway">Picture Pathway</option>
            <option value="classic-maze" data-translate="picture.pathway.mode.classic.maze">Classic Maze</option>
            <option value="choose-path" data-translate="picture.pathway.mode.choose.path">Choose the Right Path</option>
          </select>

          <label for="includeNameDate" class="checkbox-label" style="margin-top: 15px;">
            <input type="checkbox" id="includeNameDate" /><span data-translate="picture.pathway.include.name.date">Include Name/Date Fields</span>
          </label>
        </div>
      </div>


      <!-- Classic Maze Settings -->
      <div class="accordion-item" id="classicMazeSettingsAccordion" style="display:none;">
        <button class="accordion-button" data-translate="picture.pathway.settings.classic.maze">Classic Maze Settings</button>
        <div class="accordion-content">
          <h4 data-translate="picture.pathway.maze.settings">Maze Settings</h4>
          <label for="mazeGridSize" data-translate="picture.pathway.grid.size">Grid Size:</label>
          <select id="mazeGridSize">
            <option value="15" selected data-translate="picture.pathway.option.grid.15">15√ó15 (Default)</option>
            <option value="16" data-translate="picture.pathway.option.grid.16">16√ó16</option>
            <option value="17" data-translate="picture.pathway.option.grid.17">17√ó17</option>
            <option value="18" data-translate="picture.pathway.option.grid.18">18√ó18</option>
            <option value="19" data-translate="picture.pathway.option.grid.19">19√ó19</option>
            <option value="20" data-translate="picture.pathway.option.grid.20">20√ó20</option>
          </select>

          <label for="mazeNumPaths" style="margin-top:15px;" data-translate="picture.pathway.num.paths">Number of Paths:</label>
          <select id="mazeNumPaths">
            <option value="1" selected data-translate="picture.pathway.option.paths.1">1 Path</option>
            <option value="2" data-translate="picture.pathway.option.paths.2">2 Paths (1 correct, 1 dead-end)</option>
            <option value="3" data-translate="picture.pathway.option.paths.3">3 Paths (1 correct, 2 dead-ends)</option>
          </select>

          <h4 style="margin-top:20px;" data-translate="picture.pathway.collectible.settings">Collectible Settings</h4>

          <label for="numCollectibleImages" data-translate="picture.pathway.num.images">Number of Collectible Images:</label>
          <select id="numCollectibleImages">
            <option value="1" data-translate="picture.pathway.option.images.1">1 Image</option>
            <option value="2" data-translate="picture.pathway.option.images.2">2 Images</option>
            <option value="3" data-translate="picture.pathway.option.images.3">3 Images</option>
            <option value="4" selected data-translate="picture.pathway.option.images.4">4 Images</option>
          </select>

          <label for="copiesPerImageMin" style="margin-top:10px;" data-translate="picture.pathway.copies.min">Minimum Copies per Image:</label>
          <select id="copiesPerImageMin">
            <option value="1" selected>1</option>
            <option value="2">2</option>
            <option value="3">3</option>
          </select>

          <label for="copiesPerImageMax" style="margin-top:10px;" data-translate="picture.pathway.copies.max">Maximum Copies per Image:</label>
          <select id="copiesPerImageMax">
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
            <option value="7">7</option>
            <option value="8">8</option>
            <option value="9">9</option>
            <option value="10" selected>10</option>
          </select>

          <h4 style="margin-top:20px;" data-translate="picture.pathway.wall.appearance">Wall Appearance</h4>

          <label for="mazeWallColor" data-translate="picture.pathway.wall.color">Wall Color:</label>
          <input type="color" id="mazeWallColor" value="#4CAF50" style="width:60px; height:30px; border:1px solid #555; border-radius:4px; cursor:pointer;">

          <label for="mazeWallThickness" style="margin-top:10px;" data-translate="picture.pathway.wall.thickness">Wall Thickness:</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="mazeWallThickness" min="1" max="10" value="3" style="flex:1;">
            <span id="wallThicknessValue" style="min-width:30px; text-align:right;">3px</span>
          </div>

          <label for="mazeWallOpacity" style="margin-top:10px;" data-translate="picture.pathway.wall.opacity">Wall Opacity:</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="mazeWallOpacity" min="10" max="100" value="100" style="flex:1;">
            <span id="wallOpacityValue" style="min-width:30px; text-align:right;">100%</span>
          </div>

          <details style="margin-top:15px;">
            <summary style="cursor:pointer; font-weight:600; color:#64B5F6;" data-translate="picture.pathway.advanced.settings">‚öôÔ∏è Advanced Settings</summary>
            <div style="margin-top:10px; padding-left:10px;">
              <label for="mazePathLengthMin" data-translate="picture.pathway.path.length.min">Path Length (Min):</label>
              <input type="number" id="mazePathLengthMin" value="8" min="4" max="30" style="width:80px;">

              <label for="mazePathLengthMax" data-translate="picture.pathway.path.length.max">Path Length (Max):</label>
              <input type="number" id="mazePathLengthMax" value="12" min="4" max="30" style="width:80px;">
            </div>
          </details>
        </div>
      </div>

      <!-- Choose the Right Path Settings -->
      <div class="accordion-item" id="choosePathSettingsAccordion" style="display:none;">
        <button class="accordion-button" data-translate="picture.pathway.settings.choose.path">Choose the Right Path Settings</button>
        <div class="accordion-content">
          <label for="mazeDirection" data-translate="picture.pathway.maze.direction">Maze Direction:</label>
          <select id="mazeDirection">
            <option value="bottom-top" selected data-translate="picture.pathway.option.direction.bottom.top">Bottom to Top ‚Üë</option>
            <option value="top-bottom" data-translate="picture.pathway.option.direction.top.bottom">Top to Bottom ‚Üì</option>
            <option value="left-right" data-translate="picture.pathway.option.direction.left.right">Left to Right ‚Üí</option>
            <option value="right-left" data-translate="picture.pathway.option.direction.right.left">Right to Left ‚Üê</option>
          </select>

          <label for="choosePathGridSize" style="margin-top:15px;" data-translate="picture.pathway.grid.size">Grid Size:</label>
          <select id="choosePathGridSize">
            <option value="15" selected data-translate="picture.pathway.option.grid.15">15√ó15 (Default)</option>
            <option value="16" data-translate="picture.pathway.option.grid.16">16√ó16</option>
            <option value="17" data-translate="picture.pathway.option.grid.17">17√ó17</option>
            <option value="18" data-translate="picture.pathway.option.grid.18">18√ó18</option>
            <option value="19" data-translate="picture.pathway.option.grid.19">19√ó19</option>
            <option value="20" data-translate="picture.pathway.option.grid.20">20√ó20</option>
          </select>

          <label for="choosePathNumPaths" style="margin-top:15px;" data-translate="picture.pathway.num.paths">Number of Paths:</label>
          <select id="choosePathNumPaths">
            <option value="1" data-translate="picture.pathway.option.paths.1">1 Path</option>
            <option value="2" data-translate="picture.pathway.option.paths.2">2 Paths (1 correct, 1 dead-end)</option>
            <option value="3" selected data-translate="picture.pathway.option.paths.3">3 Paths (1 correct, 2 dead-ends)</option>
          </select>

          <h4 style="margin-top:20px;" data-translate="picture.pathway.wall.appearance">Wall Appearance</h4>

          <label for="choosePathWallColor" data-translate="picture.pathway.wall.color">Wall Color:</label>
          <input type="color" id="choosePathWallColor" value="#4CAF50" style="width:60px; height:30px; border:1px solid #555; border-radius:4px; cursor:pointer;">

          <label for="choosePathWallThickness" style="margin-top:10px;" data-translate="picture.pathway.wall.thickness">Wall Thickness:</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="choosePathWallThickness" min="1" max="10" value="3" style="flex:1;">
            <span id="choosePathWallThicknessValue" style="min-width:30px; text-align:right;">3px</span>
          </div>

          <label for="choosePathWallOpacity" style="margin-top:10px;" data-translate="picture.pathway.wall.opacity">Wall Opacity:</label>
          <div style="display:flex; align-items:center; gap:10px;">
            <input type="range" id="choosePathWallOpacity" min="10" max="100" value="100" style="flex:1;">
            <span id="choosePathWallOpacityValue" style="min-width:30px; text-align:right;">100%</span>
          </div>
        </div>
      </div>

      <div class="accordion-item">
        <button class="accordion-button" data-translate="picture.pathway.image.library">Image Library</button>
        <div class="accordion-content">
          <label for="selectionType" data-translate="picture.pathway.add.image.as">Add image as:</label>
          <select id="selectionType">
            <option value="start" data-translate="picture.pathway.start.image">Start Image (1 needed)</option>
            <option value="end" data-translate="picture.pathway.end.image">End Image (1 needed)</option>
            <option value="path" data-translate="picture.pathway.path.image">Path Image (‚â•1 needed)</option>
            <option value="distractor" data-translate="picture.pathway.distractor.image">Distractor Image (‚â•6 recommended)</option>
            <option value="decoration" data-translate="picture.pathway.decoration.image">üé® Decoration (place anywhere)</option>
          </select>
          <label for="themeSelect" data-translate="picture.pathway.select.theme">Select Theme:</label>
          <select id="themeSelect"></select>
          <label for="searchInput" data-translate="picture.pathway.search.images">Search Images:</label>
          <input type="text" id="searchInput" data-translate-placeholder="picture.pathway.search.placeholder" placeholder="e.g., apple, car" />
          <label data-translate="picture.pathway.available.images">Available Images:</label>
          <div class="dictionary" id="dictionary"><p class="dictionary-message" data-translate="picture.pathway.loading.images">Loading images...</p></div>

          <h4 style="margin-top:15px;" data-translate="picture.pathway.selected.images">Selected Images</h4>
          <div class="selection-panel" id="startPanel">
            <h4><span id="startLabel" data-translate="picture.pathway.start.image">Start Image</span> (<span id="startCount">0</span>/1)</h4>
            <div class="selected-images" id="startSelection"></div>
          </div>
          <div class="selection-panel" id="endPanel">
            <h4><span id="endLabel" data-translate="picture.pathway.end.image">End Image</span> (<span id="endCount">0</span>/1)</h4>
            <div class="selected-images" id="endSelection"></div>
          </div>
          <div class="selection-panel" id="pathPanel">
            <h4><span id="pathLabel" data-translate="picture.pathway.path.image">Path Images</span> (<span id="pathCount">0</span>/4 recommended)</h4>
            <div class="selected-images" id="pathSelection"></div>
          </div>
          <div class="selection-panel" id="distractorPanel">
            <h4><span id="distractorLabel" data-translate="picture.pathway.distractor.image">Distractor Images</span> (<span id="distractorCount">0</span>)</h4>
            <div class="selected-images" id="distractorSelection"></div>
          </div>
          <button id="clearSelection" data-translate="picture.pathway.clear.selections">Clear Selections</button>
        </div>
      </div>
      
      <div class="accordion-item">
            <button class="accordion-button" data-translate="picture.pathway.upload.custom">Upload Custom Images</button>
            <div class="accordion-content">
                <label for="imageUploadInput" data-translate="picture.pathway.upload.select">Select image(s) to upload:</label>
                <div class="custom-file-input-wrapper">
                    <button type="button" class="custom-file-button" id="customFileButton" data-translate="picture.pathway.upload.button">Choose files</button>
                    <span class="custom-file-status" id="customFileStatus" data-translate="picture.pathway.upload.no.file">No file chosen</span>
                </div>
                <input type="file" id="imageUploadInput" multiple accept="image/*">
                <label style="margin-top:10px;" data-translate="picture.pathway.uploaded.images">Your Uploaded Images (This Session):</label>
                <div id="uploadedImagesPreview">
                    <p class="dictionary-message" data-translate="picture.pathway.uploaded.placeholder">Your uploaded images will appear here.</p>
                </div>
            </div>
        </div>

    </div>
    <div class="panel-footer">
        <div id="messageArea" class="message-area"></div>
    </div>
  </div>

  <div class="main">
    <button id="menuToggleBtn" class="menu-toggle-btn"><i class="fas fa-bars"></i></button>

    <div id="object-context-toolbar" style="display:none;">
        <div class="toolbar-group">
            <div class="toolbar-item">
                <button class="context-btn" id="layersBtn" data-translate-title="toolbar.layers" title="Layers"><i class="fas fa-layer-group"></i></button>
                <div class="dropdown-content" id="layersDropdown">
                    <button id="toolbarBringToFrontBtn" data-translate="toolbar.bring.to.front">Bring to Front</button>
                    <button id="toolbarBringForwardBtn" data-translate="toolbar.bring.forward">Bring Forward</button>
                    <button id="toolbarSendBackwardBtn" data-translate="toolbar.send.backward">Send Backward</button>
                    <button id="toolbarSendToBackBtn" data-translate="toolbar.send.to.back">Send to Back</button>
                </div>
            </div>
        </div>
        <div class="toolbar-group">
            <div class="toolbar-item">
                <button class="context-btn" id="alignBtn" data-translate-title="toolbar.align" title="Align"><i class="fas fa-th"></i></button>
                <div class="dropdown-content" id="alignDropdown" style="min-width: 220px; padding: 12px;">
                    <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.align.selected">Align Selected:</p>
                    <div>
                        <button class="context-btn" id="alignLeftBtn" data-translate-title="toolbar.align.left" title="Align Left"><i class="fas fa-align-left"></i></button>
                        <button class="context-btn" id="alignHCenterBtn" data-translate-title="toolbar.center.h" title="Center Horizontally"><i class="fas fa-align-center"></i></button>
                        <button class="context-btn" id="alignRightBtn" data-translate-title="toolbar.align.right" title="Align Right"><i class="fas fa-align-right"></i></button>
                    </div>
                    <div style="margin-top: 5px;">
                        <button class="context-btn" id="alignTopBtn" data-translate-title="toolbar.align.top" title="Align Top"><i class="fas fa-long-arrow-alt-up"></i></button>
                        <button class="context-btn" id="alignVCenterBtn" data-translate-title="toolbar.center.v" title="Center Vertically"><i class="fas fa-grip-lines"></i></button>
                        <button class="context-btn" id="alignBottomBtn" data-translate-title="toolbar.align.bottom" title="Align Bottom"><i class="fas fa-long-arrow-alt-down"></i></button>
                    </div>
                    <hr style="margin:8px 0; border:none; border-top:1px solid #eee;">
                    <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.align.to.page">Align to Page:</p>
                    <div>
                        <button class="context-btn" id="centerHCanvasBtn" data-translate-title="toolbar.center.page.h" title="Center on Page Horizontally"><i class="fas fa-arrows-alt-h"></i></button>
                        <button class="context-btn" id="centerVCanvasBtn" data-translate-title="toolbar.center.page.v" title="Center on Page Vertically"><i class="fas fa-arrows-alt-v"></i></button>
                    </div>
                </div>
            </div>
        </div>
        <div class="toolbar-group">
            <button class="context-btn" id="toolbarLockBtn" data-translate-title="toolbar.lockUnlock" title="Lock/Unlock"><i class="fas fa-lock-open"></i></button>
        </div>
        <div class="toolbar-group">
            <button class="context-btn" id="toolbarDeleteBtn" data-translate-title="toolbar.delete" title="Delete Selected"><i class="fas fa-trash-alt"></i></button>
        </div>
    </div>
    <div class="tab-row">
                <div class="tab-buttons-container">
                    <button class="tab-button active" data-tab="worksheetTab" data-translate="picture.pathway.tab.worksheet">Worksheet</button>
                    <button class="tab-button" data-tab="answerKeyTab" data-translate="picture.pathway.tab.answer">Answer Key</button>
                </div>
                <div class="header-actions">
                    <div class="zoom-controls">
                        <button id="zoomOutBtn" class="zoom-btn" data-translate-title="zoomOut" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                        <span id="zoomPercentage" class="zoom-percentage">100%</span>
                        <button id="zoomInBtn" class="zoom-btn" data-translate-title="zoomIn" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                        <button id="zoomResetBtn" class="zoom-btn" data-translate-title="zoomReset" title="Reset Zoom"><i class="fas fa-compress-arrows-alt"></i></button>
                    </div>
                    <div class="history-controls">
                        <button id="undoBtn" class="history-btn" data-translate-title="undo" title="Undo (Ctrl+Z)" disabled><i class="fas fa-undo"></i></button>
                        <button id="redoBtn" class="history-btn" data-translate-title="redo" title="Redo (Ctrl+Y)" disabled><i class="fas fa-redo"></i></button>
                    </div>
                    <!-- Unlock All Button (shown when objects are locked) -->
                    <div id="unlockAllControls" class="unlock-all-controls">
                        <button id="unlockAllBtn" class="unlock-all-btn" data-translate-title="toolbar.unlockAll" title="Unlock All Locked Objects">
                            <i class="fas fa-unlock"></i>
                            <span data-translate="toolbar.unlockAll">Unlock All</span>
                        </button>
                    </div>
                    <div class="dropdown-container">
                        <button id="generateDropdownBtn" class="action-button accent"><span data-translate="picture.pathway.generate">Create</span> <i class="fas fa-caret-down"></i></button>
                        <div id="generateDropdownContent" class="dropdown-content">
                            <button id="generateWorksheetBtn" data-translate="picture.pathway.generate.worksheet">New Worksheet</button>
                            <button id="generateAnswerKeyBtn" disabled data-translate="picture.pathway.generate.answer">Answer Key</button>
                        </div>
                    </div>
                    <div class="dropdown-container">
                        <button id="downloadDropdownBtn" class="action-button download-btn"><span data-translate="picture.pathway.download">Download</span> <i class="fas fa-caret-down" style="margin-left: 5px;"></i></button>
                        <div id="downloadDropdownContent" class="dropdown-content">
                            <button id="downloadWorksheetJpegBtn" data-translate="picture.pathway.download.worksheet.jpeg">Worksheet (JPEG)</button>
                            <button id="downloadAnswerKeyJpegBtn" disabled data-translate="picture.pathway.download.answer.jpeg">Answer Key (JPEG)</button>
                            <hr style="margin: 6px 0; border-color: #eee;">
                            <button id="downloadWorksheetPdfBtn" data-translate="picture.pathway.download.worksheet.pdf">Worksheet (PDF)</button>
                            <button id="downloadAnswerKeyPdfBtn" disabled data-translate="picture.pathway.download.answer.pdf">Answer Key (PDF)</button>
                            <hr style="margin: 6px 0; border-color: #eee;">
                            <label class="checkbox-label" id="grayscaleLabel">
                                <input type="checkbox" id="grayscaleToggle" /><span data-translate="common.grayscale">Grayscale</span>
                            </label>
                        </div>
                    </div>
                    <button id="clearBtn" class="action-button danger" data-translate="picture.pathway.clear.all">Clear All</button>
                </div>
            </div>
    <div class="tab-content-wrapper">
      <div class="tab active" id="worksheetTab">
          <div class="canvas-container-wrapper" id="worksheetCanvasWrapper">
              <canvas id="worksheetCanvasElement"></canvas>
          </div>
      </div>
      <div class="tab" id="answerKeyTab">
           <div class="canvas-container-wrapper" id="answerKeyCanvasWrapper">
              <canvas id="answerKeyCanvasElement"></canvas>
          </div>
      </div>
    </div>
  </div>
</div>
<div id="exportArea"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
// MUST BE GLOBAL - Before DOMContentLoaded
// Separate UI locale (from URL) and content locale (from sidebar selector)
let uiLocale = 'en';  // UI language (for interface translations) - from URL parameter
let currentLocale = 'en';  // Content language (for image library) - can be changed by sidebar selector

// Initialize locale from URL if present
const urlParams = new URLSearchParams(window.location.search);
const localeParam = urlParams.get('locale');
if (localeParam) {
    uiLocale = localeParam;  // UI language comes from URL (parent app header)
    currentLocale = localeParam;  // Initial content language matches UI language
}
window.uiLocale = uiLocale;
window.currentLocale = currentLocale;

// Translation functions
function t(key) {
  if (typeof translations === 'undefined') {
    console.warn('Translations not loaded, returning key:', key);
    return key;
  }
  // Use uiLocale for UI translations, fallback to currentLocale, then to English
  const locale = window.uiLocale || window.currentLocale || 'en';
  return translations[locale]?.[key] || translations.en?.[key] || key;
}
window.t = t;

function applyTranslations() {
  console.log('[Picture Path] Applying UI translations for locale:', window.uiLocale || window.currentLocale);
  console.log('[Picture Path] Content locale:', window.currentLocale);

  document.querySelectorAll('[data-translate]').forEach(el => {
    const key = el.getAttribute('data-translate');
    el.textContent = t(key);
  });
  document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
    const key = el.getAttribute('data-translate-placeholder');
    el.placeholder = t(key);
  });
  document.querySelectorAll('[data-translate-title]').forEach(el => {
    const key = el.getAttribute('data-translate-title');
    el.title = t(key);
  });
}
window.applyTranslations = applyTranslations;

document.addEventListener("DOMContentLoaded", function() {
  const accordionButtons = document.querySelectorAll('.accordion-button');
  accordionButtons.forEach(button => {
      button.addEventListener('click', () => {
          const content = button.nextElementSibling;
          button.classList.toggle('active');
          content.classList.toggle('active');
      });
  });
  // Accordions start closed - removed auto-open code

  /* --- Responsive Sidebar Logic --- */
  const panel = document.querySelector('.panel');
  const menuToggleBtn = document.getElementById('menuToggleBtn');
  const menuCloseBtn = document.getElementById('menuCloseBtn');
  const menuOverlay = document.getElementById('menuOverlay');
  
  const openMenu = () => {
      panel.classList.add('is-open');
      menuOverlay.classList.add('is-active');
  };
  const closeMenu = () => {
      panel.classList.remove('is-open');
      menuOverlay.classList.remove('is-active');
  };

  menuToggleBtn.addEventListener('click', openMenu);
  menuCloseBtn.addEventListener('click', closeMenu);
  menuOverlay.addEventListener('click', closeMenu);

  /********************************
   * Global State & Element Caching
   ********************************/
  let allImages = []; // Stores images for the currently selected theme
  let uploadedImages = []; // Stores user-uploaded images for current session
  let allImagesCache = {}; // PERFORMANCE: Cache preloaded themes to avoid refetching
  let selectedStartImage = null;
  let selectedEndImage = null;
  let selectedPathImages = [];
  let selectedDistractorImages = [];
  let selectedTheme = 'all';
  let messageTimeout = null;
  let lastGeneratedData = null; // Stores complete puzzle data for regeneration
  const downloadMultiplier = 6; // For high-res printing

  const includeNameDateCheckbox = document.getElementById('includeNameDate');
  const selectionTypeSelect = document.getElementById('selectionType');
  const searchInput = document.getElementById('searchInput');
  
  // Language selector - set to current content locale
  const languageSelect = document.getElementById('languageSelect');
  if (languageSelect) {
      languageSelect.value = currentLocale;
      // Apply initial translations
      if (typeof applyTranslations !== 'undefined') {
          applyTranslations();
      }
  }

  // Initialize UnifiedLanguageManager for content language (image library)
  if (typeof window.UnifiedLanguageManager !== 'undefined') {
      window.languageManager = window.UnifiedLanguageManager;

      // Register callback to reload image library when content language changes
      window.languageManager.onLanguageChange(function(newLocale, oldLocale) {
          console.log('[Picture Path] Content language changed from', oldLocale, 'to', newLocale);
          currentLocale = newLocale;
          window.currentLocale = newLocale;

          // Reload themes and dictionary with new locale
          loadThemes();
          if (selectedTheme && selectedTheme !== 'all') {
              loadDictionary();
          }
      });
  } else {
      // Fallback mode with direct event handler (backward compatibility)
      console.warn('[Picture Path] UnifiedLanguageManager not found, using fallback mode');
      if (languageSelect) {
          languageSelect.addEventListener('change', function() {
              const newLocale = this.value;
              currentLocale = newLocale;
              window.currentLocale = newLocale;

              // Reload themes and dictionary with new locale (do NOT reload UI translations)
              loadThemes();
              if (selectedTheme && selectedTheme !== 'all') {
                  loadDictionary();
              }
          });
      }
  }
  const themeSelect = document.getElementById('themeSelect');
  const dictionaryDiv = document.getElementById('dictionary');
  const startSelectionDiv = document.getElementById('startSelection');
  const endSelectionDiv = document.getElementById('endSelection');
  const pathSelectionDiv = document.getElementById('pathSelection');
  const distractorSelectionDiv = document.getElementById('distractorSelection');
  const startCountSpan = document.getElementById('startCount');
  const endCountSpan = document.getElementById('endCount');
  const pathCountSpan = document.getElementById('pathCount');
  const distractorCountSpan = document.getElementById('distractorCount');
  const clearSelectionBtn = document.getElementById('clearSelection');
  const messageArea = document.getElementById('messageArea');
  const imageUploadInput = document.getElementById("imageUploadInput");
  const uploadedImagesPreviewDiv = document.getElementById("uploadedImagesPreview");
  const customFileButton = document.getElementById("customFileButton");
  const customFileStatus = document.getElementById("customFileStatus");

  const generateDropdownBtn = document.getElementById("generateDropdownBtn");
  const generateDropdownContent = document.getElementById("generateDropdownContent");
  const generateWorksheetBtn = document.getElementById("generateWorksheetBtn");
  const generateAnswerKeyBtn = document.getElementById("generateAnswerKeyBtn");

  const downloadDropdownBtn = document.getElementById("downloadDropdownBtn");
  const downloadDropdownContent = document.getElementById("downloadDropdownContent");
  const downloadWorksheetJpegBtn = document.getElementById("downloadWorksheetJpegBtn");
  const downloadAnswerKeyJpegBtn = document.getElementById("downloadAnswerKeyJpegBtn");
  const downloadWorksheetPdfBtn = document.getElementById("downloadWorksheetPdfBtn");
  const downloadAnswerKeyPdfBtn = document.getElementById("downloadAnswerKeyPdfBtn");

  const clearBtn = document.getElementById("clearBtn");
  const grayscaleToggle = document.getElementById('grayscaleToggle');

  // Header Controls - Zoom
  const zoomInBtn = document.getElementById('zoomInBtn');
  const zoomOutBtn = document.getElementById('zoomOutBtn');
  const zoomResetBtn = document.getElementById('zoomResetBtn');
  const zoomPercentage = document.getElementById('zoomPercentage');

  // Header Controls - Undo/Redo
  const undoBtn = document.getElementById('undoBtn');
  const redoBtn = document.getElementById('redoBtn');
  const unlockAllBtn = document.getElementById('unlockAllBtn');
  const unlockAllControls = document.getElementById('unlockAllControls');

  const worksheetCanvasWrapper = document.getElementById('worksheetCanvasWrapper');
  const worksheetCanvasElement = document.getElementById('worksheetCanvasElement');
  const answerKeyCanvasWrapper = document.getElementById('answerKeyCanvasWrapper');
  const answerKeyCanvasElement = document.getElementById('answerKeyCanvasElement');

  let worksheetCanvas;
  let answerKeyCanvas;
  let currentCanvasConfig = { width: 612, height: 792 }; // Letter Portrait default
  let userZoomLevel = 1.0; // User-controlled zoom level (100% = 1.0)

  // Undo/Redo state management
  const MAX_HISTORY = 20; // Maximum number of history states to keep
  let historyStack = []; // Stack of previous canvas states
  let redoStack = []; // Stack of undone states for redo
  let isRestoringState = false; // Flag to prevent saving state while restoring
  let isGenerating = false; // Flag to prevent saving state during worksheet generation

  const pageSizeSelect = document.getElementById('pageSizeSelect');
  const customPageSizeInputsDiv = document.getElementById('customPageSizeInputs');
  const pageWidthInput = document.getElementById('pageWidth');
  const pageHeightInput = document.getElementById('pageHeight');
  const setPageSizeBtn = document.getElementById('setPageSizeBtn');
  const pageColorInput = document.getElementById('pageColor');
  
  const backgroundThemeSelect = document.getElementById('backgroundThemeSelect');
  const backgroundDictionary = document.getElementById('backgroundDictionary');
  const backgroundOpacitySlider = document.getElementById('backgroundOpacitySlider');
  
  const borderThemeSelect = document.getElementById('borderThemeSelect');
  const borderDictionary = document.getElementById('borderDictionary');
  const borderOpacitySlider = document.getElementById('borderOpacitySlider');

  const textInput = document.getElementById('textInput');
  const addTextBtn = document.getElementById('addTextBtn');
  const textColorInput = document.getElementById('textColor');
  const fontSizeInput = document.getElementById('fontSize');
  const fontFamilySelect = document.getElementById('fontFamily');
  const textStrokeColorInput = document.getElementById('textStrokeColor');
  const textStrokeWidthInput = document.getElementById('textStrokeWidth');

  // Toolbar References
  const objectContextToolbar = document.getElementById('object-context-toolbar');
  const layersBtn = document.getElementById('layersBtn');
  const layersDropdown = document.getElementById('layersDropdown');
  const toolbarBringToFrontBtn = document.getElementById('toolbarBringToFrontBtn');
  const toolbarBringForwardBtn = document.getElementById('toolbarBringForwardBtn');
  const toolbarSendBackwardBtn = document.getElementById('toolbarSendBackwardBtn');
  const toolbarSendToBackBtn = document.getElementById('toolbarSendToBackBtn');
  const alignBtn = document.getElementById('alignBtn');
  const alignDropdown = document.getElementById('alignDropdown');
  const toolbarLockBtn = document.getElementById('toolbarLockBtn');
  const toolbarDeleteBtn = document.getElementById('toolbarDeleteBtn');
  const allToolbarButtons = objectContextToolbar.querySelectorAll('.context-btn');


  function setupDropdown(button, content) {
      if (!button || !content) return;
       button.addEventListener('click', function(event) {
          content.style.display = content.style.display === 'block' ? 'none' : 'block';
          event.stopPropagation();
       });
       return {button, content};
  }
  const generateDropdown = setupDropdown(generateDropdownBtn, generateDropdownContent);
  const downloadDropdown = setupDropdown(downloadDropdownBtn, downloadDropdownContent);

  window.addEventListener('click', function(event) {
      if (activePopover && !activePopover.parentElement.contains(event.target)) {
        closeAllPopovers();
      }
      if (generateDropdown && generateDropdown.content.style.display === 'block' && !generateDropdown.button.contains(event.target) && !generateDropdown.content.contains(event.target)) {
          generateDropdown.content.style.display = 'none';
      }
      if (downloadDropdown && downloadDropdown.content.style.display === 'block' && !downloadDropdown.button.contains(event.target) && !downloadDropdown.content.contains(event.target)) {
          downloadDropdown.content.style.display = 'none';
      }
  });

  // START: New Toolbar Functions
  let activePopover = null;
  
  function getActiveCanvas() {
    const activeTab = document.querySelector('.tab.active');
    // If the answer key tab is active, return that canvas, otherwise default to the worksheet canvas.
    return activeTab && activeTab.id === 'answerKeyTab' ? answerKeyCanvas : worksheetCanvas;
  }

  function togglePopover(popover) {
      const isOpening = popover.style.display !== 'block';
      closeAllPopovers();
      if (isOpening) {
          popover.style.display = 'block';
          activePopover = popover;
      }
  }

  function closeAllPopovers() {
      if (activePopover) {
          activePopover.style.display = 'none';
          activePopover = null;
      }
      if(document.getElementById('layersBtn')) document.getElementById('layersBtn').classList.remove('active-dropdown');
      if(document.getElementById('alignBtn')) document.getElementById('alignBtn').classList.remove('active-dropdown');
  }

  function bringObjectToFront() {
      const activeCanvas = getActiveCanvas();
      const activeObject = activeCanvas.getActiveObject();
      if (activeObject) {
          activeCanvas.bringToFront(activeObject);
          enforceZOrder(activeCanvas);
          activeCanvas.renderAll();
      }
      closeAllPopovers();
  }

  function bringObjectForward() {
      const activeCanvas = getActiveCanvas();
      const activeObject = activeCanvas.getActiveObject();
      if (activeObject) {
          activeCanvas.bringForward(activeObject);
          enforceZOrder(activeCanvas);
          activeCanvas.renderAll();
      }
      closeAllPopovers();
  }

  function sendObjectBackward() {
      const activeCanvas = getActiveCanvas();
      const activeObject = activeCanvas.getActiveObject();
      if (activeObject) {
          activeCanvas.sendBackwards(activeObject);
          enforceZOrder(activeCanvas);
          activeCanvas.renderAll();
      }
      closeAllPopovers();
  }

  function sendObjectToBack() {
      const activeCanvas = getActiveCanvas();
      const activeObject = activeCanvas.getActiveObject();
      if (activeObject) {
          activeCanvas.sendToBack(activeObject);
          enforceZOrder(activeCanvas);
          activeCanvas.renderAll();
      }
      closeAllPopovers();
  }

  // ============================================
  // UNDO/REDO SYSTEM - Full state management with custom properties
  // ============================================

  function saveCanvasState() {
      if (isRestoringState || isGenerating) return; // Don't save during restore or generation

      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;

      // Save canvas state with ALL custom properties to prevent duplication bugs
      const state = JSON.stringify(activeCanvas.toJSON([
          'selectable', 'evented', 'hasControls', 'hasBorders', 'lockMovementX', 'lockMovementY',
          'lockScalingX', 'lockScalingY', 'lockRotation', 'hoverCursor',
          'isGeneratedItem', 'isAnswerKeyItem', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc',
          'isBorder', 'isBackground', 'originalIndex', 'crossOrigin', 'objectCaching'
      ]));

      historyStack.push(state);
      if (historyStack.length > MAX_HISTORY) {
          historyStack.shift(); // Remove oldest state if exceeding max history
      }

      redoStack = []; // Clear redo stack when new action is performed
      updateUndoRedoButtons();
  }

  function undo() {
      if (historyStack.length === 0) return;

      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;

      // Save current state to redo stack before undoing
      const currentState = JSON.stringify(activeCanvas.toJSON([
          'selectable', 'evented', 'hasControls', 'hasBorders', 'lockMovementX', 'lockMovementY',
          'lockScalingX', 'lockScalingY', 'lockRotation', 'hoverCursor',
          'isGeneratedItem', 'isAnswerKeyItem', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc',
          'isBorder', 'isBackground', 'originalIndex', 'crossOrigin', 'objectCaching'
      ]));
      redoStack.push(currentState);

      // Pop and restore previous state
      const previousState = historyStack.pop();
      restoreCanvasState(previousState);
      updateUndoRedoButtons();
  }

  function redo() {
      if (redoStack.length === 0) return;

      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;

      // Save current state to history stack before redoing
      const currentState = JSON.stringify(activeCanvas.toJSON([
          'selectable', 'evented', 'hasControls', 'hasBorders', 'lockMovementX', 'lockMovementY',
          'lockScalingX', 'lockScalingY', 'lockRotation', 'hoverCursor',
          'isGeneratedItem', 'isAnswerKeyItem', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc',
          'isBorder', 'isBackground', 'originalIndex', 'crossOrigin', 'objectCaching'
      ]));
      historyStack.push(currentState);

      // Pop and restore next state
      const nextState = redoStack.pop();
      restoreCanvasState(nextState);
      updateUndoRedoButtons();
  }

  function restoreCanvasState(state) {
      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;

      isRestoringState = true; // Set flag to prevent saving during restore

      activeCanvas.loadFromJSON(state, () => {
          activeCanvas.renderAll();
          isRestoringState = false; // Reset flag after restore completes
      });
  }

  function updateUndoRedoButtons() {
      if (undoBtn) {
          undoBtn.disabled = historyStack.length === 0;
      }
      if (redoBtn) {
          redoBtn.disabled = redoStack.length === 0;
      }
  }

  function deleteSelectedObjects() {
      const activeCanvas = getActiveCanvas();
      const activeObjects = activeCanvas.getActiveObjects();
      if (activeObjects.length > 0) {
          activeObjects.forEach(obj => {
              if (!obj.isGeneratedItem && !obj.isAnswerKeyItem) {
                  activeCanvas.remove(obj);
              } else if (obj.isGeneratedItem || obj.isAnswerKeyItem) {
                  displayMessage(t('picture.pathway.msg.cannot.delete'), 'warning', 3000);
              }
          });
          activeCanvas.discardActiveObject().renderAll();
      }
      closeAllPopovers();
  }

  function toggleLockSelectedObjects() {
      const canvas = getActiveCanvas();
      const activeObject = canvas.getActiveObject();

      // If nothing is selected, unlock ALL locked objects on the canvas
      if (!activeObject) {
          const allObjects = canvas.getObjects();
          const lockedObjects = allObjects.filter(obj => obj.lockMovementX === true);

          if (lockedObjects.length > 0) {
              lockedObjects.forEach(obj => {
                  obj.set({
                      lockMovementX: false,
                      lockMovementY: false,
                      lockRotation: false,
                      lockScalingX: false,
                      lockScalingY: false,
                      hasControls: true,
                      hasBorders: true,
                      selectable: true,
                      evented: true
                  });
              });

              // Update button icon to unlocked
              const lockIcon = toolbarLockBtn.querySelector('i');
              lockIcon.classList.remove('fa-lock');
              lockIcon.classList.add('fa-lock-open');

              canvas.renderAll();
              console.log(`Unlocked ${lockedObjects.length} objects`);
          }

          closeAllPopovers();
          updateUnlockAllButtonVisibility();
          return;
      }

      // Handle both single objects and groups
      const objectsToLock = activeObject.type === 'activeSelection'
          ? activeObject.getObjects()
          : [activeObject];

      // Check if any object is currently locked
      const isAnyLocked = objectsToLock.some(obj => obj.lockMovementX === true);

      // Toggle lock state (opposite of current state)
      const shouldLock = !isAnyLocked;

      objectsToLock.forEach(obj => {
          // When locking, make objects completely non-interactive
          // This prevents them from blocking mouse drag selections
          obj.set({
              lockMovementX: shouldLock,
              lockMovementY: shouldLock,
              lockRotation: shouldLock,
              lockScalingX: shouldLock,
              lockScalingY: shouldLock,
              hasControls: !shouldLock,
              hasBorders: !shouldLock,
              selectable: !shouldLock,  // Locked objects are not selectable
              evented: !shouldLock      // Locked objects don't capture mouse events
          });
      });

      // Update button icon
      const lockIcon = toolbarLockBtn.querySelector('i');
      if (shouldLock) {
          lockIcon.classList.remove('fa-lock-open');
          lockIcon.classList.add('fa-lock');
      } else {
          lockIcon.classList.remove('fa-lock');
          lockIcon.classList.add('fa-lock-open');
      }

      canvas.renderAll();
      closeAllPopovers();
      updateUnlockAllButtonVisibility();
  }

  function unlockAllObjects() {
      const canvas = getActiveCanvas();
      const allObjects = canvas.getObjects();
      const lockedObjects = allObjects.filter(obj => obj.lockMovementX === true);

      if (lockedObjects.length > 0) {
          lockedObjects.forEach(obj => {
              obj.set({
                  lockMovementX: false,
                  lockMovementY: false,
                  lockRotation: false,
                  lockScalingX: false,
                  lockScalingY: false,
                  hasControls: true,
                  hasBorders: true,
                  selectable: true,
                  evented: true
              });
          });

          canvas.renderAll();
          console.log(`Unlocked ${lockedObjects.length} objects`);
          updateUnlockAllButtonVisibility();
      }
  }

  function updateUnlockAllButtonVisibility() {
      const canvas = getActiveCanvas();
      const allObjects = canvas.getObjects();
      const hasLockedObjects = allObjects.some(obj => obj.lockMovementX === true);

      if (hasLockedObjects) {
          unlockAllControls.classList.add('visible');
      } else {
          unlockAllControls.classList.remove('visible');
      }
  }

  function alignObjects(type) {
      const activeCanvas = getActiveCanvas();
      const activeObj = activeCanvas.getActiveObject();
      if (!activeObj) {
          closeAllPopovers();
          return;
      }

      if (type.includes('Canvas')) { // Align single object to canvas
          if (activeObj.isGeneratedItem || activeObj.isAnswerKeyItem || activeObj.isBorder || activeObj.isBackground) {
              displayMessage(t('picture.pathway.msg.cannot.align.core'), 'warning', 3000);
              closeAllPopovers();
              return;
          }
          // Use actual page dimensions, not zoomed canvas dimensions
          const actualPageWidth = currentCanvasConfig.width;
          const actualPageHeight = currentCanvasConfig.height;
          
          if (type === 'centerHCanvas') {
              const objWidth = activeObj.getScaledWidth();
              activeObj.set('left', (actualPageWidth - objWidth) / 2);
              activeObj.setCoords();
          }
          if (type === 'centerVCanvas') {
              const objHeight = activeObj.getScaledHeight();
              activeObj.set('top', (actualPageHeight - objHeight) / 2);
              activeObj.setCoords();
          }
      }
      else if (activeObj.type === 'activeSelection') { // Align multiple objects to each other
          const group = activeObj;
          const groupCenter = group.getCenterPoint();
          const groupLeft = groupCenter.x - group.width / 2;
          const groupTop = groupCenter.y - group.height / 2;
          const groupRight = groupCenter.x + group.width / 2;
          const groupBottom = groupCenter.y + group.height / 2;
          
          group._objects.forEach(function(obj) {
                if (obj.isGeneratedItem || obj.isAnswerKeyItem || obj.isBorder || obj.isBackground) {
                     displayMessage(t('picture.pathway.msg.cannot.align.core'), 'warning', 3000);
                     return;
                }
                const objBounds = obj.getBoundingRect(true, true);
                switch (type) {
                    case 'alignLeft': 
                        obj.set('left', obj.left - (objBounds.left - groupLeft));
                        break;
                    case 'alignHCenter': 
                        const objCenterX = objBounds.left + objBounds.width / 2;
                        obj.set('left', obj.left + (groupCenter.x - objCenterX));
                        break;
                    case 'alignRight': 
                        const objRight = objBounds.left + objBounds.width;
                        obj.set('left', obj.left + (groupRight - objRight));
                        break;
                    case 'alignTop': 
                        obj.set('top', obj.top - (objBounds.top - groupTop));
                        break;
                    case 'alignVCenter': 
                        const objCenterY = objBounds.top + objBounds.height / 2;
                        obj.set('top', obj.top + (groupCenter.y - objCenterY));
                        break;
                    case 'alignBottom': 
                        const objBottom = objBounds.top + objBounds.height;
                        obj.set('top', obj.top + (groupBottom - objBottom));
                        break;
                }
                obj.setCoords();
          });
          group.setCoords();
      }
      else { // Single object alignment - align to canvas if not in a group
          if (activeObj.isGeneratedItem || activeObj.isAnswerKeyItem || activeObj.isBorder || activeObj.isBackground) {
              displayMessage(t('picture.pathway.msg.cannot.align.core'), 'warning', 3000);
              closeAllPopovers();
              return;
          }
          
          // Use actual page dimensions from currentCanvasConfig
          const actualPageWidth = currentCanvasConfig.width;
          const actualPageHeight = currentCanvasConfig.height;
          
          switch (type) {
              case 'alignLeft':
                  activeObj.set('left', 0);
                  break;
              case 'alignHCenter':
                  const objWidth = activeObj.getScaledWidth();
                  activeObj.set('left', (actualPageWidth - objWidth) / 2);
                  break;
              case 'alignRight':
                  const objRightWidth = activeObj.getScaledWidth();
                  activeObj.set('left', actualPageWidth - objRightWidth);
                  break;
              case 'alignTop':
                  activeObj.set('top', 0);
                  break;
              case 'alignVCenter':
                  const objHeight = activeObj.getScaledHeight();
                  activeObj.set('top', (actualPageHeight - objHeight) / 2);
                  break;
              case 'alignBottom':
                  const objBottomHeight = activeObj.getScaledHeight();
                  activeObj.set('top', actualPageHeight - objBottomHeight);
                  break;
          }
          activeObj.setCoords();
      }
      activeCanvas.renderAll();
      closeAllPopovers();
  }
  
  function createHeaderGroup(canvas) {
      const defaultHeaders = {
          en: { title: 'Picture Pathway', description: 'Follow the path from start to finish!' },
          de: { title: 'Bilderpfad', description: 'Folge dem Weg von Anfang bis Ende!' },
          fr: { title: 'Chemin d\'Images', description: 'Suis le chemin du d√©but √† la fin!' },
          es: { title: 'Camino de Im√°genes', description: '¬°Sigue el camino desde el inicio hasta el final!' },
          it: { title: 'Percorso di Immagini', description: 'Segui il percorso dall\'inizio alla fine!' },
          pt: { title: 'Caminho de Imagens', description: 'Siga o caminho do in√≠cio ao fim!' },
          nl: { title: 'Afbeeldingspad', description: 'Volg het pad van begin tot eind!' },
          sv: { title: 'Bildstig', description: 'F√∂lj v√§gen fr√•n start till m√•l!' },
          da: { title: 'Billedsti', description: 'F√∏lg stien fra start til slut!' },
          no: { title: 'Bildesti', description: 'F√∏lg stien fra start til slutt!' },
          fi: { title: 'Kuvapolku', description: 'Seuraa polkua alusta loppuun!' }
      };

      const locale = currentLocale || 'en';
      const defaults = defaultHeaders[locale] || defaultHeaders.en;
      const title = defaults.title;
      const description = defaults.description;

      // Get current canvas dimensions for responsive design
      const pageWidth = currentCanvasConfig.width;
      const pageHeight = currentCanvasConfig.height;
      const isLandscape = pageWidth > pageHeight;

      const objects = [];

      // Outer border - responsive to page size (bright orange for adventure/pathway)
      const margin = 34;
      const strokeWidth = 8;
      const borderWidth = pageWidth - (margin * 2);
      const borderHeight = pageHeight - (margin * 2);

      const outerBorder = new fabric.Rect({
          left: margin,
          top: margin,
          width: borderWidth,
          height: borderHeight,
          fill: 'transparent',
          stroke: '#FF8C42',
          strokeWidth: strokeWidth,
          rx: 12,
          ry: 12,
          selectable: true,
          hasControls: true,
          isPageBorder: true
      });
      objects.push(outerBorder);

      // LANDSCAPE MODE: Compact, centered header
      if (isLandscape) {
          const maxHeaderWidth = Math.min(500, pageWidth * 0.6);
          const headerHeight = 70;
          const centerX = pageWidth / 2;
          const headerTop = 60;

          // Sunny blue header background - compact size
          const bgRect = new fabric.Rect({
              left: centerX - maxHeaderWidth / 2,
              top: headerTop,
              width: maxHeaderWidth,
              height: headerHeight,
              fill: '#52B2CF',
              rx: 35,
              ry: 35,
              selectable: true,
              isHeaderElement: true
          });
          objects.push(bgRect);

          // White pill for title - compact
          const whitePill = new fabric.Rect({
              left: centerX - (maxHeaderWidth - 40) / 2,
              top: headerTop + 10,
              width: maxHeaderWidth - 40,
              height: 50,
              fill: '#FFFFFF',
              rx: 25,
              ry: 25,
              selectable: true,
              isHeaderElement: true
          });
          objects.push(whitePill);

          // Title - compact size for landscape
          let titleFontSize = 36;
          if (title.length > 12) titleFontSize = 32;
          if (title.length > 15) titleFontSize = 28;
          if (title.length > 18) titleFontSize = 24;

          const titleText = new fabric.IText(title, {
              left: centerX,
              top: headerTop + 35,
              fontSize: titleFontSize,
              fontFamily: 'Fredoka, sans-serif',
              fontWeight: '700',
              fill: '#1E3D59',
              textAlign: 'center',
              originX: 'center',
              originY: 'center',
              selectable: true,
              editable: true,
              isHeaderElement: true
          });
          objects.push(titleText);

          // Description - compact below header
          const descText = new fabric.Textbox(description, {
              left: centerX,
              top: headerTop + headerHeight + 5,
              width: maxHeaderWidth - 20,
              fontSize: 14,
              fontFamily: 'Quicksand, sans-serif',
              fontWeight: '500',
              fill: '#E67E22',
              textAlign: 'center',
              originX: 'center',
              originY: 'top',
              selectable: true,
              editable: true,
              hasControls: true,
              isHeaderDesc: true
          });
          objects.push(descText);

      } else {
          // PORTRAIT MODE: Full-width professional header
          const headerMargin = 70;
          const headerWidth = pageWidth - (headerMargin * 2);
          const centerX = pageWidth / 2;

          // Sunny blue header background
          const bgRect = new fabric.Rect({
              left: headerMargin,
              top: 70,
              width: headerWidth,
              height: 100,
              fill: '#52B2CF',
              rx: 15,
              ry: 15,
              selectable: true,
              isHeaderElement: true
          });
          objects.push(bgRect);

          // White pill for title
          const whitePill = new fabric.Rect({
              left: headerMargin + 20,
              top: 85,
              width: headerWidth - 40,
              height: 70,
              fill: '#FFFFFF',
              rx: 35,
              ry: 35,
              selectable: true,
              isHeaderElement: true
          });
          objects.push(whitePill);

          // Title - Dynamic size based on length
          let titleFontSize = 48;
          if (title.length > 12) titleFontSize = 40;
          if (title.length > 15) titleFontSize = 36;
          if (title.length > 18) titleFontSize = 32;
          if (title.length > 22) titleFontSize = 28;

          const titleText = new fabric.IText(title, {
              left: centerX,
              top: 120,
              fontSize: titleFontSize,
              fontFamily: 'Fredoka, sans-serif',
              fontWeight: '700',
              fill: '#1E3D59',
              textAlign: 'center',
              originX: 'center',
              originY: 'center',
              selectable: true,
              editable: true,
              isHeaderElement: true
          });
          objects.push(titleText);

          // Description text
          const descText = new fabric.Textbox(description, {
              left: centerX,
              top: 190,
              width: Math.min(450, pageWidth - 150),
              fontSize: 20,
              fontFamily: 'Quicksand, sans-serif',
              fontWeight: '500',
              fill: '#E67E22',
              textAlign: 'center',
              originX: 'center',
              originY: 'top',
              selectable: true,
              editable: true,
              hasControls: true,
              isHeaderDesc: true
          });
          objects.push(descText);
      }

      return objects;
  }

  function createPageBorder(canvas) {
      return null;
  }

  function enforceZOrder(canvas) {
      if (!canvas) return;

      const allObjects = canvas.getObjects();

      // MODIFIED: Remove automatic enforcement of backgrounds and borders
      // Users should have full control over these elements via layer controls
      // Only enforce page borders and header elements

      const pageBorders = allObjects.filter(o => o.isPageBorder);
      const headerElements = allObjects.filter(o => o.isHeaderElement && !o.isPageBorder);
      const nameDateElements = allObjects.filter(o => o.isNameDate);
      const worksheetItems = allObjects.filter(o => o.isWorksheetItem || o.isAnswerKeyItem);
      const otherItems = allObjects.filter(o =>
          !o.isPageBorder &&
          !o.isHeaderElement &&
          !o.isNameDate &&
          !o.isWorksheetItem &&
          !o.isAnswerKeyItem
      );

      // Use moveTo for precise z-order control
      // Order from back to front: page borders, header elements, name/date, worksheet items, everything else (including user borders/backgrounds)
      let index = 0;

      pageBorders.forEach(obj => { canvas.moveTo(obj, index++); });
      headerElements.forEach(obj => { canvas.moveTo(obj, index++); });
      nameDateElements.forEach(obj => { canvas.moveTo(obj, index++); });
      worksheetItems.forEach(obj => { canvas.moveTo(obj, index++); });
      otherItems.forEach(obj => { canvas.moveTo(obj, index++); });
  }

  // CRITICAL: Regeneration functions for paper type switching (follows wordsearch pattern)
  async function regenerateHeadersOnly() {
      // Only regenerate if worksheet exists
      if (!lastGeneratedData) return;

      // Regenerate worksheet canvas
      await regenerateCanvasLayout(worksheetCanvas, false);

      // Regenerate answer key canvas if it exists
      const hasAnswerKey = answerKeyCanvas && answerKeyCanvas.getObjects().some(o => o.isAnswerKeyItem);
      if (hasAnswerKey) {
          await regenerateCanvasLayout(answerKeyCanvas, true);
      }
  }

  async function regenerateCanvasLayout(canvas, isAnswerKey) {
      if (!canvas || !lastGeneratedData) return;

      // Preserve user-added objects ONLY (NOT generated content)
      const userAddedObjects = canvas.getObjects().filter(o =>
          !o.isGeneratedItem &&
          !o.isAnswerKeyItem &&
          !o.isBorder &&
          !o.isBackground &&
          !o.isPageBorder &&
          !o.isHeaderDesc &&
          !o.isHeaderElement
      );

      // Remove ALL generated content (following wordsearch pattern)
      const itemTag = isAnswerKey ? 'isAnswerKeyItem' : 'isGeneratedItem';
      const oldItems = canvas.getObjects().filter(o =>
          o[itemTag] ||
          o.isPageBorder ||
          o.isHeaderDesc ||
          o.isHeaderElement
      );
      oldItems.forEach(o => canvas.remove(o));

      // Recreate header with current page dimensions
      const headerObjects = createHeaderGroup(canvas);
      if (headerObjects) {
          canvas.add(...headerObjects);
      }

      // Recreate puzzle grid from stored data with current canvas dimensions
      const puzzleObjects = await createPuzzleGrid(lastGeneratedData, isAnswerKey);
      canvas.add(...puzzleObjects);

      enforceZOrder(canvas);
      userAddedObjects.forEach(obj => obj.bringToFront());
      canvas.renderAll();
  }

  // Creates a professional educational legend - SIMPLE AND CLEAN
  async function createMazeLegend(items, legendLeft, legendTop, mazeWidth, cellSize, isAnswerKey, itemTag) {
      // USING FIND AND COUNT LEGEND STYLE: Image + "=" + Number

      // Count each unique collectible image
      const collectibles = items.filter(item => item.type === 'collectible');

      // Group by image path and count occurrences
      const collectibleCounts = new Map();
      collectibles.forEach(item => {
        const key = item.image.path;
        if (collectibleCounts.has(key)) {
          collectibleCounts.get(key).count++;
        } else {
          collectibleCounts.set(key, { image: item.image, count: 1 });
        }
      });

      const uniqueCollectibles = Array.from(collectibleCounts.values());
      console.log('Unique collectibles for legend:', uniqueCollectibles.length);

      // Create legend items using Find and Count style: Image + "=" + Count
      // ULTRA COMPACT LEGEND - Reduced 15% more from previous size
      const imageHeight = 33;  // 39 √ó 0.85 = 33.15
      const itemSpacing = 11;  // 13 √ó 0.85 = 11.05

      const legendItemPromises = uniqueCollectibles.map(collectibleData => {
          return new Promise(resolve => {
              fabric.Image.fromURL(collectibleData.image.path, img => {
                  // Scale image to consistent height
                  img.scaleToHeight(imageHeight);

                  // Simple equals sign - reduced 15% more
                  const equalsText = new fabric.Text('=', {
                      fontSize: 11,  // 13 √ó 0.85 = 11.05
                      fontFamily: 'Arial, sans-serif',
                      fill: '#666666'
                  });

                  // Count or blank line - reduced 15% more
                  const countDisplay = isAnswerKey ?
                      new fabric.Text(collectibleData.count.toString(), {
                          fontSize: 13,  // 15 √ó 0.85 = 12.75
                          fontFamily: 'Arial, sans-serif',
                          fontWeight: 'bold',
                          fill: '#2c3e50'
                      }) :
                      new fabric.Line([0, 0, 18, 0], {  // 21 √ó 0.85 = 17.85
                          stroke: '#999999',
                          strokeWidth: 2  // Keep at 2 for visibility
                      });

                  // Position elements in a simple row
                  img.set({
                      left: 0,
                      top: 0
                  });

                  equalsText.set({
                      left: img.getScaledWidth() + 7,  // 8 √ó 0.85 = 6.8
                      top: (imageHeight - 11) / 2  // Updated for new font size
                  });

                  if (isAnswerKey) {
                      countDisplay.set({
                          left: img.getScaledWidth() + 23,  // 27 √ó 0.85 = 22.95
                          top: (imageHeight - 13) / 2  // Updated for new font size
                      });
                  } else {
                      countDisplay.set({
                          left: img.getScaledWidth() + 23,  // 27 √ó 0.85 = 22.95
                          top: imageHeight / 2
                      });
                  }

                  // Create simple group
                  const group = new fabric.Group([img, equalsText, countDisplay], {
                      selectable: false,
                      evented: false
                  });

                  resolve(group);
              }, { crossOrigin: 'anonymous' });
          });
      });

      const legendItems = (await Promise.all(legendItemPromises)).filter(item => item !== null);

      if (legendItems.length === 0) {
          return [];
      }

      // Ultra compact spacing - reduced 15% more
      const horizontalPadding = 11;  // 13 √ó 0.85 = 11.05
      const verticalPadding = 8;     // 9 √ó 0.85 = 7.65

      // Calculate actual dimensions based on items
      const itemHeight = Math.max(...legendItems.map(item => item.height));
      const totalItemsWidth = legendItems.reduce((sum, item) => sum + item.width, 0);
      const totalSpacing = (legendItems.length - 1) * itemSpacing;
      let legendBoxWidth = totalItemsWidth + totalSpacing + (horizontalPadding * 2);
      let legendBoxHeight = itemHeight + (verticalPadding * 2);

      // Legend can be wider than maze - no scaling down!
      // This ensures images remain at full 112px height for maximum visibility
      let scaleFactor = 1;

      // Calculate final scaled item height for proper vertical centering
      const finalScaledItemHeight = Math.max(...legendItems.map(item => item.getScaledHeight()));

      // Background with clean border
      const legendBackground = new fabric.Rect({
          width: legendBoxWidth,
          height: legendBoxHeight,
          fill: '#FFFFFF',
          stroke: '#333333',
          strokeWidth: 2,
          rx: 8,
          ry: 8,
          selectable: false,
          evented: false,
          [itemTag]: true
      });

      // Position items with FIXED spacing (not spread out to fill box)
      const scaledItemsWidth = legendItems.reduce((sum, item) => sum + item.getScaledWidth(), 0);
      const scaledItemSpacing = itemSpacing * scaleFactor;
      const totalContentWidth = scaledItemsWidth + ((legendItems.length - 1) * scaledItemSpacing);

      // Center the entire row of items horizontally
      const startX = (legendBoxWidth - totalContentWidth) / 2;

      let currentX = startX;
      legendItems.forEach((item, index) => {
          item.set({
              left: currentX,
              top: (legendBoxHeight - finalScaledItemHeight) / 2  // Vertically centered
          });
          currentX += item.getScaledWidth() + (index < legendItems.length - 1 ? scaledItemSpacing : 0);
      });

      // CENTER LEGEND HORIZONTALLY ON PAGE
      const pageWidth = currentCanvasConfig.width;
      const centeredLeft = (pageWidth - legendBoxWidth) / 2;

      const legendGroup = new fabric.Group([legendBackground, ...legendItems], {
          left: centeredLeft,  // Centered horizontally on page
          top: legendTop,
          selectable: true,
          hasControls: true,
          hasBorders: true,
          lockScalingX: false,
          lockScalingY: false,
          lockRotation: false,
          [itemTag]: true
      });

      return [legendGroup];
  }

  // Find solution path through maze using BFS
  function findMazeSolution(mazeWalls, startCell, endCell, rows, cols) {
      const queue = [[startCell]];
      const visited = Array.from({ length: rows }, () => Array(cols).fill(false));
      visited[startCell.r][startCell.c] = true;

      while (queue.length > 0) {
          const path = queue.shift();
          const current = path[path.length - 1];

          if (current.r === endCell.r && current.c === endCell.c) {
              return path;  // Found solution
          }

          const cell = mazeWalls[current.r][current.c];
          const directions = [
              { dr: -1, dc: 0, wall: 'top' },     // Up
              { dr: 0, dc: 1, wall: 'right' },    // Right
              { dr: 1, dc: 0, wall: 'bottom' },   // Down
              { dr: 0, dc: -1, wall: 'left' }     // Left
          ];

          for (const dir of directions) {
              if (!cell[dir.wall]) {  // Wall is open
                  const nr = current.r + dir.dr;
                  const nc = current.c + dir.dc;

                  if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited[nr][nc]) {
                      visited[nr][nc] = true;
                      queue.push([...path, { r: nr, c: nc }]);
                  }
              }
          }
      }

      return [];  // No solution found
  }

  // Creates wall-based maze with corridors
  async function createMazeWithWalls(data, isAnswerKey) {
      const { mazeWalls, startCell, endCell, items, rows, cols, selectedStartImage, selectedEndImage } = data;
      const itemTag = isAnswerKey ? 'isAnswerKeyItem' : 'isGeneratedItem';

      const objects = [];

      // Find solution path for answer key
      let solutionPath = [];
      if (isAnswerKey) {
          console.log('=== ANSWER KEY DEBUG ===');
          console.log('mazeWalls data structure:', mazeWalls);
          console.log('mazeWalls full JSON:', JSON.stringify(mazeWalls));
          console.log('mazeWalls dimensions:', mazeWalls ? mazeWalls.length : 'null', 'x', mazeWalls && mazeWalls[0] ? mazeWalls[0].length : 'null');

          // For Choose Path mode, use corridorCell (actual grid position) instead of outside marker position
          const pathStartCell = startCell.corridorCell || startCell;
          const pathEndCell = endCell.corridorCell || endCell;

          console.log('Finding solution from START:', pathStartCell, 'to END:', pathEndCell);
          solutionPath = findMazeSolution(mazeWalls, pathStartCell, pathEndCell, rows, cols);
          console.log('Solution path found:', solutionPath ? solutionPath.length : 0, 'cells');
          if (solutionPath && solutionPath.length > 0) {
            console.log('Solution path cells:', JSON.stringify(solutionPath));
          }
      }

      // Get wall appearance settings from UI (use Choose Path controls if in Choose Path mode)
      const isChoosePathMode = data.isChoosePath;
      const wallColor = isChoosePathMode
          ? (document.getElementById('choosePathWallColor')?.value || '#4CAF50')
          : (document.getElementById('mazeWallColor')?.value || '#4CAF50');
      const wallThickness = isChoosePathMode
          ? (parseInt(document.getElementById('choosePathWallThickness')?.value) || 3)
          : (parseInt(document.getElementById('mazeWallThickness')?.value) || 3);
      const wallOpacity = isChoosePathMode
          ? ((parseInt(document.getElementById('choosePathWallOpacity')?.value) || 100) / 100)
          : ((parseInt(document.getElementById('mazeWallOpacity')?.value) || 100) / 100);

      // Get current page dimensions
      const pageWidth = currentCanvasConfig.width;
      const pageHeight = currentCanvasConfig.height;
      const isLandscape = pageWidth > pageHeight;

      const HEADER_HEIGHT = isLandscape ? 165 : 240;
      const pageMargin = 50;
      const nameDateHeight = includeNameDateCheckbox.checked ? 60 : 0;

      // Calculate available space
      const availableWidth = pageWidth - (2 * pageMargin);
      const availableHeight = pageHeight - HEADER_HEIGHT - pageMargin - nameDateHeight;

      // Calculate cell size (15% larger)
      const cellSize = Math.min((availableWidth * 0.9775) / cols, (availableHeight * 0.805) / rows, 92);
      const mazeWidth = cols * cellSize;
      const mazeHeight = rows * cellSize;

      // Position maze with direction-specific pixel adjustments
      const mazeDirection = data.mazeDirection || 'bottom-top';
      const baseLeft = pageMargin + (availableWidth - mazeWidth) / 2;
      const baseTop = HEADER_HEIGHT + nameDateHeight + 45;

      let mazeLeft, mazeTop;

      if (mazeDirection === 'left-right') {
        // Left to right: move 57px to the left (7px more)
        mazeLeft = baseLeft - 57;
        mazeTop = baseTop;
      } else if (mazeDirection === 'right-left') {
        // Right to left: move 3px to the left (5px right from before)
        mazeLeft = baseLeft - 3;
        mazeTop = baseTop;
      } else if (mazeDirection === 'top-bottom') {
        // Top to bottom: move 65px up (5px more)
        mazeLeft = baseLeft;
        mazeTop = baseTop - 65;
      } else { // 'bottom-top'
        // Bottom to top: move 5px up
        mazeLeft = baseLeft;
        mazeTop = baseTop - 5;
      }

      // CLASSIC MAZE: Move grid and legend 25px up (for better positioning)
      const isClassicMaze = data.isMazeMode && !data.isChoosePath;
      if (isClassicMaze) {
        mazeTop = mazeTop - 25;
      }

      // Draw outer border (SKIP for Choose Path mode - we need corridor openings!)
      if (!data.isChoosePath) {
          const outerBorder = new fabric.Rect({
              left: 0, top: 0,
              width: mazeWidth, height: mazeHeight,
              fill: 'transparent',
              stroke: wallColor,
              strokeWidth: wallThickness * 2,
              opacity: wallOpacity,
              selectable: false,
              evented: false,
              [itemTag]: true,
              isMazeWall: true
          });
          objects.push(outerBorder);
      } else {
          // For Choose Path, draw border walls as continuous segments with gaps
          // Helper to draw continuous border segments
          const drawBorderSegments = (segments, isHorizontal) => {
              segments.forEach(seg => {
                  const line = new fabric.Line(
                      isHorizontal ? [seg.start * cellSize, seg.y, seg.end * cellSize, seg.y]
                                   : [seg.x, seg.start * cellSize, seg.x, seg.end * cellSize],
                      {
                          stroke: wallColor,
                          strokeWidth: wallThickness,
                          strokeLineCap: 'square',
                          strokeLineJoin: 'miter',
                          opacity: wallOpacity,
                          selectable: false,
                          evented: false,
                          [itemTag]: true,
                          isMazeWall: true
                      }
                  );
                  objects.push(line);
              });
          };

          // Top border - group continuous segments
          let topSegments = [];
          let currentSegment = null;
          console.log('=== RENDERING TOP BORDER ===');
          for (let c = 0; c < cols; c++) {
              const hasWall = mazeWalls[0][c].top;
              // Log END corridor cells specifically
              if (data.isChoosePath && data.endCells) {
                  data.endCells.forEach((endCell, idx) => {
                      if (endCell.r === 0 && endCell.c === c) {
                          console.log(`‚Üí END ${idx} at col ${c}: top wall = ${hasWall} (correct=${idx === data.correctPathIndex}, should be ${idx === data.correctPathIndex ? 'FALSE' : 'TRUE'})`);
                      }
                  });
              }
              if (hasWall) {
                  if (!currentSegment) {
                      currentSegment = { start: c, end: c + 1, y: 0 };
                  } else {
                      currentSegment.end = c + 1;
                  }
              } else {
                  if (currentSegment) {
                      topSegments.push(currentSegment);
                      currentSegment = null;
                  }
              }
          }
          if (currentSegment) topSegments.push(currentSegment);
          console.log(`Top border segments: ${topSegments.length} segments drawn`);
          drawBorderSegments(topSegments, true);

          // Bottom border - group continuous segments
          let bottomSegments = [];
          currentSegment = null;
          console.log('=== RENDERING BOTTOM BORDER ===');
          for (let c = 0; c < cols; c++) {
              const hasWall = mazeWalls[rows - 1][c].bottom;
              // Log START corridor cell specifically
              if (data.isChoosePath && data.startCell && data.startCell.corridorCell) {
                  const startCorridor = data.startCell.corridorCell;
                  if (startCorridor.r === rows - 1 && startCorridor.c === c) {
                      console.log(`‚Üí START CORRIDOR at col ${c}: bottom wall = ${hasWall} (should be FALSE)`);
                  }
              }
              if (hasWall) {
                  if (!currentSegment) {
                      currentSegment = { start: c, end: c + 1, y: mazeHeight };
                  } else {
                      currentSegment.end = c + 1;
                  }
              } else {
                  if (currentSegment) {
                      bottomSegments.push(currentSegment);
                      currentSegment = null;
                  }
              }
          }
          if (currentSegment) bottomSegments.push(currentSegment);
          console.log(`Bottom border segments: ${bottomSegments.length} segments drawn`);
          drawBorderSegments(bottomSegments, true);

          // Left border - group continuous segments
          let leftSegments = [];
          currentSegment = null;
          for (let r = 0; r < rows; r++) {
              if (mazeWalls[r][0].left) {
                  if (!currentSegment) {
                      currentSegment = { start: r, end: r + 1, x: 0 };
                  } else {
                      currentSegment.end = r + 1;
                  }
              } else {
                  if (currentSegment) {
                      leftSegments.push(currentSegment);
                      currentSegment = null;
                  }
              }
          }
          if (currentSegment) leftSegments.push(currentSegment);
          drawBorderSegments(leftSegments, false);

          // Right border - group continuous segments
          let rightSegments = [];
          currentSegment = null;
          for (let r = 0; r < rows; r++) {
              if (mazeWalls[r][cols - 1].right) {
                  if (!currentSegment) {
                      currentSegment = { start: r, end: r + 1, x: mazeWidth };
                  } else {
                      currentSegment.end = r + 1;
                  }
              } else {
                  if (currentSegment) {
                      rightSegments.push(currentSegment);
                      currentSegment = null;
                  }
              }
          }
          if (currentSegment) rightSegments.push(currentSegment);
          drawBorderSegments(rightSegments, false);
      }

      // Draw internal walls with professional line cap/join for clean connections
      for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
              const cell = mazeWalls[r][c];
              const x = c * cellSize;
              const y = r * cellSize;

              // For Choose Path mode, skip border-edge walls (border segments handle them)
              const isChoosePath = data.isChoosePath;
              const isBorderCell = r === 0 || r === rows - 1 || c === 0 || c === cols - 1;

              // Draw top wall if it exists (skip if it's the top border in Choose Path mode)
              if (cell.top && !(isChoosePath && r === 0)) {
                  const line = new fabric.Line([x, y, x + cellSize, y], {
                      stroke: wallColor,
                      strokeWidth: wallThickness,
                      strokeLineCap: 'square',
                      strokeLineJoin: 'miter',
                      opacity: wallOpacity,
                      selectable: false,
                      evented: false,
                      [itemTag]: true,
                      isMazeWall: true
                  });
                  objects.push(line);
              }

              // Draw right wall if it exists (skip if it's the right border in Choose Path mode)
              if (cell.right && !(isChoosePath && c === cols - 1)) {
                  const line = new fabric.Line([x + cellSize, y, x + cellSize, y + cellSize], {
                      stroke: wallColor,
                      strokeWidth: wallThickness,
                      strokeLineCap: 'square',
                      strokeLineJoin: 'miter',
                      opacity: wallOpacity,
                      selectable: false,
                      evented: false,
                      [itemTag]: true,
                      isMazeWall: true
                  });
                  objects.push(line);
              }

              // Draw bottom wall if it exists (skip if it's the bottom border in Choose Path mode)
              if (cell.bottom && !(isChoosePath && r === rows - 1)) {
                  const line = new fabric.Line([x, y + cellSize, x + cellSize, y + cellSize], {
                      stroke: wallColor,
                      strokeWidth: wallThickness,
                      strokeLineCap: 'square',
                      strokeLineJoin: 'miter',
                      opacity: wallOpacity,
                      selectable: false,
                      evented: false,
                      [itemTag]: true,
                      isMazeWall: true
                  });
                  objects.push(line);
              }

              // Draw left wall if it exists (skip if it's the left border in Choose Path mode)
              if (cell.left && !(isChoosePath && c === 0)) {
                  const line = new fabric.Line([x, y, x, y + cellSize], {
                      stroke: wallColor,
                      strokeWidth: wallThickness,
                      strokeLineCap: 'square',
                      strokeLineJoin: 'miter',
                      opacity: wallOpacity,
                      selectable: false,
                      evented: false,
                      [itemTag]: true,
                      isMazeWall: true
                  });
                  objects.push(line);
              }
          }
      }

      // Draw solution path on answer key
      if (isAnswerKey && solutionPath.length > 0) {
          for (const cell of solutionPath) {
              const centerX = cell.c * cellSize + cellSize / 2;
              const centerY = cell.r * cellSize + cellSize / 2;

              // Draw path indicator (circle)
              const pathDot = new fabric.Circle({
                  left: centerX,
                  top: centerY,
                  radius: cellSize * 0.15,
                  fill: '#FFD700',
                  opacity: 0.7,
                  originX: 'center',
                  originY: 'center',
                  selectable: false,
                  evented: false,
                  [itemTag]: true
              });
              objects.push(pathDot);
          }
      }

      // Helper function to place images in cells
      // Place arrow only (without image) - for maze mode start/end markers
      const placeArrowOnly = async (r, c, arrowType, itemTag) => {
          const cellObjects = [];
          const arrowSize = Math.max(28, Math.min(cellSize * 0.4, 40));

          if (arrowType === 'start') {
              // START: Green arrow pointing right (into the maze)
              const arrowX = c * cellSize + 3;
              const arrowY = r * cellSize + 3;

              const arrowPoints = [
                  { x: arrowX, y: arrowY + arrowSize * 0.35 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.35 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY },
                  { x: arrowX + arrowSize, y: arrowY + arrowSize * 0.5 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.65 },
                  { x: arrowX, y: arrowY + arrowSize * 0.65 }
              ];

              const startArrow = new fabric.Polygon(arrowPoints, {
                  fill: '#4CAF50',
                  stroke: '#FFFFFF',
                  strokeWidth: 3,
                  strokeLineJoin: 'round',
                  selectable: false,
                  evented: false,
                  [itemTag]: true
              });
              cellObjects.push(startArrow);

          } else if (arrowType === 'finish') {
              // FINISH: Red arrow pointing right (OUT toward the outer wall)
              const arrowX = c * cellSize + cellSize - arrowSize - 3;
              const arrowY = r * cellSize + cellSize - arrowSize - 3;

              const arrowPoints = [
                  { x: arrowX, y: arrowY + arrowSize * 0.35 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.35 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY },
                  { x: arrowX + arrowSize, y: arrowY + arrowSize * 0.5 },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize },
                  { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.65 },
                  { x: arrowX, y: arrowY + arrowSize * 0.65 }
              ];

              const finishArrow = new fabric.Polygon(arrowPoints, {
                  fill: '#FF5722',
                  stroke: '#FFFFFF',
                  strokeWidth: 3,
                  strokeLineJoin: 'round',
                  selectable: false,
                  evented: false,
                  [itemTag]: true
              });
              cellObjects.push(finishArrow);
          }

          return cellObjects;
      };

      const placeImageInCell = async (img, r, c, scale = 0.455, highlightType = null) => {  // 35% reduction
          const centerX = c * cellSize + cellSize / 2;
          const centerY = r * cellSize + cellSize / 2;
          const cellObjects = [];

          // Child-friendly arrow markers - positioned in corners to not overlap images
          // Calculate arrow size ONCE to use for both arrow and image positioning
          const arrowSize = Math.max(28, Math.min(cellSize * 0.4, 40));  // Min 28px, max 40px

          if (highlightType === 'start' || highlightType === 'finish') {
              if (highlightType === 'start') {
                  // START: Green arrow pointing right (into the maze)
                  const arrowX = c * cellSize + 3;
                  const arrowY = r * cellSize + 3;

                  // Create right-pointing arrow shape
                  const arrowPoints = [
                      { x: arrowX, y: arrowY + arrowSize * 0.35 },                    // Left top
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.35 },  // Shaft top-right
                      { x: arrowX + arrowSize * 0.6, y: arrowY },                     // Head top
                      { x: arrowX + arrowSize, y: arrowY + arrowSize * 0.5 },         // Head point
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize },         // Head bottom
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.65 },  // Shaft bottom-right
                      { x: arrowX, y: arrowY + arrowSize * 0.65 }                     // Left bottom
                  ];

                  const startArrow = new fabric.Polygon(arrowPoints, {
                      fill: '#4CAF50',
                      stroke: '#FFFFFF',
                      strokeWidth: 3,
                      strokeLineJoin: 'round',
                      selectable: false,
                      evented: false,
                      [itemTag]: true
                  });
                  cellObjects.push(startArrow);

              } else if (highlightType === 'finish') {
                  // FINISH: Red arrow pointing right (OUT toward the outer wall)
                  const arrowX = c * cellSize + cellSize - arrowSize - 3;
                  const arrowY = r * cellSize + cellSize - arrowSize - 3;

                  // Create right-pointing arrow shape (pointing OUT of maze toward outer wall)
                  const arrowPoints = [
                      { x: arrowX, y: arrowY + arrowSize * 0.35 },                    // Left top
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.35 },  // Shaft top-right
                      { x: arrowX + arrowSize * 0.6, y: arrowY },                     // Head top
                      { x: arrowX + arrowSize, y: arrowY + arrowSize * 0.5 },         // Head point (RIGHT)
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize },         // Head bottom
                      { x: arrowX + arrowSize * 0.6, y: arrowY + arrowSize * 0.65 },  // Shaft bottom-right
                      { x: arrowX, y: arrowY + arrowSize * 0.65 }                     // Left bottom
                  ];

                  const finishArrow = new fabric.Polygon(arrowPoints, {
                      fill: '#FF5722',
                      stroke: '#FFFFFF',
                      strokeWidth: 3,
                      strokeLineJoin: 'round',
                      selectable: false,
                      evented: false,
                      [itemTag]: true
                  });
                  cellObjects.push(finishArrow);
              }
          }

          try {
              const fabricImg = await new Promise((resolve, reject) => {
                  fabric.Image.fromURL(img.path, (img) => {
                      if (img) resolve(img);
                      else reject(new Error('Failed to load image'));
                  }, { crossOrigin: 'anonymous' });
              });

              // Use original scale for all images
              const maxSize = cellSize * scale;
              const scaleX = maxSize / fabricImg.width;
              const scaleY = maxSize / fabricImg.height;
              const scaleFactor = Math.min(scaleX, scaleY);

              // Position images with proper spacing from arrows
              let imageLeft, imageTop, originX, originY;

              if (highlightType === 'start') {
                  // START: Place image immediately AFTER arrow (no padding calculation error)
                  const arrowStrokeWidth = 3;
                  const arrowRightEnd = c * cellSize + 3 + arrowSize;
                  const visualArrowEnd = arrowRightEnd + (arrowStrokeWidth / 2);

                  console.log('üü¢ START ARROW - cellSize:', cellSize, 'arrowSize:', arrowSize);
                  console.log('üü¢ Arrow polygon right:', arrowRightEnd);
                  console.log('üü¢ Visual arrow end (with stroke):', visualArrowEnd);
                  console.log('üü¢ Image scale:', scale, 'maxSize:', cellSize * scale);

                  // NEGATIVE padding - maximum overlap to eliminate all visual gap
                  imageLeft = arrowRightEnd - 4;  // Start 4px BEFORE arrow polygon edge (maximum overlap)
                  imageTop = centerY;
                  originX = 'left';
                  originY = 'center';

                  console.log('üü¢ Image positioned at:', imageLeft, 'originX:', originX, 'OVERLAP: 4px into arrow');
              } else if (highlightType === 'finish') {
                  // FINISH: Place image immediately BEFORE arrow (no padding calculation error)
                  const arrowStrokeWidth = 3;
                  const arrowLeftEnd = c * cellSize + cellSize - arrowSize - 3;
                  const visualArrowEnd = arrowLeftEnd - (arrowStrokeWidth / 2);

                  console.log('üî¥ FINISH ARROW - cellSize:', cellSize, 'arrowSize:', arrowSize);
                  console.log('üî¥ Arrow polygon left:', arrowLeftEnd);
                  console.log('üî¥ Visual arrow end (with stroke):', visualArrowEnd);
                  console.log('üî¥ Image scale:', scale, 'maxSize:', cellSize * scale);

                  // NEGATIVE padding - overlap arrow stroke to eliminate visual gap (a little bit more)
                  imageLeft = arrowLeftEnd + 4;  // Start 4px AFTER arrow polygon edge (maximum overlap)
                  imageTop = centerY;
                  originX = 'right';
                  originY = 'center';

                  console.log('üî¥ Image positioned at:', imageLeft, 'originX:', originX, 'OVERLAP: 4px into arrow');
              } else {
                  // No arrow, center the image
                  imageLeft = centerX;
                  imageTop = centerY;
                  originX = 'center';
                  originY = 'center';
              }

              fabricImg.set({
                  left: imageLeft,
                  top: imageTop,
                  scaleX: scaleFactor,
                  scaleY: scaleFactor,
                  originX: originX,
                  originY: originY,
                  selectable: true,  // Make images editable
                  hasControls: true,
                  hasBorders: true,
                  lockRotation: false,
                  [itemTag]: true
              });

              cellObjects.push(fabricImg);
              return cellObjects;
          } catch (err) {
              console.error('Error loading image:', err);
              return cellObjects;  // Return highlight even if image fails
          }
      };

      // Place start arrow (always for maze mode, with or without image)
      if (data.isMazeMode) {
          // In maze mode, ALWAYS place arrows even if no start/end images

          // Place START arrow - check if it's outside the maze
          if (data.isChoosePath) {
              // Choose Path: Direction-aware arrow placement
              const mazeDirection = data.mazeDirection || 'bottom-top';
              let arrowX, arrowY, arrowPath, rotation;

              // Arrow pointing UP (default for bottom-top)
              const arrowUpPath = 'M 0,-15 L -10,5 L -4,5 L -4,15 L 4,15 L 4,5 L 10,5 Z';

              if (mazeDirection === 'bottom-top') {
                  // START below maze, arrow points UP
                  const corridorCol = startCell.corridorCell.c;
                  arrowX = corridorCol * cellSize + cellSize / 2;
                  arrowY = mazeHeight + cellSize;
                  arrowPath = arrowUpPath;
                  rotation = 0;

              } else if (mazeDirection === 'top-bottom') {
                  // START above maze, arrow points DOWN
                  const corridorCol = startCell.corridorCell.c;
                  arrowX = corridorCol * cellSize + cellSize / 2;
                  arrowY = -cellSize;
                  arrowPath = arrowUpPath;
                  rotation = 180;

              } else if (mazeDirection === 'left-right') {
                  // START left of maze, arrow points RIGHT
                  const corridorRow = startCell.corridorCell.r;
                  arrowX = -cellSize;
                  arrowY = corridorRow * cellSize + cellSize / 2;
                  arrowPath = arrowUpPath;
                  rotation = 90;

              } else { // 'right-left'
                  // START right of maze, arrow points LEFT
                  const corridorRow = startCell.corridorCell.r;
                  arrowX = mazeWidth + cellSize;
                  arrowY = corridorRow * cellSize + cellSize / 2;
                  arrowPath = arrowUpPath;
                  rotation = 270;
              }

              const arrow = new fabric.Path(arrowPath, {
                  left: arrowX,
                  top: arrowY,
                  fill: '#4CAF50',
                  stroke: '#2E7D32',
                  strokeWidth: 2,
                  originX: 'center',
                  originY: 'center',
                  scaleX: 1.5,
                  scaleY: 1.5,
                  angle: rotation,
                  selectable: false,
                  evented: false,
                  [itemTag]: true
              });
              objects.push(arrow);
          } else {
              // Classic Maze: START inside maze border
              const startArrowOnly = await placeArrowOnly(startCell.r, startCell.c, 'start', itemTag);
              objects.push(...startArrowOnly);
          }

          // Check if this is Choose Path mode (has multiple end cells)
          if (data.endCells && data.endCells.length > 1) {
              // Choose Path mode: place END IMAGES at ALL 3 destinations (not arrows)
              // These will be placed via the items array, not here
          } else {
              // Classic Maze mode: single end cell with arrow
              const endArrowOnly = await placeArrowOnly(endCell.r, endCell.c, 'finish', itemTag);
              objects.push(...endArrowOnly);
          }
      } else {
          // Non-maze modes: place images with arrows
          if (selectedStartImage) {
              const startObjs = await placeImageInCell(selectedStartImage, startCell.r, startCell.c, 0.975, 'start');  // 35% reduction
              objects.push(...startObjs);
          }

          if (selectedEndImage) {
              const endObjs = await placeImageInCell(selectedEndImage, endCell.r, endCell.c, 0.975, 'finish');  // 35% reduction
              objects.push(...endObjs);
          }
      }

      // Place items (collectibles and obstacles) - no highlighting
      for (const item of items) {
          // Check if item is outside the maze borders
          const isOutside = item.r < 0 || item.r >= rows || item.c < 0 || item.c >= cols;

          if (isOutside) {
              // END image OUTSIDE maze border (direction-aware positioning)
              let imgX, imgY;

              if (item.r < 0) {
                  // ABOVE top border (bottom-top direction)
                  // Use smaller images to fit in available space above maze
                  // Image is cellSize * 1.68 tall (30% reduction), so radius = cellSize * 0.84
                  const corridorCol = item.corridorCell.c;
                  imgX = corridorCol * cellSize + cellSize / 2;
                  imgY = -(cellSize * 0.84 + 5) + 12;  // 30% reduction positioning

              } else if (item.r >= rows) {
                  // BELOW bottom border (top-bottom direction)
                  const corridorCol = item.corridorCell.c;
                  imgX = corridorCol * cellSize + cellSize / 2;
                  imgY = mazeHeight + (cellSize * 0.84 + 5) + 43;  // 30% reduction positioning

              } else if (item.c < 0) {
                  // LEFT of left border (right-left direction)
                  // Use smaller images to fit in available space left of maze
                  const corridorRow = item.corridorCell.r;
                  imgX = -(cellSize * 0.84 + 5) + 30;  // 30% reduction positioning
                  imgY = corridorRow * cellSize + cellSize / 2;

              } else { // item.c >= cols
                  // RIGHT of right border (left-right direction)
                  const corridorRow = item.corridorCell.r;
                  imgX = mazeWidth + (cellSize * 0.84 + 5) + 43;  // 30% reduction positioning
                  imgY = corridorRow * cellSize + cellSize / 2;
              }

              const imgObj = await new Promise((resolve) => {
                  fabric.Image.fromURL(item.image.path, (img) => {
                      if (!img) {
                          resolve(null);
                          return;
                      }

                      // Scale image to fit nicely outside maze (30% reduction)
                      const maxSize = cellSize * 1.68;  // 30% reduction from 2.4
                      const scale = Math.min(maxSize / img.width, maxSize / img.height);

                      img.set({
                          left: imgX,
                          top: imgY,
                          scaleX: scale,
                          scaleY: scale,
                          originX: 'center',
                          originY: 'center',
                          selectable: true,
                          hasControls: true,
                          hasBorders: true,
                          [itemTag]: true
                      });

                      resolve(img);
                  });
              });

              if (imgObj) objects.push(imgObj);
          } else {
              // Normal item inside maze
              const itemObjs = await placeImageInCell(item.image, item.r, item.c, 0.91, null);  // 35% reduction
              objects.push(...itemObjs);
          }
      }

      // NOTE: Corridor openings are now created by the border segment logic above
      // No need for overlay lines - gaps appear naturally where border walls are skipped

      // Place obstacles (red X marks blocking wrong corridors)
      if (data.obstacles && data.obstacles.length > 0) {
          const mazeDirection = data.mazeDirection || 'bottom-top';

          for (const obstacle of data.obstacles) {
              let obstacleX, obstacleY;

              if (obstacle.r < 0) {
                  // ABOVE top border (bottom-top direction)
                  // Match END image positioning for consistency
                  const corridorCol = obstacle.corridorCell.c;
                  obstacleX = corridorCol * cellSize + cellSize / 2;
                  obstacleY = -(cellSize * 0.84 + 5) + 12;  // 30% reduction positioning

              } else if (obstacle.r >= rows) {
                  // BELOW bottom border (top-bottom direction)
                  const corridorCol = obstacle.corridorCell.c;
                  obstacleX = corridorCol * cellSize + cellSize / 2;
                  obstacleY = mazeHeight + (cellSize * 0.84 + 5) + 43;  // 30% reduction positioning

              } else if (obstacle.c < 0) {
                  // LEFT of left border (right-left direction)
                  const corridorRow = obstacle.corridorCell.r;
                  obstacleX = -(cellSize * 0.84 + 5) + 30;  // 30% reduction positioning
                  obstacleY = corridorRow * cellSize + cellSize / 2;

              } else { // obstacle.c >= cols
                  // RIGHT of right border (left-right direction)
                  const corridorRow = obstacle.corridorCell.r;
                  obstacleX = mazeWidth + (cellSize * 0.84 + 5) + 43;  // 30% reduction positioning
                  obstacleY = corridorRow * cellSize + cellSize / 2;
              }

              // Create red X mark (two diagonal lines crossing)
              const xSize = cellSize * 0.8;
              const line1 = new fabric.Line(
                  [obstacleX - xSize/2, obstacleY - xSize/2, obstacleX + xSize/2, obstacleY + xSize/2],
                  {
                      stroke: '#D32F2F',
                      strokeWidth: 6,
                      selectable: false,
                      evented: false,
                      [itemTag]: true
                  }
              );
              const line2 = new fabric.Line(
                  [obstacleX + xSize/2, obstacleY - xSize/2, obstacleX - xSize/2, obstacleY + xSize/2],
                  {
                      stroke: '#D32F2F',
                      strokeWidth: 6,
                      selectable: false,
                      evented: false,
                      [itemTag]: true
                  }
              );

              // Optional: Add red circle background for better visibility
              const circle = new fabric.Circle({
                  left: obstacleX,
                  top: obstacleY,
                  radius: xSize / 2,
                  fill: 'rgba(255, 0, 0, 0.2)',
                  stroke: '#D32F2F',
                  strokeWidth: 3,
                  originX: 'center',
                  originY: 'center',
                  selectable: false,
                  evented: false,
                  [itemTag]: true
              });

              objects.push(circle, line1, line2);
          }
          console.log(`Rendered ${data.obstacles.length} red X obstacles`);
      }

      // Separate walls and images for independent editability
      const wallsAndPaths = objects.filter(obj =>
          obj instanceof fabric.Line ||
          obj instanceof fabric.Rect ||
          obj instanceof fabric.Circle ||
          obj instanceof fabric.Path ||
          obj instanceof fabric.Polygon ||  // ‚Üê FINISH STAR!
          obj instanceof fabric.Text        // ‚Üê FINISH CHECKMARK & START TEXT!
      );

      const images = objects.filter(obj => obj instanceof fabric.Image);

      // Group walls, paths, and highlights (non-image elements)
      const mazeStructureGroup = new fabric.Group(wallsAndPaths, {
          left: mazeLeft,
          top: mazeTop,
          selectable: true,
          hasControls: true,
          hasBorders: true,
          [itemTag]: true
      });

      // Position images separately so they remain individually editable
      images.forEach(img => {
          img.set({
              left: img.left + mazeLeft,
              top: img.top + mazeTop
          });
      });

      // Create legend below maze
      const legendTop = mazeTop + mazeHeight + 40;
      const legendObjects = await createMazeLegend(
          items,
          mazeLeft,
          legendTop,
          mazeWidth,
          cellSize,
          isAnswerKey,
          itemTag
      );

      return [mazeStructureGroup, ...images, ...legendObjects];
  }

  // Creates puzzle grid from stored data (follows wordsearch pattern)
  async function createPuzzleGrid(data, isAnswerKey) {
      if (!data) return [];

      // Check if this is a wall-based maze
      if (data.isMazeMode) {
          return await createMazeWithWalls(data, isAnswerKey);
      }

      const { solutionPath, gridData, rows, cols } = data;
      const itemTag = isAnswerKey ? 'isAnswerKeyItem' : 'isGeneratedItem';

      // Get current page dimensions
      const pageWidth = currentCanvasConfig.width;
      const pageHeight = currentCanvasConfig.height;
      const isLandscape = pageWidth > pageHeight;

      // Responsive header height (CRITICAL: must account for description bottom!)
      // Landscape: desc at top=135, fontSize=14 ‚Üí desc bottom ~165px (add 30px buffer)
      // Portrait: desc at top=190, fontSize=20 ‚Üí desc bottom ~230px (add 40px buffer)
      const HEADER_HEIGHT = isLandscape ? 165 : 240;
      const pageMargin = 50;
      const nameDateHeight = includeNameDateCheckbox.checked ? 60 : 0;

      // Calculate available space within margins
      const availableWidth = pageWidth - (2 * pageMargin);
      const availableHeight = pageHeight - HEADER_HEIGHT - pageMargin - nameDateHeight;

      // Grid configuration
      const gridInnerPadding = 10;
      const cellSpacing = 8;

      // Calculate optimal image size to fit within available space
      const maxCellWidth = (availableWidth - 2 * gridInnerPadding - (cols - 1) * cellSpacing) / cols;
      const maxCellHeight = (availableHeight - 2 * gridInnerPadding - (rows - 1) * cellSpacing) / rows;
      const imageSize = Math.min(maxCellWidth, maxCellHeight, 90);

      const totalCellDim = imageSize + cellSpacing;
      const gridWidth = cols * imageSize + (cols - 1) * cellSpacing + 2 * gridInnerPadding;
      const gridHeight = rows * imageSize + (rows - 1) * cellSpacing + 2 * gridInnerPadding;

      // Positioning logic:
      // Worksheet landscape: 10px up (moved 50px down from original 60px up)
      // Worksheet portrait: centered (0px offset)
      // Answer key landscape: centered (moved 20px right from previous -20px left)
      // Answer key portrait: 20px up (moved 10px down from original 30px up)
      const verticalOffset = isAnswerKey ? (isLandscape ? 0 : 20) : (isLandscape ? 10 : 0);
      const horizontalOffset = isAnswerKey && isLandscape ? 0 : 0;

      const gridTopOffset = HEADER_HEIGHT + nameDateHeight + (availableHeight - gridHeight) / 2 - verticalOffset;
      const gridLeftOffset = pageMargin + (availableWidth - gridWidth) / 2 + horizontalOffset;

      const gridBorder = new fabric.Rect({
          left: 0, top: 0, width: gridWidth, height: gridHeight,
          fill: 'transparent', stroke: '#89CFF0', strokeWidth: 5,
          rx: 15, ry: 15, shadow: 'rgba(0,0,0,0.15) 3px 3px 7px',
      });

      const problemImages = [];
      for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
              const left = c * (imageSize + cellSpacing) + gridInnerPadding;
              const top = r * (imageSize + cellSpacing) + gridInnerPadding;
              const cellData = gridData[r][c];

              // Support both old format (direct image) and new format (object with image and type)
              const imgData = cellData.image || cellData;
              const cellType = cellData.type || null;

              const imgInstance = await new Promise(resolve => {
                  fabric.Image.fromURL(imgData.path, function(img) {
                      if (!img) { resolve(null); return; }
                      img.scaleToWidth(imageSize * 0.62);  // 35% reduction

                      let finalObject;
                      let needsBorder = false;
                      let borderColor = null;
                      let borderWidth = 3;

                      // Check if this needs a colored border
                      if (imgData === data.selectedStartImage || cellType === 'start') {
                          needsBorder = true;
                          borderColor = '#34C759'; // Green for start
                      } else if (imgData === data.selectedEndImage || cellType === 'end') {
                          needsBorder = true;
                          borderColor = '#FF3B30'; // Red for end
                      } else if (cellType === 'collectible') {
                          needsBorder = true;
                          borderColor = '#34C759'; // Green for collectibles
                          borderWidth = 4;
                      } else if (cellType === 'obstacle') {
                          needsBorder = true;
                          borderColor = '#FF3B30'; // Red for obstacles
                          borderWidth = 4;
                      }

                      if (needsBorder) {
                          const highlightRect = new fabric.Rect({
                              width: img.getScaledWidth() + 8, height: img.getScaledHeight() + 8,
                              fill: 'transparent', stroke: borderColor, strokeWidth: borderWidth,
                              rx: 8, ry: 8, originX: 'center', originY: 'center'
                          });
                          img.set({ originX: 'center', originY: 'center' });

                          // Add X mark for obstacles
                          if (cellType === 'obstacle') {
                              const xSize = img.getScaledWidth() + 8;
                              const line1 = new fabric.Line([-xSize/2, -xSize/2, xSize/2, xSize/2], {
                                  stroke: '#FF3B30', strokeWidth: 3, originX: 'center', originY: 'center'
                              });
                              const line2 = new fabric.Line([xSize/2, -xSize/2, -xSize/2, xSize/2], {
                                  stroke: '#FF3B30', strokeWidth: 3, originX: 'center', originY: 'center'
                              });
                              finalObject = new fabric.Group([highlightRect, img, line1, line2]);
                          } else {
                              finalObject = new fabric.Group([highlightRect, img]);
                          }
                      } else {
                          finalObject = img;
                      }

                      finalObject.set({
                          left: left + (imageSize / 2), top: top + (imageSize / 2),
                          originX: 'center', originY: 'center',
                          selectable: false, evented: false, crossOrigin: 'anonymous', objectCaching: false
                      });
                      resolve(finalObject);
                  }, { crossOrigin: 'anonymous' });
              });
              if (imgInstance) problemImages.push(imgInstance);
          }
      }

      // For answer key, add solution path
      if (isAnswerKey) {
          // Check if this is "Choose the Right Path" mode
          if (data.correctPathIndex !== undefined && data.allPaths) {
              // Choose the Right Path mode - show correct path only
              const correctPath = data.allPaths[data.correctPathIndex].path;
              if (correctPath && correctPath.length > 0) {
                  const solutionPoints = correctPath.map(({r, c}) => ({
                      x: c * (imageSize + cellSpacing) + gridInnerPadding + imageSize / 2,
                      y: r * (imageSize + cellSpacing) + gridInnerPadding + imageSize / 2
                  }));
                  const pathLine = new fabric.Polyline(solutionPoints, {
                      stroke: '#34C759', strokeWidth: 6, fill: '', strokeDashArray: [10, 5],
                      selectable: false, evented: false, objectCaching: false
                  });
                  problemImages.push(pathLine);

                  // Add text label at correct starting point
                  const startCell = correctPath[0];
                  const startX = startCell.c * (imageSize + cellSpacing) + gridInnerPadding + imageSize / 2;
                  const startY = startCell.r * (imageSize + cellSpacing) + gridInnerPadding - 20;
                  const correctLabel = new fabric.Text('‚úì CORRECT PATH', {
                      left: startX, top: startY, fontSize: 14, fill: '#34C759',
                      fontWeight: 'bold', originX: 'center', originY: 'bottom',
                      selectable: false, evented: false, objectCaching: false
                  });
                  problemImages.push(correctLabel);
              }
          } else if (solutionPath && solutionPath.length > 0) {
              // Picture Pathway or Classic Maze mode - show solution path
              const solutionPoints = solutionPath.map(({r, c}) => ({
                  x: c * (imageSize + cellSpacing) + gridInnerPadding + imageSize / 2,
                  y: r * (imageSize + cellSpacing) + gridInnerPadding + imageSize / 2
              }));
              const pathLine = new fabric.Polyline(solutionPoints, {
                  stroke: 'red', strokeWidth: 5, fill: '', strokeDashArray: [10, 5],
                  selectable: false, evented: false, objectCaching: false
              });
              problemImages.push(pathLine);
          }
      }

      const gridGroup = new fabric.Group([gridBorder, ...problemImages], {
          left: gridLeftOffset, top: gridTopOffset,
          selectable: true, evented: true, [itemTag]: true, originalIndex: 0,
          objectCaching: false, borderColor: 'var(--app-accent-primary)', cornerColor: 'var(--app-accent-primary)',
          cornerSize: 10, transparentCorners: false, cornerStyle: 'circle'
      });

      const objects = [gridGroup];

      // Add name/date field if needed (only for worksheet)
      if (!isAnswerKey && includeNameDateCheckbox.checked) {
          const nameDateGroup = new fabric.Group([
              new fabric.Textbox(t('picture.pathway.name.field'), { fontSize: 18, fontFamily: fontFamilySelect.options[0].value, fill: '#333', left: 0, top: 0 }),
              new fabric.Textbox(t('picture.pathway.date.field'), { fontSize: 18, fontFamily: fontFamilySelect.options[0].value, fill: '#333', left: 300, top: 0 })
          ], {
              left: pageMargin, top: pageMargin, isGeneratedItem: true, originalIndex: 1,
              selectable: true, hasControls: true, hasBorders: true,
              borderColor: 'var(--app-accent-primary)', cornerColor: 'var(--app-accent-primary)',
              cornerSize: 8, transparentCorners: false, cornerStyle: 'circle'
          });
          objects.push(nameDateGroup);
      }

      return objects;
  }


  /********************************
   * Canvas Initialization & Management
   ********************************/
  function initializeCanvas(canvasEl) {
      return new fabric.Canvas(canvasEl, {
          width: currentCanvasConfig.width,
          height: currentCanvasConfig.height,
          backgroundColor: '#fff',
          preserveObjectStacking: true,
          enableRetinaScaling: true // For high-res previews
      });
  }

  // ============================================
  // ZOOM FUNCTIONALITY
  // Exact implementation from wordsearch.html lines 1745-1767
  // ============================================

  function zoomIn() {
      // Increase zoom by 25%, max 300%
      userZoomLevel = Math.min(userZoomLevel + 0.25, 3.0);
      updateZoomDisplay();
      updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
  }

  function zoomOut() {
      // Decrease zoom by 25%, min 25%
      userZoomLevel = Math.max(userZoomLevel - 0.25, 0.25);
      updateZoomDisplay();
      updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
  }

  function zoomReset() {
      // Reset to 100%
      userZoomLevel = 1.0;
      updateZoomDisplay();
      updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
  }

  function updateZoomDisplay() {
      if (zoomPercentage) {
          zoomPercentage.textContent = Math.round(userZoomLevel * 100) + '%';
      }
  }

  async function updateCanvasDisplayDimensions(width, height, fromLoad = false) {
      currentCanvasConfig.width = width;
      currentCanvasConfig.height = height;

      const mainContentAreaStyle = getComputedStyle(document.querySelector('.tab-content-wrapper'));
      const availableWidth = parseFloat(mainContentAreaStyle.width) - parseFloat(mainContentAreaStyle.paddingLeft) - parseFloat(mainContentAreaStyle.paddingRight) - 50;
      const availableHeight = parseFloat(mainContentAreaStyle.height) - parseFloat(mainContentAreaStyle.paddingTop) - parseFloat(mainContentAreaStyle.paddingBottom) - 50;
      
      // Apply 25% scaling for better visibility
      const isLandscape = width > height;
      const baseScale = 1.25; // Base 25% larger for all
      const landscapeBonus = isLandscape ? 1.25 : 1.0; // Additional 25% for landscape
      const displayScale = baseScale * landscapeBonus * userZoomLevel; // Apply user zoom level

      // Calculate display dimensions with scaling
      const scaledWidth = width * displayScale;
      const scaledHeight = height * displayScale;

      // When zoomed beyond 100%, allow canvas to overflow viewport (creates scrollbars)
      // When at 100% or less, constrain to fit within viewport
      let scaleRatio;
      if (userZoomLevel > 1.0) {
          scaleRatio = 1; // No viewport constraint - allow overflow
      } else {
          scaleRatio = Math.min(availableWidth / scaledWidth, availableHeight / scaledHeight, 1);
      }
      const displayWidth = scaledWidth * scaleRatio;
      const displayHeight = scaledHeight * scaleRatio;
      
      [worksheetCanvas, answerKeyCanvas].forEach(c => {
          if (c) {
              // CRITICAL: Update actual canvas dimensions FIRST
              c.setWidth(width);
              c.setHeight(height);

              // Apply zoom for display scaling
              const finalZoom = displayWidth / width;
              c.setZoom(finalZoom);

              // Set dimensions AFTER zoom to ensure viewport matches zoomed size
              c.setDimensions({
                  width: displayWidth,
                  height: displayHeight
              });

              c.calcOffset();

              // Update hit detection areas for all objects after zoom
              c.getObjects().forEach(obj => {
                  obj.setCoords();
              });

              c.renderAll();
          }
      });
      [worksheetCanvasWrapper, answerKeyCanvasWrapper].forEach(w => {
          if(w) {
              w.style.width = displayWidth + 'px'; w.style.height = displayHeight + 'px';
          }
      });

      if (!fromLoad) {
          pageWidthInput.value = width;
          pageHeightInput.value = height;
          // Regenerate layout when page size changes (repositions existing content)
          // CRITICAL: await to prevent race condition with generatePathway()
          await regenerateHeadersOnly();
      }
  }

  pageSizeSelect.addEventListener('change', async function() {
      const selectedValue = this.value;
      if (selectedValue === 'custom') {
          customPageSizeInputsDiv.style.display = 'block';
      } else {
          customPageSizeInputsDiv.style.display = 'none';
          const [w, h] = selectedValue.split('x').map(Number);
          await updateCanvasDisplayDimensions(w, h);
      }
  });

  setPageSizeBtn.addEventListener('click', async () => {
      let newWidth, newHeight;
      if (pageSizeSelect.value === 'custom' || customPageSizeInputsDiv.style.display === 'block') {
          newWidth = parseInt(pageWidthInput.value, 10) || currentCanvasConfig.width;
          newHeight = parseInt(pageHeightInput.value, 10) || currentCanvasConfig.height;
      } else {
          [newWidth, newHeight] = pageSizeSelect.value.split('x').map(Number);
      }
      await updateCanvasDisplayDimensions(newWidth, newHeight);
  });

  pageColorInput.addEventListener('input', () => {
    const newColor = pageColorInput.value;
    if (worksheetCanvas) {
        worksheetCanvas.backgroundColor = newColor;
        worksheetCanvas.renderAll();
    }
    if (answerKeyCanvas) {
        answerKeyCanvas.backgroundColor = newColor;
        answerKeyCanvas.renderAll();
    }
  });

  /********************************
   * Text Tools Functions
   ********************************/
  addTextBtn.addEventListener('click', addText);

  function addText() {
      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;
      const textContent = textInput.value.trim() || 'New Text';
      const textObject = new fabric.Textbox(textContent, {
          left: (currentCanvasConfig.width - 250) / 2,
          top: (currentCanvasConfig.height - 100) / 2,
          fontSize: 48,
          fill: '#333333',
          fontFamily: 'Arial',
          width: 250,
          padding: 8,
          borderColor: 'var(--app-accent-primary)',
          cornerColor: 'var(--app-accent-primary)',
          cornerSize: 10,
          transparentCorners: false,
          cornerStyle: 'circle',
          stroke: '#000000',
          strokeWidth: 0
      });
      activeCanvas.add(textObject);
      activeCanvas.setActiveObject(textObject);
      activeCanvas.renderAll();
      textInput.value = '';
      displayMessage(t('picture.pathway.msg.text.added'), 'success', 1500);
  }

  function updateActiveTextObjectProperties() {
      const activeCanvas = getActiveCanvas();
      if (!activeCanvas) return;
      const activeObject = activeCanvas.getActiveObject();

      if (!activeObject || activeObject.type === 'activeSelection' ||
          !(activeObject.type === 'textbox' || activeObject.type === 'i-text' || activeObject.type === 'text')) {
          return;
      }

      const newProps = {};
      let propsChanged = false;

      const currentFill = typeof activeObject.fill === 'string' ? activeObject.fill : '';
      if (textColorInput.value !== currentFill) {
          newProps.fill = textColorInput.value;
          propsChanged = true;
      }
      const currentFontSize = activeObject.fontSize;
      const newFontSize = parseInt(fontSizeInput.value, 10);
      if (!isNaN(newFontSize) && newFontSize > 0 && newFontSize !== currentFontSize) {
          newProps.fontSize = newFontSize;
          propsChanged = true;
      }
      const currentFontFamily = activeObject.fontFamily;
      if (fontFamilySelect.value !== currentFontFamily) {
          newProps.fontFamily = fontFamilySelect.value;
          propsChanged = true;
      }
      const currentStroke = typeof activeObject.stroke === 'string' ? activeObject.stroke : '';
      if (textStrokeColorInput.value !== currentStroke) {
          newProps.stroke = textStrokeColorInput.value;
          propsChanged = true;
      }
      const currentStrokeWidth = activeObject.strokeWidth;
      const newStrokeWidth = parseFloat(textStrokeWidthInput.value);
      if (!isNaN(newStrokeWidth) && newStrokeWidth >= 0 && newStrokeWidth !== currentStrokeWidth) {
          newProps.strokeWidth = newStrokeWidth;
          propsChanged = true;
      }
      if (document.activeElement === textInput && textInput.value !== activeObject.text) {
          newProps.text = textInput.value;
          propsChanged = true;
      }
      if (propsChanged && Object.keys(newProps).length > 0) {
          activeObject.set(newProps);
          activeCanvas.renderAll();
      }
  }

  textInput.addEventListener('input', updateActiveTextObjectProperties);
  textColorInput.addEventListener('input', updateActiveTextObjectProperties);
  fontSizeInput.addEventListener('input', updateActiveTextObjectProperties);
  fontFamilySelect.addEventListener('change', updateActiveTextObjectProperties);
  textStrokeColorInput.addEventListener('input', updateActiveTextObjectProperties);
  textStrokeWidthInput.addEventListener('input', updateActiveTextObjectProperties);

  function setupGlobalKeydownListener() {
    window.addEventListener('keydown', function(e) {
        const activeCanvas = getActiveCanvas();
        if (!activeCanvas) return;
        const activeElement = document.activeElement;
        if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.tagName === 'SELECT')) {
            if (activeElement.closest('.panel') || activeElement.closest('.dropdown-content')) {
                return;
            }
        }

        // Undo: Ctrl+Z (or Cmd+Z on Mac)
        if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
            e.preventDefault();
            undo();
            return;
        }

        // Redo: Ctrl+Y or Ctrl+Shift+Z (or Cmd+Y / Cmd+Shift+Z on Mac)
        if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
            e.preventDefault();
            redo();
            return;
        }

        const activeObject = activeCanvas.getActiveObject();
        if (activeObject && (e.key === 'Delete' || e.key === 'Backspace')) {
            if (activeObject.isEditing) {
                return;
            }
            deleteSelectedObjects();
        }
    });
  }

  function handleObjectSelection(e, canvas) {
      objectContextToolbar.style.display = 'flex';
      const activeObject = e.target || canvas.getActiveObject();
      if (!activeObject) {
          handleSelectionCleared(null, canvas);
          return;
      }

      const isGroup = activeObject.type === 'activeSelection';

      allToolbarButtons.forEach(btn => btn.disabled = false);
      document.querySelectorAll('#alignDropdown button').forEach(btn => {
          if (btn.id.includes('Canvas')) {
              btn.disabled = isGroup; // Disable align-to-canvas for multi-selection
          } else {
              btn.disabled = !isGroup; // Disable align-to-each-other for single selection
          }
      });

      const isSingleTextObject = activeObject.type !== 'activeSelection' &&
                                 (activeObject.type === 'textbox' || activeObject.type === 'i-text' || activeObject.type === 'text');

      textColorInput.disabled = !isSingleTextObject;
      fontSizeInput.disabled = !isSingleTextObject;
      fontFamilySelect.disabled = !isSingleTextObject;
      textStrokeColorInput.disabled = !isSingleTextObject;
      textStrokeWidthInput.disabled = !isSingleTextObject;
      textInput.disabled = !isSingleTextObject;

      if (isSingleTextObject) {
          textInput.value = activeObject.text || "";
          textColorInput.value = typeof activeObject.fill === 'string' ? activeObject.fill : '#333333';
          fontSizeInput.value = activeObject.fontSize || 48;
          fontFamilySelect.value = activeObject.fontFamily || fontFamilySelect.options[0].value;
          textStrokeColorInput.value = typeof activeObject.stroke === 'string' ? activeObject.stroke : '#000000';
          textStrokeWidthInput.value = activeObject.strokeWidth || 0;
      } else {
          textColorInput.value = '#333333';
          textColorInput.disabled = true;
          fontSizeInput.value = 48;
          fontSizeInput.disabled = true;
          fontFamilySelect.value = fontFamilySelect.options[0].value;
          fontFamilySelect.disabled = true;
          textStrokeColorInput.value = '#000000';
          textStrokeColorInput.disabled = true;
          textStrokeWidthInput.value = 0;
          textStrokeWidthInput.disabled = true;
          if (document.activeElement !== textInput) {
            textInput.value = "";
          }
          textInput.disabled = false;
      }
  }

  function handleSelectionCleared(e, canvas) {
      objectContextToolbar.style.display = 'none';
      closeAllPopovers();

      textColorInput.value = '#333333';
      textColorInput.disabled = true;
      fontSizeInput.value = 48;
      fontSizeInput.disabled = true;
      fontFamilySelect.value = fontFamilySelect.options[0].value;
      fontFamilySelect.disabled = true;
      textStrokeColorInput.value = '#000000';
      textStrokeColorInput.disabled = true;
      textStrokeWidthInput.value = 0;
      textStrokeWidthInput.disabled = true;

      if (document.activeElement !== textInput) {
        textInput.value = "";
      }
      textInput.disabled = false;
  }

  /********************************
   * Display Messages in Sidebar
   ********************************/
  function displayMessage(message, type = 'info', duration = 3000) {
      if (!messageArea) {
          console.error("Message area not found!");
          return;
      }
      messageArea.textContent = message;
      messageArea.className = 'message-area ' + type; 

      if (messageTimeout) { 
          clearTimeout(messageTimeout);
      }

      if (duration > 0) {
          messageTimeout = setTimeout(() => {
              messageArea.textContent = '';
              messageArea.className = 'message-area';
          }, duration);
      }
  }

  // Alias for undo/redo system compatibility
  function showMessage(message, type = 'info', duration = 3000) {
      displayMessage(message, type, duration);
  }

  function clearMessage() {
      if (messageArea) {
          messageArea.textContent = '';
          messageArea.className = 'message-area'; 
      }
      if (messageTimeout) {
          clearTimeout(messageTimeout);
      }
  }

  /********************************
   * Image Library Logic (Dictionary System)
   ********************************/
  async function loadThemes() {
    fetch(`/api/themes-translated?locale=${currentLocale}`)
      .then(res => { if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`); return res.json(); })
      .then(themes => {
        themeSelect.innerHTML = `<option value="all">${t('picture.pathway.themes.all')}</option>`;

        // Process translated themes from the API
        themes.forEach(theme => {
            const opt = document.createElement("option");
            // Use theme.value for the actual folder name
            opt.value = theme.value || theme;
            // Use theme.displayName for the translated display name
            opt.textContent = theme.displayName || theme.value || theme;
            themeSelect.appendChild(opt);
        });

        loadDictionary();
      })
      .catch(err => { console.error("Error loading themes:", err); displayMessage(t('picture.pathway.msg.themes.error'), 'error'); dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.themes.loading.error')}</p>`; });
  }

  async function loadDictionary() {
    const query = searchInput.value.trim().toLowerCase();
    
    let imagesToRender = [];

    if (selectedTheme === 'all') {
        if (!query) {
            // Load animals theme by default when "All Themes" is selected with no search
            const animalsTheme = 'animals';
            dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.loading.animals')}</p>`;
            try {
                const res = await fetch(`/api/images?theme=${encodeURIComponent(animalsTheme)}&locale=${currentLocale}`);
                if (!res.ok) throw new Error(t('picture.pathway.msg.animals.error'));
                const data = await res.json();
                const themeImages = data.images || data; // Handle both old and new API formats
                allImages = themeImages;
                imagesToRender = themeImages;
            } catch (err) {
                console.error("Error loading animals theme:", err);
                dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.animals.error')}</p>`;
                allImages = [];
                return;
            }
        } else {
            dictionaryDiv.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.searching')}</p>`;
            try {
                const res = await fetch(`/api/images?search=${encodeURIComponent(query)}&locale=${currentLocale}`);
                if (!res.ok) throw new Error(t('picture.pathway.msg.search.error'));
                const data = await res.json();
                    imagesToRender = data.images || data; // Handle both old and new API formats
                allImages = []; // Not storing search results globally
            } catch (err) {
                console.error("Error searching images:", err);
                displayMessage(err.message, 'error');
                dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.search.error')}</p>`;
                allImages = [];
                return;
            }
        }
    } else {
        const themeName = themeSelect.options[themeSelect.selectedIndex].text;
        dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.loading.theme').replace('{theme}', themeName)}</p>`;
        try {
            const res = await fetch(`/api/images?theme=${encodeURIComponent(selectedTheme)}&locale=${currentLocale}`);
            if (!res.ok) throw new Error(t('picture.pathway.msg.images.error'));
            const data = await res.json();
                const themeImages = data.images || data; // Handle both old and new API formats
            allImages = themeImages; // Store for generator and client-side filtering
            imagesToRender = query ? themeImages.filter(img => {
                const searchTerm = (img.word || img.name || '').toLowerCase();
                return searchTerm.includes(query);
            }) : themeImages;
        } catch (err) {
            console.error("Error loading dictionary:", err);
            dictionaryDiv.innerHTML = `<p class='dictionary-message'>${t('picture.pathway.msg.images.error')}</p>`;
            allImages = [];
            return;
        }
    }

    dictionaryDiv.innerHTML = "";
    if (imagesToRender.length === 0) {
        const queryPart = query ? ` matching "${query}"` : '';
        dictionaryDiv.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.no.images').replace('{query}', queryPart)}</p>`;
        return;
    }

    imagesToRender.sort((a, b) => {
        const aName = a.word || a.name || '';
        const bName = b.word || b.name || '';
        return aName.localeCompare(bName);
    }).forEach(img => {
        const item = document.createElement("div");
        item.className = "dictionary-item";
        const isSelected = isImageSelected(img);
        if (isSelected) item.classList.add('selected');
        
        const displayName = img.name || img.word; // Use translated name if available
        item.innerHTML = `<img src="${img.path}" alt="${displayName}" loading="lazy"/><span>${displayName}</span>`;
        item.onclick = () => addImageToSelection(img);
        dictionaryDiv.appendChild(item);
    });
  }

  function renderUploadedImages() {
      uploadedImagesPreviewDiv.innerHTML = "";
      if (uploadedImages.length === 0) {
          uploadedImagesPreviewDiv.innerHTML = `<p class="dictionary-message">Your uploaded images will appear here.</p>`;
          return;
      }
      uploadedImages.forEach(img => {
          const item = document.createElement("div");
          item.className = "dictionary-item";
          const isSelected = isImageSelected(img);
          if (isSelected) item.classList.add('selected');

          const displayName = img.name || img.word; // Use translated name if available
        item.innerHTML = `<img src="${img.path}" alt="${displayName}" loading="lazy"/><span>${displayName}</span>`;
          item.onclick = () => addImageToSelection(img);
          uploadedImagesPreviewDiv.appendChild(item);
      });
  }

  function isImageSelected(imgData) {
    return (selectedStartImage && selectedStartImage.path === imgData.path) ||
           (selectedEndImage && selectedEndImage.path === imgData.path) ||
           selectedPathImages.some(i => i.path === imgData.path) ||
           selectedDistractorImages.some(i => i.path === imgData.path);
  }

  function addImageToSelection(imgData) {
    clearMessage();

    const selType = selectionTypeSelect.value;

    // Handle decoration mode - place image directly on canvas
    if (selType === 'decoration') {
      placeDecorationImage(imgData);
      return;
    }

    // Check if image is already selected in any category
    if (isImageSelected(imgData)) {
      // If already selected, remove it
      removeImageFromSelection(imgData);
      return;
    }

    if (selType === 'start') {
      if (selectedStartImage) { displayMessage(t('picture.pathway.msg.one.start'), 'info'); return; }
      selectedStartImage = imgData;
    } else if (selType === 'end') {
      // Get current game mode
      const gameMode = document.getElementById('gameModeSelect').value;

      if (gameMode === 'choose-path') {
        // Choose Path: Allow up to 3 END images (stored in pathImages array)
        if (selectedPathImages.length >= 3) {
          displayMessage('Maximum 3 End images allowed for Choose the Right Path mode', 'info');
          return;
        }
        selectedPathImages.push(imgData);
      } else {
        // Other modes: Single END image only
        if (selectedEndImage) { displayMessage(t('picture.pathway.msg.one.end'), 'info'); return; }
        selectedEndImage = imgData;
      }
    } else if (selType === 'path') {
      selectedPathImages.push(imgData);
    } else if (selType === 'distractor') {
      selectedDistractorImages.push(imgData);
    }
    updateSelectionPreviews();
    updateDictionaryItemSelection(imgData.path, true);
  }

  // Place a decoration image on the canvas
  function placeDecorationImage(imgData) {
    fabric.Image.fromURL(imgData.path, (img) => {
      if (!img) {
        displayMessage('Failed to load image', 'error');
        return;
      }

      // Scale image to reasonable size (max 150px)
      const maxSize = 150;
      const scale = Math.min(maxSize / img.width, maxSize / img.height);

      img.set({
        left: worksheetCanvas.width / 2,
        top: worksheetCanvas.height / 2,
        scaleX: scale,
        scaleY: scale,
        originX: 'center',
        originY: 'center',
        selectable: true,
        hasControls: true,
        hasBorders: true
        // NOT setting isGeneratedItem - these are user-placed decorations
      });

      worksheetCanvas.add(img);
      worksheetCanvas.setActiveObject(img);
      worksheetCanvas.renderAll();

      displayMessage('Decoration placed! You can move, resize, and rotate it.', 'success', 3000);
    }, { crossOrigin: 'anonymous' });
  }

  function removeImageFromSelection(imgData) {
    if (selectedStartImage && selectedStartImage.path === imgData.path) {
      selectedStartImage = null;
    } else if (selectedEndImage && selectedEndImage.path === imgData.path) {
      selectedEndImage = null;
    } else {
      const pathIndex = selectedPathImages.findIndex(i => i.path === imgData.path);
      if (pathIndex !== -1) {
        selectedPathImages.splice(pathIndex, 1);
      } else {
        const distractorIndex = selectedDistractorImages.findIndex(i => i.path === imgData.path);
        if (distractorIndex !== -1) {
          selectedDistractorImages.splice(distractorIndex, 1);
        }
      }
    }
    updateSelectionPreviews();
    updateDictionaryItemSelection(imgData.path, false);
  }

  function updateDictionaryItemSelection(imgPath, isSelected) {
      const items = dictionaryDiv.querySelectorAll('.dictionary-item');
      items.forEach(item => {
          if (item.querySelector('img').src.endsWith(imgPath)) {
              item.classList.toggle('selected', isSelected);
          }
      });
      const uploadedItems = uploadedImagesPreviewDiv.querySelectorAll('.dictionary-item');
      uploadedItems.forEach(item => {
          if (item.querySelector('img').src === imgPath) {
              item.classList.toggle('selected', isSelected);
          }
      });
  }

  function updateSelectionPreviews() {
    const gameMode = document.getElementById('gameModeSelect').value;

    startSelectionDiv.innerHTML = '';
    if (selectedStartImage) {
      const im = document.createElement('img'); im.src = selectedStartImage.path; im.alt = selectedStartImage.word; im.onclick = () => removeImageFromSelection(selectedStartImage);
      startSelectionDiv.appendChild(im);
    }

    endSelectionDiv.innerHTML = '';
    if (selectedEndImage) {
      const im = document.createElement('img'); im.src = selectedEndImage.path; im.alt = selectedEndImage.word; im.onclick = () => removeImageFromSelection(selectedEndImage);
      endSelectionDiv.appendChild(im);
    }

    pathSelectionDiv.innerHTML = '';
    selectedPathImages.forEach(img => {
      const im = document.createElement('img'); im.src = img.path; im.alt = img.word; im.onclick = () => removeImageFromSelection(img);
      pathSelectionDiv.appendChild(im);
    });

    distractorSelectionDiv.innerHTML = '';
    selectedDistractorImages.forEach(img => {
      const im = document.createElement('img'); im.src = img.path; im.alt = img.word; im.onclick = () => removeImageFromSelection(img);
      distractorSelectionDiv.appendChild(im);
    });

    // Update counts
    startCountSpan.textContent = selectedStartImage ? 1 : 0;
    if (gameMode === 'choose-path') {
      // In Choose Path mode, END images are in pathImages array
      endCountSpan.textContent = 0;
      pathCountSpan.textContent = selectedPathImages.length;  // Shows END image count
    } else {
      endCountSpan.textContent = selectedEndImage ? 1 : 0;
      pathCountSpan.textContent = selectedPathImages.length;
    }
    distractorCountSpan.textContent = selectedDistractorImages.length;
  }

  clearSelectionBtn.addEventListener('click', () => {
    clearMessage();
    selectedStartImage = null;
    selectedEndImage = null;
    selectedPathImages = [];
    selectedDistractorImages = [];
    updateSelectionPreviews();
  });

  // Custom file button handler
  customFileButton.addEventListener('click', () => {
      imageUploadInput.click();
  });

  imageUploadInput.addEventListener('change', (e) => {
      const files = e.target.files;
      if(!files || files.length === 0) {
          customFileStatus.textContent = t('picture.pathway.upload.no.file');
          return;
      }

      // Update custom file status
      const count = files.length;
      if (count === 1) {
          customFileStatus.textContent = files[0].name;
      } else {
          customFileStatus.textContent = t('picture.pathway.upload.files.selected').replace('{count}', count);
      }

      let filesToLoad = Array.from(files).filter(f => f.type.startsWith('image/')).length;
      if(filesToLoad === 0) return;

      uploadedImagesPreviewDiv.innerHTML = `<p class='dictionary-message'>Loading ${filesToLoad} image(s)...</p>`;
      
      for(const file of files) {
          if(!file.type.startsWith('image/')) continue;
          const reader = new FileReader();
          reader.onload = (event) => {
              if (!uploadedImages.some(img => img.path === event.target.result)) {
                  uploadedImages.push({word: file.name, name: file.name, path: event.target.result});
              }
              filesToLoad--;
              if (filesToLoad === 0) {
                  renderUploadedImages();
                  displayMessage(t('picture.pathway.msg.custom.available').replace('{count}', uploadedImages.length), 'success');
              }
          };
          reader.onerror = () => {
              filesToLoad--;
              displayMessage(t('picture.pathway.msg.file.error').replace('{name}', file.name), 'error');
          };
          reader.readAsDataURL(file);
      }
      imageUploadInput.value = ''; // Reset file input
      customFileStatus.textContent = t('picture.pathway.upload.no.file'); // Reset status
  });


  /********************************
   * Tab Switching
   ********************************/
  document.querySelectorAll('.tab-button').forEach(btn => {
    btn.addEventListener('click', () => {
      clearMessage();
      
      const activeCanvas = getActiveCanvas();
      if (activeCanvas) {
        activeCanvas.discardActiveObject().renderAll();
      }

      document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      const activeTab = document.getElementById(btn.dataset.tab);
      if (activeTab) activeTab.classList.add('active');
      
      handleSelectionCleared(null, getActiveCanvas());
    });
  });

  /********************************
   * Pathway Generation Logic
   ********************************/
  function getRandomInt(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function generatePath(targetMin, targetMax, rows, cols) {
    const maxAttempts = 1000;
    for (let attempt = 0; attempt < maxAttempts; attempt++) {
      let path = [];
      let visited = new Set();
      let r = getRandomInt(0, rows - 1);
      let c = getRandomInt(0, cols - 1);
      path.push({ r, c });
      visited.add(`${r},${c}`);
      const targetLen = getRandomInt(targetMin, targetMax);
      while (path.length < targetLen) {
        let neigh = neighbors(r, c, rows, cols).filter(n => !visited.has(`${n.r},${n.c}`));
        if (neigh.length === 0) break;
        let nxt = neigh[Math.floor(Math.random() * neigh.length)];
        path.push(nxt);
        visited.add(`${nxt.r},${nxt.c}`);
        r = nxt.r; c = nxt.c;
      }
      if (path.length < targetMin) continue; // Ensure min length

      // Check if start and end are not adjacent (unless path length is 2)
      const start = path[0];
      const end = path[path.length - 1];
      if (path.length > 2) {
          const startNeighs = neighbors(start.r, start.c, rows, cols).map(n => `${n.r},${n.c}`);
          if (startNeighs.includes(`${end.r},${end.c}`)) continue; // Start and End are too close
      }

      // Check connectivity of internal path elements
      let valid = true;
      for (let i = 1; i < path.length - 1; i++) {
        const cell = path[i];
        const prev = path[i-1];
        const next = path[i+1];
        const cellNeighs = neighbors(cell.r, cell.c, rows, cols).map(n => `${n.r},${n.c}`);
        
        const connectedToPrev = cellNeighs.includes(`${prev.r},${prev.c}`);
        const connectedToNext = cellNeighs.includes(`${next.r},${next.c}`);
        
        if (!connectedToPrev || !connectedToNext) { valid = false; break; }
        
        const otherPathNeighbors = path.filter((p, idx) => idx !== i && idx !== i-1 && idx !== i+1 && cellNeighs.includes(`${p.r},${p.c}`));
        if (otherPathNeighbors.length > 0) { valid = false; break; }
      }
      if (!valid) continue;

      return path;
    }
    console.warn("Could not generate a valid path after max attempts.");
    return null;
  }

  function neighbors(r, c, rows, cols) {
    const deltas = [[1,0],[-1,0],[0,1],[0,-1]]; // Up, Down, Left, Right
    let res = [];
    for (const [dr, dc] of deltas) {
      let nr = r + dr, nc = c + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) res.push({ r: nr, c: nc });
    }
    return res;
  }

  // =============================================================================
  // üîí PROTECTED: LPF MAZE ALGORITHM v1.0 - IMPLEMENTED 2026-01-09
  // =============================================================================
  // PROFESSIONAL MAZE GENERATION - LONGEST PATH FIRST (LPF) ALGORITHM
  // =============================================================================
  // This algorithm creates genuinely challenging mazes by:
  // 1. Generating a perfect maze (preserving its structure)
  // 2. Finding the LONGEST possible path (maze diameter)
  // 3. Using that naturally winding path as the solution
  // =============================================================================
  // ‚õî DO NOT OVERWRITE - Contains professional algorithm development
  // Verify: grep "LPF MAZE ALGORITHM" "REFERENCE APPS\picture path.html"
  // =============================================================================

  // LPF Algorithm Version Check - logs on first maze generation
  (function() {
    const LPF_VERSION = '1.0';
    const LPF_DATE = '2026-01-09';
    if (!window._lpfVersionLogged) {
      console.log(`‚úÖ Picture Path: LPF Maze Algorithm v${LPF_VERSION} (${LPF_DATE})`);
      console.log('   Features: generatePerfectMaze, findLongestMazePath, Two-Pass Farthest Point');
      window._lpfVersionLogged = true;
    }
  })();

  function generateClassicMaze(config) {
    const {
      rows, cols, numPaths = 1, copiesMin = 1, copiesMax = 5,
      startImage, endImage, pathImages, distractorImages
    } = config;

    console.log('=== PROFESSIONAL MAZE GENERATION (LPF Algorithm) ===');
    console.log('Config:', { rows, cols, numPaths });

    // STEP 1: Generate a perfect maze (preserved, not overwritten)
    const maze = generatePerfectMaze(rows, cols);
    console.log('Perfect maze generated');

    // STEP 2: Find the LONGEST path - this becomes the solution
    const { startCell, endCell, solutionPath } = findLongestMazePath(maze, rows, cols);

    const pathPercent = Math.round(solutionPath.length * 100 / (rows * cols));
    const turns = countPathTurns(solutionPath);
    console.log(`Solution path: ${solutionPath.length} cells (${pathPercent}% of maze)`);
    console.log(`Turns in solution: ${turns}`);

    // STEP 3: Open border walls for start and end
    maze[startCell.r][startCell.c].left = false;
    maze[endCell.r][endCell.c].right = false;

    // STEP 4: For multi-path mode, add decoy exits
    let endPositions = [endCell];
    let correctIndex = 0;

    if (numPaths > 1) {
      const usedRows = new Set([endCell.r]);
      for (let i = 1; i < numPaths; i++) {
        // Find a row for decoy that's not too close to correct end
        let decoyRow;
        let attempts = 0;
        do {
          decoyRow = Math.floor(Math.random() * (rows - 2)) + 1;
          attempts++;
        } while (usedRows.has(decoyRow) && attempts < 20);

        usedRows.add(decoyRow);
        const decoyEnd = { r: decoyRow, c: cols - 1 };
        maze[decoyEnd.r][decoyEnd.c].right = false;
        endPositions.push(decoyEnd);
        console.log(`Decoy exit ${i}: row ${decoyRow}`);
      }
    }

    // STEP 5: Place collectibles
    const itemPositions = placeCollectiblesLPF(
      rows, cols, startCell, endPositions, pathImages, copiesMin, copiesMax
    );

    return {
      mazeWalls: maze,
      startCell,
      endCell,
      endPositions,
      correctPathIndex: correctIndex,
      items: itemPositions,
      rows,
      cols,
      numPaths,
      solutionPath,
      selectedStartImage: startImage,
      selectedEndImage: endImage,
      isMazeMode: true
    };
  }

  // Generate a perfect maze optimized for long winding corridors
  function generatePerfectMaze(rows, cols) {
    const cells = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => ({
        top: true, right: true, bottom: true, left: true, visited: false
      }))
    );

    const directions = [
      { dr: -1, dc: 0, wall: 'top', opposite: 'bottom' },
      { dr: 0, dc: 1, wall: 'right', opposite: 'left' },
      { dr: 1, dc: 0, wall: 'bottom', opposite: 'top' },
      { dr: 0, dc: -1, wall: 'left', opposite: 'right' }
    ];

    // Start from corner for more interesting structure
    const activeCells = [];
    cells[0][0].visited = true;
    activeCells.push({ r: 0, c: 0 });

    while (activeCells.length > 0) {
      // CRITICAL: Cell selection strategy for maximum path complexity
      // 50% newest (creates long winding corridors like DFS)
      // 30% oldest (creates branches that loop back - KEY for complexity!)
      // 20% random (adds unpredictability)
      let currentIndex;
      const rand = Math.random();
      if (rand < 0.50) {
        currentIndex = activeCells.length - 1; // Newest
      } else if (rand < 0.80) {
        currentIndex = 0; // Oldest - creates longer paths!
      } else {
        currentIndex = Math.floor(Math.random() * activeCells.length);
      }

      const current = activeCells[currentIndex];
      const shuffledDirs = [...directions].sort(() => Math.random() - 0.5);
      const unvisitedNeighbors = [];

      for (const dir of shuffledDirs) {
        const newR = current.r + dir.dr;
        const newC = current.c + dir.dc;
        if (newR >= 0 && newR < rows && newC >= 0 && newC < cols && !cells[newR][newC].visited) {
          unvisitedNeighbors.push({ r: newR, c: newC, wall: dir.wall, opposite: dir.opposite });
        }
      }

      if (unvisitedNeighbors.length > 0) {
        const chosen = unvisitedNeighbors[Math.floor(Math.random() * unvisitedNeighbors.length)];
        cells[current.r][current.c][chosen.wall] = false;
        cells[chosen.r][chosen.c][chosen.opposite] = false;
        cells[chosen.r][chosen.c].visited = true;
        activeCells.push({ r: chosen.r, c: chosen.c });
      } else {
        activeCells.splice(currentIndex, 1);
      }
    }

    return cells;
  }

  // Find the longest possible path in the maze (diameter algorithm)
  function findLongestMazePath(maze, rows, cols) {
    // Two-pass farthest point algorithm - proven to find maze diameter

    // Pass 1: Find the farthest cell from top-left corner
    const farthest1 = findFarthestMazeCell(maze, { r: 0, c: 0 }, rows, cols);
    console.log(`Pass 1: Farthest from (0,0) is (${farthest1.cell.r},${farthest1.cell.c}) at distance ${farthest1.dist}`);

    // Pass 2: Find the farthest cell from THAT point
    const farthest2 = findFarthestMazeCell(maze, farthest1.cell, rows, cols);
    console.log(`Pass 2: Farthest from (${farthest1.cell.r},${farthest1.cell.c}) is (${farthest2.cell.r},${farthest2.cell.c}) at distance ${farthest2.dist}`);

    // The path between these two points is the longest in the maze
    let startCell = farthest1.cell;
    let endCell = farthest2.cell;

    // Ensure start is on left side, end on right side (swap if needed)
    if (startCell.c > endCell.c) {
      [startCell, endCell] = [endCell, startCell];
    }

    // Adjust to edge cells for proper maze entry/exit
    startCell = findNearestLeftEdge(maze, startCell, rows, cols);
    endCell = findNearestRightEdge(maze, endCell, rows, cols);

    // Get the actual solution path
    const solutionPath = findMazePathBFS(maze, startCell, endCell, rows, cols);

    console.log(`Final path: (${startCell.r},${startCell.c}) -> (${endCell.r},${endCell.c}), length: ${solutionPath.length}`);

    return { startCell, endCell, solutionPath };
  }

  // BFS to find the farthest reachable cell from a starting point
  function findFarthestMazeCell(maze, start, rows, cols) {
    const queue = [{ cell: start, dist: 0 }];
    const visited = new Set([`${start.r},${start.c}`]);
    let farthest = { cell: start, dist: 0 };

    const directions = [
      { dr: -1, dc: 0, wall: 'top' },
      { dr: 0, dc: 1, wall: 'right' },
      { dr: 1, dc: 0, wall: 'bottom' },
      { dr: 0, dc: -1, wall: 'left' }
    ];

    while (queue.length > 0) {
      const { cell: current, dist } = queue.shift();
      if (dist > farthest.dist) {
        farthest = { cell: current, dist };
      }

      const mazeCell = maze[current.r][current.c];
      for (const dir of directions) {
        if (!mazeCell[dir.wall]) { // Wall is open
          const nr = current.r + dir.dr;
          const nc = current.c + dir.dc;
          const key = `${nr},${nc}`;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited.has(key)) {
            visited.add(key);
            queue.push({ cell: { r: nr, c: nc }, dist: dist + 1 });
          }
        }
      }
    }
    return farthest;
  }

  // BFS to find the path between two cells
  function findMazePathBFS(maze, start, end, rows, cols) {
    const queue = [[start]];
    const visited = new Set([`${start.r},${start.c}`]);

    const directions = [
      { dr: -1, dc: 0, wall: 'top' },
      { dr: 0, dc: 1, wall: 'right' },
      { dr: 1, dc: 0, wall: 'bottom' },
      { dr: 0, dc: -1, wall: 'left' }
    ];

    while (queue.length > 0) {
      const path = queue.shift();
      const current = path[path.length - 1];

      if (current.r === end.r && current.c === end.c) {
        return path;
      }

      const cell = maze[current.r][current.c];
      for (const dir of directions) {
        if (!cell[dir.wall]) {
          const nr = current.r + dir.dr;
          const nc = current.c + dir.dc;
          const key = `${nr},${nc}`;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && !visited.has(key)) {
            visited.add(key);
            queue.push([...path, { r: nr, c: nc }]);
          }
        }
      }
    }
    return [start, end]; // Fallback
  }

  // Find nearest cell on left edge
  function findNearestLeftEdge(maze, cell, rows, cols) {
    if (cell.c === 0) return cell;
    let best = null, bestDist = Infinity;
    for (let r = 0; r < rows; r++) {
      const path = findMazePathBFS(maze, cell, { r, c: 0 }, rows, cols);
      if (path.length < bestDist) {
        bestDist = path.length;
        best = { r, c: 0 };
      }
    }
    return best || cell;
  }

  // Find nearest cell on right edge
  function findNearestRightEdge(maze, cell, rows, cols) {
    if (cell.c === cols - 1) return cell;
    let best = null, bestDist = Infinity;
    for (let r = 0; r < rows; r++) {
      const path = findMazePathBFS(maze, cell, { r, c: cols - 1 }, rows, cols);
      if (path.length < bestDist) {
        bestDist = path.length;
        best = { r, c: cols - 1 };
      }
    }
    return best || cell;
  }

  // Count direction changes (turns) in a path
  function countPathTurns(path) {
    if (path.length < 3) return 0;
    let turns = 0;
    for (let i = 1; i < path.length - 1; i++) {
      const prev = path[i - 1], curr = path[i], next = path[i + 1];
      const dir1 = { r: curr.r - prev.r, c: curr.c - prev.c };
      const dir2 = { r: next.r - curr.r, c: next.c - curr.c };
      if (dir1.r !== dir2.r || dir1.c !== dir2.c) turns++;
    }
    return turns;
  }

  // Place collectibles evenly across the maze
  function placeCollectiblesLPF(rows, cols, startCell, endPositions, pathImages, copiesMin, copiesMax) {
    if (!pathImages || pathImages.length === 0) return [];

    const itemPositions = [];
    const endCellSet = new Set(endPositions.map(e => `${e.r},${e.c}`));

    // Build available cells list (excluding start and end cells)
    const availableCells = [];
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (!(r === startCell.r && c === startCell.c) && !endCellSet.has(`${r},${c}`)) {
          availableCells.push({ r, c });
        }
      }
    }

    // Shuffle for random distribution
    availableCells.sort(() => Math.random() - 0.5);

    // Place items
    let cellIndex = 0;
    for (const img of pathImages) {
      const copies = Math.floor(Math.random() * (copiesMax - copiesMin + 1)) + copiesMin;
      for (let i = 0; i < copies && cellIndex < availableCells.length; i++) {
        const cell = availableCells[cellIndex++];
        itemPositions.push({ r: cell.r, c: cell.c, image: img, type: 'collectible' });
      }
    }

    console.log(`Placed ${itemPositions.length} collectibles`);
    return itemPositions;
  }

  // =============================================================================
  // END OF LPF ALGORITHM
  // =============================================================================

  // Generate evenly-spaced end positions on the right edge
  function generateEndPositions(rows, cols, numPaths) {
    const positions = [];
    const spacing = Math.floor(rows / (numPaths + 1));

    for (let i = 1; i <= numPaths; i++) {
      const baseRow = spacing * i;
      // Add small random offset for variety (¬±1 row)
      const offset = Math.floor(Math.random() * 3) - 1;
      const row = Math.max(1, Math.min(rows - 2, baseRow + offset));
      positions.push({ r: row, c: cols - 1 });
    }

    console.log(`Generated ${numPaths} end positions:`, positions);
    return positions;
  }

  // Create distinct paths from start toward each end position
  function createMultiPathStructure(maze, startCell, endPositions, rows, cols, numPaths) {
    // Calculate branch zone (25-40% into the maze)
    const branchZoneStart = Math.floor(cols * 0.25);
    const branchZoneEnd = Math.floor(cols * 0.40);
    const branchCol = branchZoneStart + Math.floor(Math.random() * (branchZoneEnd - branchZoneStart));

    console.log(`Creating ${numPaths} paths with branch zone at column ${branchCol}`);

    // Carve main trunk from start to branch point
    const trunk = carveMainTrunk(maze, startCell, branchCol, rows, cols);
    const branchPoint = trunk[trunk.length - 1];
    console.log(`Branch point: (${branchPoint.r}, ${branchPoint.c})`);

    // Create distinct paths from branch point to each end
    const paths = [];
    for (let i = 0; i < numPaths; i++) {
      const targetEnd = endPositions[i];
      const branch = carvePathToEnd(maze, branchPoint, targetEnd, i, numPaths, rows, cols);

      paths.push({
        index: i,
        trunk: [...trunk],
        branch: branch,
        fullPath: [...trunk, ...branch],
        endPosition: targetEnd,
        length: trunk.length + branch.length,
        isCorrect: false
      });

      console.log(`Path ${i}: ${branch.length} cells from branch to (${targetEnd.r}, ${targetEnd.c})`);
    }

    return { trunk, branchPoint, paths };
  }

  // Carve main trunk corridor from start - IMPROVED ALGORITHM
  // Creates winding paths instead of straight lines
  function carveMainTrunk(maze, startCell, targetCol, rows, cols) {
    const trunk = [{ ...startCell }];
    let current = { ...startCell };
    let lastDirection = null;
    let consecutiveSameDir = 0;
    const MAX_CONSECUTIVE = 2; // Force direction change after 2 consecutive same-direction moves

    // Ensure start cell opens into maze
    carvePassageBetween(maze, current, { r: current.r, c: current.c + 1 });

    // Move with balanced bias - much more winding than before
    while (current.c < targetCol && trunk.length < cols * 3) {
      const directions = [];

      // Reduced rightward bias (40% instead of 70%) - creates more vertical movement
      if (current.c + 1 < cols - 2) {
        // Further reduce weight if we've been going right too long
        const rightWeight = (lastDirection === 'right' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 40;
        directions.push({ dr: 0, dc: 1, weight: rightWeight, name: 'right' });
      }
      // Increased vertical movement (30% each instead of 15%) - creates winding paths
      if (current.r > 1) {
        const upWeight = (lastDirection === 'up' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 30;
        directions.push({ dr: -1, dc: 0, weight: upWeight, name: 'up' });
      }
      if (current.r < rows - 2) {
        const downWeight = (lastDirection === 'down' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 30;
        directions.push({ dr: 1, dc: 0, weight: downWeight, name: 'down' });
      }

      const chosen = weightedRandomSelect(directions);
      if (!chosen) break;

      // Track consecutive same-direction moves to force variety
      if (chosen.name === lastDirection) {
        consecutiveSameDir++;
      } else {
        consecutiveSameDir = 1;
        lastDirection = chosen.name;
      }

      const next = { r: current.r + chosen.dr, c: current.c + chosen.dc };
      carvePassageBetween(maze, current, next);
      trunk.push(next);
      current = next;
    }

    return trunk;
  }

  // Carve path from branch point to target end - IMPROVED ALGORITHM
  // Creates winding, complex paths that are harder to trace visually
  function carvePathToEnd(maze, branchPoint, targetEnd, pathIndex, totalPaths, rows, cols) {
    const path = [];
    let current = { ...branchPoint };
    let lastDirection = null;
    let consecutiveSameDir = 0;
    const MAX_CONSECUTIVE = 2; // Force direction changes for winding paths

    // Calculate vertical separation for this path
    const verticalOffset = Math.floor((pathIndex - (totalPaths - 1) / 2) * 4);
    const targetRow = Math.max(1, Math.min(rows - 2, branchPoint.r + verticalOffset));

    // First, move vertically with some horizontal wandering for variety
    while (current.r !== targetRow && path.length < 20) {
      const dir = current.r < targetRow ? 1 : -1;

      // 70% chance to move toward target row, 30% chance to meander horizontally
      if (Math.random() < 0.7 || current.c >= cols - 3) {
        const next = { r: current.r + dir, c: current.c };
        if (next.r >= 0 && next.r < rows) {
          carvePassageBetween(maze, current, next);
          path.push(next);
          current = next;
        }
      } else {
        // Meander right occasionally during vertical movement
        const next = { r: current.r, c: current.c + 1 };
        if (next.c < cols - 1) {
          carvePassageBetween(maze, current, next);
          path.push(next);
          current = next;
        }
      }
    }

    // Progress with heavy meandering - creates winding paths
    while (current.c < cols - 2 && path.length < rows * 4) {
      const directions = [];

      // Greatly reduced rightward bias (35% instead of 60%) - much more winding
      if (current.c + 1 < cols) {
        const rightWeight = (lastDirection === 'right' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 35;
        directions.push({ dr: 0, dc: 1, weight: rightWeight, name: 'right' });
      }
      // Increased vertical movement (32-33% each instead of 20%) - balanced distribution
      if (current.r > 1) {
        const upWeight = (lastDirection === 'up' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 32;
        directions.push({ dr: -1, dc: 0, weight: upWeight, name: 'up' });
      }
      if (current.r < rows - 2) {
        const downWeight = (lastDirection === 'down' && consecutiveSameDir >= MAX_CONSECUTIVE) ? 10 : 33;
        directions.push({ dr: 1, dc: 0, weight: downWeight, name: 'down' });
      }

      const chosen = weightedRandomSelect(directions);
      if (!chosen) break;

      // Track consecutive same-direction moves
      if (chosen.name === lastDirection) {
        consecutiveSameDir++;
      } else {
        consecutiveSameDir = 1;
        lastDirection = chosen.name;
      }

      const next = { r: current.r + chosen.dr, c: current.c + chosen.dc };
      carvePassageBetween(maze, current, next);
      path.push(next);
      current = next;
    }

    // Connect to target end position with some final wandering
    let finalMoves = 0;
    while (current.r !== targetEnd.r || current.c !== targetEnd.c) {
      let next;

      // Add final wandering - 20% chance to take a detour if not at edge
      if (finalMoves < 5 && Math.random() < 0.2 && current.c < targetEnd.c - 1) {
        // Take a vertical detour
        if (current.r > 1 && Math.random() < 0.5) {
          next = { r: current.r - 1, c: current.c };
        } else if (current.r < rows - 2) {
          next = { r: current.r + 1, c: current.c };
        } else {
          next = { r: current.r, c: current.c + 1 };
        }
      } else if (current.c < targetEnd.c) {
        next = { r: current.r, c: current.c + 1 };
      } else if (current.r < targetEnd.r) {
        next = { r: current.r + 1, c: current.c };
      } else if (current.r > targetEnd.r) {
        next = { r: current.r - 1, c: current.c };
      } else {
        break;
      }

      carvePassageBetween(maze, current, next);
      path.push(next);
      current = next;
      finalMoves++;

      if (path.length > rows * 5) break;
    }

    return path;
  }

  // Helper to carve passage between two adjacent cells
  function carvePassageBetween(maze, from, to) {
    const dr = to.r - from.r;
    const dc = to.c - from.c;

    // Validate cells are adjacent
    if (Math.abs(dr) + Math.abs(dc) !== 1) return;

    // Validate cells are in bounds
    if (from.r < 0 || from.r >= maze.length || from.c < 0 || from.c >= maze[0].length) return;
    if (to.r < 0 || to.r >= maze.length || to.c < 0 || to.c >= maze[0].length) return;

    if (dr === -1) {  // Moving up
      maze[from.r][from.c].top = false;
      maze[to.r][to.c].bottom = false;
    } else if (dr === 1) {  // Moving down
      maze[from.r][from.c].bottom = false;
      maze[to.r][to.c].top = false;
    } else if (dc === -1) {  // Moving left
      maze[from.r][from.c].left = false;
      maze[to.r][to.c].right = false;
    } else if (dc === 1) {  // Moving right
      maze[from.r][from.c].right = false;
      maze[to.r][to.c].left = false;
    }
  }

  // Weighted random selection
  function weightedRandomSelect(options) {
    if (!options || options.length === 0) return null;

    const totalWeight = options.reduce((sum, opt) => sum + opt.weight, 0);
    let random = Math.random() * totalWeight;

    for (const option of options) {
      random -= option.weight;
      if (random <= 0) return option;
    }
    return options[0];
  }

  // Select the correct path based on complexity metrics
  function selectCorrectPath(pathStructure, endPositions) {
    const { paths } = pathStructure;

    // Score paths by: length, turns, coverage
    const scores = paths.map((pathData, idx) => {
      const fullPath = pathData.fullPath;
      const length = fullPath.length;

      // Count turns
      let turns = 0;
      for (let i = 1; i < fullPath.length - 1; i++) {
        const prev = fullPath[i - 1];
        const curr = fullPath[i];
        const next = fullPath[i + 1];
        const dir1 = { r: curr.r - prev.r, c: curr.c - prev.c };
        const dir2 = { r: next.r - curr.r, c: next.c - curr.c };
        if (dir1.r !== dir2.r || dir1.c !== dir2.c) turns++;
      }

      // Score formula (higher = better)
      const score = length * 2 + turns * 8;

      console.log(`Path ${idx}: length=${length}, turns=${turns}, score=${score}`);
      return { index: idx, score, endCell: endPositions[idx] };
    });

    // Highest score = correct path
    scores.sort((a, b) => b.score - a.score);
    const correctIndex = scores[0].index;
    paths[correctIndex].isCorrect = true;

    return { correctIndex, correctEndCell: scores[0].endCell };
  }

  // Block dead-end paths convincingly
  function blockDeadEndPaths(maze, pathStructure, correctIndex, rows, cols) {
    const { paths } = pathStructure;
    const correctPath = paths[correctIndex];
    const correctPathSet = new Set(correctPath.fullPath.map(c => `${c.r},${c.c}`));

    console.log('=== BLOCKING DEAD-END PATHS ===');

    paths.forEach((pathData, idx) => {
      if (idx === correctIndex) {
        console.log(`Path ${idx}: CORRECT - no blocking`);
        return;
      }

      console.log(`Path ${idx}: Creating dead-end...`);

      // Find blocking point (60-85% along the branch)
      const branchLength = pathData.branch.length;
      if (branchLength < 3) {
        console.warn(`Path ${idx}: Branch too short to block`);
        return;
      }

      const blockPercent = 0.6 + Math.random() * 0.25;
      const blockDepth = Math.max(2, Math.min(Math.floor(branchLength * blockPercent), branchLength - 2));
      let blockCell = pathData.branch[blockDepth];

      // Ensure blocking cell is NOT on correct path
      let attempts = 0;
      while (correctPathSet.has(`${blockCell.r},${blockCell.c}`) && attempts < 10) {
        const newDepth = Math.max(1, blockDepth - attempts - 1);
        blockCell = pathData.branch[newDepth];
        attempts++;
      }

      if (correctPathSet.has(`${blockCell.r},${blockCell.c}`)) {
        console.warn(`Path ${idx}: Cannot find safe blocking point`);
        return;
      }

      // Block at this cell - close all walls
      maze[blockCell.r][blockCell.c].top = true;
      maze[blockCell.r][blockCell.c].right = true;
      maze[blockCell.r][blockCell.c].bottom = true;
      maze[blockCell.r][blockCell.c].left = true;

      // Re-open wall back toward start
      const blockIdx = pathData.branch.indexOf(blockCell);
      if (blockIdx > 0) {
        const prevCell = pathData.branch[blockIdx - 1];
        carvePassageBetween(maze, blockCell, prevCell);
      }

      // Add small alcove for visual interest
      addDeadEndAlcove(maze, blockCell, rows, cols);

      console.log(`  Blocked at (${blockCell.r}, ${blockCell.c})`);
    });
  }

  // Add small alcove at dead-end for visual interest
  function addDeadEndAlcove(maze, blockCell, rows, cols) {
    const perpendicular = [];

    if (blockCell.r > 1) perpendicular.push({ dr: -1, dc: 0 });
    if (blockCell.r < rows - 2) perpendicular.push({ dr: 1, dc: 0 });
    if (blockCell.c > 1) perpendicular.push({ dr: 0, dc: -1 });
    if (blockCell.c < cols - 2) perpendicular.push({ dr: 0, dc: 1 });

    if (perpendicular.length === 0) return;

    const alcoveDir = perpendicular[Math.floor(Math.random() * perpendicular.length)];
    const alcoveCell = {
      r: blockCell.r + alcoveDir.dr,
      c: blockCell.c + alcoveDir.dc
    };

    if (alcoveCell.r >= 0 && alcoveCell.r < rows && alcoveCell.c >= 0 && alcoveCell.c < cols) {
      carvePassageBetween(maze, blockCell, alcoveCell);
      // Close far side of alcove
      maze[alcoveCell.r][alcoveCell.c].top = true;
      maze[alcoveCell.r][alcoveCell.c].right = true;
      maze[alcoveCell.r][alcoveCell.c].bottom = true;
      maze[alcoveCell.r][alcoveCell.c].left = true;
      // Re-open toward block cell
      carvePassageBetween(maze, alcoveCell, blockCell);
    }
  }

  // Emergency path carving if no solution exists
  function carveEmergencyPath(maze, startCell, endCell, rows, cols) {
    console.log('Carving emergency path...');
    let current = { ...startCell };

    while (current.r !== endCell.r || current.c !== endCell.c) {
      let next;
      if (current.c < endCell.c) {
        next = { r: current.r, c: current.c + 1 };
      } else if (current.r < endCell.r) {
        next = { r: current.r + 1, c: current.c };
      } else if (current.r > endCell.r) {
        next = { r: current.r - 1, c: current.c };
      } else {
        break;
      }

      carvePassageBetween(maze, current, next);
      current = next;
    }
    console.log('Emergency path carved successfully');
  }

  // Add extra blocking if dead-end is still reachable
  function addExtraBlocking(maze, deadPath, correctPath, rows, cols) {
    const correctPathSet = new Set(correctPath.map(c => `${c.r},${c.c}`));

    // Find a cell on dead path that's not on correct path
    for (let i = Math.floor(deadPath.length * 0.5); i < deadPath.length - 1; i++) {
      const cell = deadPath[i];
      if (!correctPathSet.has(`${cell.r},${cell.c}`)) {
        // Block this cell
        maze[cell.r][cell.c].top = true;
        maze[cell.r][cell.c].right = true;
        maze[cell.r][cell.c].bottom = true;
        maze[cell.r][cell.c].left = true;

        // Re-open toward previous cell
        if (i > 0) {
          carvePassageBetween(maze, cell, deadPath[i - 1]);
        }

        console.log(`  Extra blocking at (${cell.r}, ${cell.c})`);
        return;
      }
    }
  }

  // Generate maze walls using recursive backtracking
  function generateMazeWalls(rows, cols) {
    // PROFESSIONAL GROWING TREE ALGORITHM
    // Creates more interesting, winding mazes than pure recursive backtracking
    // Optimized for 12x12+ grids with educational maze requirements

    // Each cell has walls: top, right, bottom, left
    const cells = Array.from({ length: rows }, () =>
      Array.from({ length: cols }, () => ({
        top: true,
        right: true,
        bottom: true,
        left: true,
        visited: false
      }))
    );

    const directions = [
      { dr: -1, dc: 0, wall: 'top', opposite: 'bottom' },    // Up
      { dr: 0, dc: 1, wall: 'right', opposite: 'left' },     // Right
      { dr: 1, dc: 0, wall: 'bottom', opposite: 'top' },     // Down
      { dr: 0, dc: -1, wall: 'left', opposite: 'right' }     // Left
    ];

    // Start from random position
    const startR = Math.floor(Math.random() * rows);
    const startC = Math.floor(Math.random() * cols);

    // Growing Tree: maintain active cell list
    const activeCells = [];
    cells[startR][startC].visited = true;
    activeCells.push({ r: startR, c: startC });

    console.log(`GROWING TREE ALGORITHM: Starting from (${startR}, ${startC})`);

    while (activeCells.length > 0) {
      // CRITICAL: Cell selection strategy determines maze character
      // 70% newest (creates winding, river-like paths)
      // 20% random (adds variety and branching)
      // 10% oldest (creates loops and complexity)
      let currentIndex;
      const rand = Math.random();

      if (rand < 0.70) {
        // Newest - creates deep, winding paths (like a river)
        currentIndex = activeCells.length - 1;
      } else if (rand < 0.90) {
        // Random - adds unpredictability
        currentIndex = Math.floor(Math.random() * activeCells.length);
      } else {
        // Oldest - creates shorter branches
        currentIndex = 0;
      }

      const current = activeCells[currentIndex];

      // Find all unvisited neighbors
      const unvisitedNeighbors = [];

      for (const dir of directions) {
        const newR = current.r + dir.dr;
        const newC = current.c + dir.dc;

        if (newR >= 0 && newR < rows && newC >= 0 && newC < cols &&
            !cells[newR][newC].visited) {
          unvisitedNeighbors.push({
            r: newR,
            c: newC,
            wall: dir.wall,
            opposite: dir.opposite
          });
        }
      }

      if (unvisitedNeighbors.length > 0) {
        // Choose random unvisited neighbor
        const chosen = unvisitedNeighbors[
          Math.floor(Math.random() * unvisitedNeighbors.length)
        ];

        // Carve passage: remove walls between current and chosen
        cells[current.r][current.c][chosen.wall] = false;
        cells[chosen.r][chosen.c][chosen.opposite] = false;

        // Mark chosen as visited and add to active list
        cells[chosen.r][chosen.c].visited = true;
        activeCells.push({ r: chosen.r, c: chosen.c });
      } else {
        // Dead end - remove this cell from active list
        activeCells.splice(currentIndex, 1);
      }
    }

    // Verify complete coverage
    let visitedCount = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (cells[r][c].visited) visitedCount++;
      }
    }

    console.log(`‚úì Maze generation complete: ${visitedCount}/${rows * cols} cells (${(visitedCount*100/(rows*cols)).toFixed(1)}%)`);

    if (visitedCount < rows * cols) {
      console.warn(`‚ö†Ô∏è Incomplete coverage: ${visitedCount}/${rows * cols} cells visited`);
    }

    return cells;
  }

  // Carve a path between two cells by opening walls along the route
  // Uses A* algorithm to find shortest path and opens walls along it
  function carvePathBetweenCells(maze, startCell, endCell, rows, cols, endBorderSide) {
    // Use corridorCell if available (for outside marker positions)
    const actualStart = startCell.corridorCell || startCell;
    const actualEnd = endCell;

    console.log(`Carving path from (${actualStart.r}, ${actualStart.c}) to (${actualEnd.r}, ${actualEnd.c})`);

    // A* algorithm to find shortest path
    const openSet = [actualStart];
    const cameFrom = new Map();
    const gScore = Array.from({ length: rows }, () => Array(cols).fill(Infinity));
    const fScore = Array.from({ length: rows }, () => Array(cols).fill(Infinity));

    gScore[actualStart.r][actualStart.c] = 0;
    fScore[actualStart.r][actualStart.c] = heuristic(actualStart, actualEnd);

    function heuristic(a, b) {
      return Math.abs(a.r - b.r) + Math.abs(a.c - b.c);
    }

    while (openSet.length > 0) {
      // Find cell with lowest fScore
      let current = openSet[0];
      let currentIdx = 0;
      for (let i = 1; i < openSet.length; i++) {
        if (fScore[openSet[i].r][openSet[i].c] < fScore[current.r][current.c]) {
          current = openSet[i];
          currentIdx = i;
        }
      }

      // Found the target
      if (current.r === actualEnd.r && current.c === actualEnd.c) {
        // Reconstruct path
        const path = [current];
        let curr = current;
        while (cameFrom.has(`${curr.r},${curr.c}`)) {
          curr = cameFrom.get(`${curr.r},${curr.c}`);
          path.unshift(curr);
        }

        // Carve path by opening walls
        for (let i = 0; i < path.length - 1; i++) {
          const from = path[i];
          const to = path[i + 1];

          // Determine direction and open walls
          if (to.r < from.r) { // Moving up
            maze[from.r][from.c].top = false;
            maze[to.r][to.c].bottom = false;
          } else if (to.r > from.r) { // Moving down
            maze[from.r][from.c].bottom = false;
            maze[to.r][to.c].top = false;
          } else if (to.c < from.c) { // Moving left
            maze[from.r][from.c].left = false;
            maze[to.r][to.c].right = false;
          } else if (to.c > from.c) { // Moving right
            maze[from.r][from.c].right = false;
            maze[to.r][to.c].left = false;
          }
        }

        // Connect end to border if needed
        if (endBorderSide === 'top' && actualEnd.r === 0) {
          maze[actualEnd.r][actualEnd.c].top = false;
        } else if (endBorderSide === 'bottom' && actualEnd.r === rows - 1) {
          maze[actualEnd.r][actualEnd.c].bottom = false;
        } else if (endBorderSide === 'left' && actualEnd.c === 0) {
          maze[actualEnd.r][actualEnd.c].left = false;
        } else if (endBorderSide === 'right' && actualEnd.c === cols - 1) {
          maze[actualEnd.r][actualEnd.c].right = false;
        }

        console.log(`‚úì Carved path of ${path.length} cells`);
        return path;
      }

      // Remove current from openSet
      openSet.splice(currentIdx, 1);

      // Check all neighbors
      const directions = [
        { dr: -1, dc: 0, wall: 'top' },
        { dr: 0, dc: 1, wall: 'right' },
        { dr: 1, dc: 0, wall: 'bottom' },
        { dr: 0, dc: -1, wall: 'left' }
      ];

      for (const dir of directions) {
        const nr = current.r + dir.dr;
        const nc = current.c + dir.dc;

        if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
          const neighbor = { r: nr, c: nc };
          const tentativeGScore = gScore[current.r][current.c] + 1;

          if (tentativeGScore < gScore[nr][nc]) {
            cameFrom.set(`${nr},${nc}`, current);
            gScore[nr][nc] = tentativeGScore;
            fScore[nr][nc] = gScore[nr][nc] + heuristic(neighbor, actualEnd);

            if (!openSet.some(cell => cell.r === nr && cell.c === nc)) {
              openSet.push(neighbor);
            }
          }
        }
      }
    }

    console.error('‚ö†Ô∏è Could not find path to carve!');
    return [];
  }

  function generateChooseRightPath(config) {
    // config: { rows, cols, wrongPathBehavior, startImage, endImage, pathImages, distractorImages, obstaclesImages }
    // This generates a WALL-BASED MAZE with direction-aware START and END positions

    const { rows, cols, numPaths = 3, wrongPathBehavior, startImage, endImage, pathImages, distractorImages, obstaclesImages } = config;

    // Get maze direction from UI
    const mazeDirection = document.getElementById('mazeDirection').value;

    console.log('=== CHOOSE THE RIGHT PATH MAZE GENERATION ===');
    console.log('Config:', { rows, cols, numPaths, wrongPathBehavior, mazeDirection });

    // Generate wall-based maze using recursive backtracking
    const maze = generateMazeWalls(rows, cols);

    // Helper to generate random positions with ENFORCED minimum spacing
    function generateRandomPositions(count, maxRange) {
      // Ensure minimum gap of at least 2 cells between END images (prevents adjacent corridors)
      const minGap = Math.max(2, Math.floor(maxRange * 0.15));
      const maxAttempts = 50;

      for (let attempt = 0; attempt < maxAttempts; attempt++) {
        const positions = [];
        let valid = true;

        // Generate positions one by one, ensuring each maintains minimum gap
        for (let i = 0; i < count; i++) {
          let attempts = 0;
          let pos;

          do {
            // Pick random position in valid range
            pos = Math.floor(Math.random() * (maxRange - 2)) + 1;
            attempts++;

            // Check if this position is far enough from all existing positions
            const isFarEnough = positions.every(existingPos =>
              Math.abs(pos - existingPos) > minGap
            );

            if (isFarEnough) {
              positions.push(pos);
              break;
            }

            if (attempts > 100) {
              valid = false;
              break;
            }
          } while (true);

          if (!valid) break;
        }

        // If we successfully generated all positions with proper spacing, return them
        if (valid && positions.length === count) {
          positions.sort((a, b) => a - b); // Sort for consistent ordering
          console.log(`Generated ${count} END positions with ${minGap}+ cell spacing: ${positions.join(', ')}`);
          return positions;
        }
      }

      // Fallback: If we couldn't generate with random positions, use evenly spaced positions
      console.warn(`‚ö†Ô∏è Using evenly spaced END positions (couldn't find random positions with enough spacing)`);
      const positions = [];
      const spacing = Math.floor(maxRange / (count + 1));
      for (let i = 0; i < count; i++) {
        positions.push((i + 1) * spacing);
      }
      return positions;
    }

    // Configure START and END positions based on direction
    let startCell, endCells, startBorderSide, endBorderSide, startOutsideMarker, endOutsideMarker;

    if (mazeDirection === 'bottom-top') {
      // START at bottom (1 corridor), ENDs at top (numPaths corridors)
      const startCol = Math.floor(Math.random() * (cols - 2)) + 1;
      const endColumns = generateRandomPositions(numPaths, cols);

      startCell = { r: rows - 1, c: startCol };
      endCells = endColumns.map((c, idx) => ({ r: 0, c: c, label: `Position ${idx + 1}` }));
      startBorderSide = 'bottom';
      endBorderSide = 'top';
      startOutsideMarker = { r: rows, c: startCol };  // Below grid
      endOutsideMarker = (c) => ({ r: -1, c: c });    // Above grid

    } else if (mazeDirection === 'top-bottom') {
      // START at top (1 corridor), ENDs at bottom (numPaths corridors)
      const startCol = Math.floor(Math.random() * (cols - 2)) + 1;
      const endColumns = generateRandomPositions(numPaths, cols);

      startCell = { r: 0, c: startCol };
      endCells = endColumns.map((c, idx) => ({ r: rows - 1, c: c, label: `Position ${idx + 1}` }));
      startBorderSide = 'top';
      endBorderSide = 'bottom';
      startOutsideMarker = { r: -1, c: startCol };    // Above grid
      endOutsideMarker = (c) => ({ r: rows, c: c });  // Below grid

    } else if (mazeDirection === 'left-right') {
      // START at left (1 corridor), ENDs at right (numPaths corridors)
      const startRow = Math.floor(Math.random() * (rows - 2)) + 1;
      const endRows = generateRandomPositions(numPaths, rows);

      startCell = { r: startRow, c: 0 };
      endCells = endRows.map((r, idx) => ({ r: r, c: cols - 1, label: `Position ${idx + 1}` }));
      startBorderSide = 'left';
      endBorderSide = 'right';
      startOutsideMarker = { r: startRow, c: -1 };    // Left of grid
      endOutsideMarker = (r) => ({ r: r, c: cols });  // Right of grid

    } else { // 'right-left'
      // START at right (1 corridor), ENDs at left (numPaths corridors)
      const startRow = Math.floor(Math.random() * (rows - 2)) + 1;
      const endRows = generateRandomPositions(numPaths, rows);

      startCell = { r: startRow, c: cols - 1 };
      endCells = endRows.map((r, idx) => ({ r: r, c: 0, label: `Position ${idx + 1}` }));
      startBorderSide = 'right';
      endBorderSide = 'left';
      startOutsideMarker = { r: startRow, c: cols };  // Right of grid
      endOutsideMarker = (r) => ({ r: r, c: -1 });    // Left of grid
    }

    // Helper functions for path analysis
    function countTurns(path) {
      if (!path || path.length < 3) return 0;

      let turns = 0;
      for (let i = 1; i < path.length - 1; i++) {
        const prev = path[i - 1];
        const curr = path[i];
        const next = path[i + 1];

        const dir1 = { r: curr.r - prev.r, c: curr.c - prev.c };
        const dir2 = { r: next.r - curr.r, c: next.c - curr.c };

        // Direction changed = turn
        if (dir1.r !== dir2.r || dir1.c !== dir2.c) {
          turns++;
        }
      }

      return turns;
    }

    function calculateStraightness(path) {
      if (!path || path.length < 2) return 1;

      const start = path[0];
      const end = path[path.length - 1];

      // Manhattan distance
      const straightDistance = Math.abs(end.r - start.r) + Math.abs(end.c - start.c);
      const actualDistance = path.length - 1;

      // Closer to 1 = more straight, closer to 0 = more winding
      return straightDistance / actualDistance;
    }

    function createEntryCorridor(maze, cell, borderSide, depth, rows, cols) {
      // Create a deep, clear corridor that goes depth cells into the maze
      // CRITICAL: Also clear side walls to ensure corridor is visually clear
      let current = { ...cell };
      const corridorCells = [{ ...cell }];

      for (let i = 0; i < depth; i++) {
        let next;

        if (borderSide === 'top') {
          if (current.r + 1 >= rows) break;
          next = { r: current.r + 1, c: current.c };
          maze[current.r][current.c].bottom = false;
          maze[next.r][next.c].top = false;
        } else if (borderSide === 'bottom') {
          if (current.r - 1 < 0) break;
          next = { r: current.r - 1, c: current.c };
          maze[current.r][current.c].top = false;
          maze[next.r][next.c].bottom = false;
        } else if (borderSide === 'left') {
          if (current.c + 1 >= cols) break;
          next = { r: current.r, c: current.c + 1 };
          maze[current.r][current.c].right = false;
          maze[next.r][next.c].left = false;
        } else { // 'right'
          if (current.c - 1 < 0) break;
          next = { r: current.r, c: current.c - 1 };
          maze[current.r][current.c].left = false;
          maze[next.r][next.c].right = false;
        }

        current = next;
        corridorCells.push({ ...current });
      }

      // DON'T clear sidewalls - keep corridors NARROW (1 cell wide)
      // This keeps more walls near the END images, making all paths look equally challenging
      // and prevents giving away which path is correct

      return current; // Return the deepest cell reached
    }

    function blockAtDepth(maze, cell, borderSide, depth, rows, cols) {
      // Move depth cells into maze, then block that cell from all sides except back to border
      let current = { ...cell };

      for (let i = 0; i < depth; i++) {
        if (borderSide === 'top') {
          if (current.r + 1 >= rows) break;
          current = { r: current.r + 1, c: current.c };
        } else if (borderSide === 'bottom') {
          if (current.r - 1 < 0) break;
          current = { r: current.r - 1, c: current.c };
        } else if (borderSide === 'left') {
          if (current.c + 1 >= cols) break;
          current = { r: current.r, c: current.c + 1 };
        } else { // 'right'
          if (current.c - 1 < 0) break;
          current = { r: current.r, c: current.c - 1 };
        }
      }

      // Block all sides of this deep cell
      maze[current.r][current.c].top = true;
      maze[current.r][current.c].right = true;
      maze[current.r][current.c].bottom = true;
      maze[current.r][current.c].left = true;

      // Re-open ONLY the path back toward the border (to create visible dead-end corridor)
      if (borderSide === 'top') {
        maze[current.r][current.c].top = false;
      } else if (borderSide === 'bottom') {
        maze[current.r][current.c].bottom = false;
      } else if (borderSide === 'left') {
        maze[current.r][current.c].left = false;
      } else {
        maze[current.r][current.c].right = false;
      }
    }

    console.log('=== üéì PROFESSIONAL MAZE GENERATION ALGORITHM (Enhanced) ===');
    console.log(`Direction: ${mazeDirection}, Grid: ${rows}√ó${cols}`);

    // STEP 1: Create DEEP, INVITING entry corridors for ALL 3 ENDs
    // This makes all paths look equally accessible from the border
    console.log('=== STEP 1: CREATE DEEP ENTRY CORRIDORS ===');

    // Open START border and create shallow corridor
    maze[startCell.r][startCell.c][startBorderSide] = false;
    const startCorridorDepth = 2; // Shallow for START
    createEntryCorridor(maze, startCell, startBorderSide, startCorridorDepth, rows, cols);
    console.log(`START corridor: ${startCorridorDepth + 1} cells deep`);

    // Create deep, attractive corridors for ALL 3 ENDs (5-7 cells each)
    const endCorridorDepths = [];
    endCells.forEach((cell, idx) => {
      maze[cell.r][cell.c][endBorderSide] = false;
      const depth = 5 + Math.floor(Math.random() * 3); // 5-7 cells
      createEntryCorridor(maze, cell, endBorderSide, depth, rows, cols);
      endCorridorDepths.push(depth);
      console.log(`END ${idx} corridor: ${depth + 1} cells deep with widened entrance`);
    });

    console.log('‚úì All entry corridors created - all paths look equally promising from border');

    // CRITICAL: Ensure adjacent END corridors are isolated from each other
    console.log('=== CORRIDOR ISOLATION CHECK ===');
    for (let i = 0; i < endCells.length; i++) {
      for (let j = i + 1; j < endCells.length; j++) {
        const cell1 = endCells[i];
        const cell2 = endCells[j];

        // Check if END cells are adjacent (horizontally or vertically)
        const isAdjacent = (Math.abs(cell1.r - cell2.r) === 1 && cell1.c === cell2.c) ||
                          (Math.abs(cell1.c - cell2.c) === 1 && cell1.r === cell2.r);

        if (isAdjacent) {
          console.warn(`‚ö†Ô∏è END ${i} and END ${j} are adjacent - adding isolation wall`);

          // Add wall between adjacent corridor cells
          if (cell1.r === cell2.r) {
            // Horizontally adjacent - close the left/right walls
            if (cell1.c < cell2.c) {
              maze[cell1.r][cell1.c].right = true;
              maze[cell2.r][cell2.c].left = true;
            } else {
              maze[cell1.r][cell1.c].left = true;
              maze[cell2.r][cell2.c].right = true;
            }
          } else {
            // Vertically adjacent - close the top/bottom walls
            if (cell1.r < cell2.r) {
              maze[cell1.r][cell1.c].bottom = true;
              maze[cell2.r][cell2.c].top = true;
            } else {
              maze[cell1.r][cell1.c].top = true;
              maze[cell2.r][cell2.c].bottom = true;
            }
          }
        }
      }
    }
    console.log('‚úì Corridor isolation verified');

    // STEP 2: Find NATURAL paths from START to each END
    console.log('=== STEP 2: ANALYZE NATURAL PATHS ===');
    const pathsToEnds = endCells.map(endCell =>
      findMazeSolution(maze, startCell, endCell, rows, cols)
    );

    const pathMetrics = pathsToEnds.map((path, idx) => {
      if (!path || path.length === 0) {
        console.log(`END ${idx}: NO PATH`);
        return { index: idx, length: 0, turns: 0, straightness: 1, score: -1000 };
      }

      // ENHANCED PATH ANALYSIS for 12x12+ grids
      const turns = countTurns(path);
      const straightness = calculateStraightness(path);

      // New metrics for better educational value
      const directionChanges = countDirectionChanges(path);
      const zigzagScore = calculateZigzagScore(path);
      const coverage = calculateCoverageScore(path, rows, cols);

      // PROFESSIONAL SCORING ALGORITHM
      // Optimized for educational mazes in 12x12+ grids
      const lengthScore = path.length * 3;               // Longer is more challenging (weight: 3)
      const turnScore = turns * 12;                      // More turns = more interesting (weight: 12)
      const straightnessPenalty = straightness * -40;    // Penalize straight paths heavily (weight: -40)
      const directionScore = directionChanges * 8;       // Variety in directions (weight: 8)
      const zigzagBonus = zigzagScore * 6;              // Reward winding paths (weight: 6)
      const coverageBonus = coverage * 10;               // Reward paths that explore more area (weight: 10)

      const score = lengthScore + turnScore + straightnessPenalty +
                   directionScore + zigzagBonus + coverageBonus;

      console.log(`END ${idx}: len=${path.length}, turns=${turns}, straight=${straightness.toFixed(2)}, dirs=${directionChanges}, zigzag=${zigzagScore.toFixed(1)}, coverage=${coverage.toFixed(1)}, SCORE=${score.toFixed(1)}`);

      return { index: idx, length: path.length, turns, straightness, directionChanges, zigzagScore, coverage, score, path };
    });

    // Helper: Count unique direction changes
    function countDirectionChanges(path) {
      if (!path || path.length < 2) return 0;
      const directions = new Set();
      for (let i = 1; i < path.length; i++) {
        const dr = path[i].r - path[i-1].r;
        const dc = path[i].c - path[i-1].c;
        directions.add(`${dr},${dc}`);
      }
      return directions.size; // Should be 2-4 for a good maze path
    }

    // Helper: Measure how much the path zigzags
    function calculateZigzagScore(path) {
      if (!path || path.length < 4) return 0;
      let zigzagCount = 0;
      for (let i = 2; i < path.length; i++) {
        const dir1r = path[i-1].r - path[i-2].r;
        const dir1c = path[i-1].c - path[i-2].c;
        const dir2r = path[i].r - path[i-1].r;
        const dir2c = path[i].c - path[i-1].c;
        // Opposite direction = zigzag
        if (dir1r === -dir2r && dir1c === -dir2c) {
          zigzagCount++;
        }
      }
      return zigzagCount;
    }

    // Helper: Calculate how much area the path covers
    function calculateCoverageScore(path, rows, cols) {
      if (!path || path.length === 0) return 0;
      // Measure the bounding box area covered by the path
      let minR = rows, maxR = 0, minC = cols, maxC = 0;
      for (const cell of path) {
        minR = Math.min(minR, cell.r);
        maxR = Math.max(maxR, cell.r);
        minC = Math.min(minC, cell.c);
        maxC = Math.max(maxC, cell.c);
      }
      const coverageArea = (maxR - minR + 1) * (maxC - minC + 1);
      const totalArea = rows * cols;
      return (coverageArea / totalArea); // 0-1 score
    }

    // STEP 3: Select the most complex path as CORRECT
    console.log('=== STEP 3: SELECT BEST PATH ===');
    let correctPathIndex = 0;
    let bestScore = -Infinity;

    pathMetrics.forEach(metrics => {
      if (metrics.score > bestScore) {
        bestScore = metrics.score;
        correctPathIndex = metrics.index;
      }
    });

    console.log(`‚úì CORRECT PATH: END ${correctPathIndex} (score: ${bestScore.toFixed(1)})`);
    const correctPath = pathsToEnds[correctPathIndex];

    // CRITICAL: Create a Set of correct path cells to prevent blocking them
    const correctPathSet = new Set(correctPath.map(c => `${c.r},${c.c}`));
    console.log(`Protected cells on correct path: ${correctPathSet.size} cells`);

    // STEP 4: ITERATIVELY block ALL paths to wrong ENDs (ensures EXACTLY ONE solution!)
    // This guarantees educational integrity - only ONE path leads to the correct END
    console.log('=== STEP 4: ITERATIVE BLOCKING - ENSURE EXACTLY ONE SOLUTION ===');

    // Calculate maze center coordinates
    const centerR = Math.floor(rows / 2);
    const centerC = Math.floor(cols / 2);
    console.log(`Maze center: (${centerR}, ${centerC})`);

    const obstacles = [];

    endCells.forEach((endCell, idx) => {
      if (idx !== correctPathIndex) {
        console.log(`\nBlocking wrong END ${idx}...`);

        // ITERATIVE BLOCKING: Keep finding and blocking paths until NONE exist
        let iteration = 0;
        const maxIterations = 10; // Safety limit
        let pathFound = true;

        while (pathFound && iteration < maxIterations) {
          iteration++;

          // Find if a path still exists from START to this wrong END
          const pathToWrong = findMazeSolution(maze, startCell, endCell, rows, cols);

          if (!pathToWrong || pathToWrong.length === 0) {
            // No path found - this END is now completely unreachable!
            pathFound = false;
            console.log(`  ‚úì END ${idx}: Completely blocked after ${iteration - 1} iteration(s) - UNREACHABLE`);
            break;
          }

          // Path still exists - block it using center-based approach
          console.log(`  ‚Üí Iteration ${iteration}: Found path (${pathToWrong.length} cells) - blocking...`);

          // Calculate center-based blocking depth for THIS path
          const distToCenter = Math.abs(endCell.r - centerR) + Math.abs(endCell.c - centerC);
          const percentToCenter = 0.70 + Math.random() * 0.10; // 70-80%
          let blockDepth = Math.floor(distToCenter * percentToCenter);

          // Apply safety checks
          blockDepth = Math.max(5, blockDepth); // Min 5 cells
          const entryDepth = endCorridorDepths[idx];
          blockDepth = Math.max(blockDepth, entryDepth + 2); // Beyond entry corridor
          blockDepth = Math.min(blockDepth, Math.floor(distToCenter * 0.95)); // Cap at 95%
          blockDepth = Math.min(blockDepth, pathToWrong.length - 1); // Don't exceed path length

          // CRITICAL FIX: Use the ACTUAL path returned by findMazeSolution()
          // The path zigzags through the maze, we must block along the real route!
          let blockIndex = Math.min(blockDepth, pathToWrong.length - 1);
          let cellToBlock = pathToWrong[blockIndex];

          // CRITICAL: Don't block if this cell is on the CORRECT solution path!
          let cellKey = `${cellToBlock.r},${cellToBlock.c}`;
          if (correctPathSet.has(cellKey)) {
            console.log(`    ‚ö†Ô∏è Skipping block at (${cellToBlock.r}, ${cellToBlock.c}) - cell is on CORRECT path!`);
            console.log(`    ‚Üí Trying to find alternative depth that doesn't share cells...`);

            // Try blocking at a different depth to find a cell NOT on the correct path
            let foundAlternative = false;
            for (let altDepth = blockDepth - 2; altDepth >= Math.max(3, entryDepth); altDepth--) {
              const altIndex = Math.min(altDepth, pathToWrong.length - 1);
              const altCell = pathToWrong[altIndex];
              const altKey = `${altCell.r},${altCell.c}`;

              if (!correctPathSet.has(altKey)) {
                console.log(`    ‚úì Found alternative at depth ${altDepth}: (${altCell.r}, ${altCell.c})`);
                blockIndex = altIndex; // Update to use alternative index
                cellToBlock = altCell;
                cellKey = altKey;
                foundAlternative = true;
                break;
              }
            }

            if (!foundAlternative) {
              console.log(`    ‚ùå No alternative found - paths share too many cells. Skipping this iteration.`);
              continue; // Skip this iteration entirely
            }
          }

          console.log(`    ‚Üí Blocking at path index ${blockIndex}: (${cellToBlock.r}, ${cellToBlock.c})`);

          // Block this cell from all directions
          maze[cellToBlock.r][cellToBlock.c].top = true;
          maze[cellToBlock.r][cellToBlock.c].right = true;
          maze[cellToBlock.r][cellToBlock.c].bottom = true;
          maze[cellToBlock.r][cellToBlock.c].left = true;

          // Re-open ONLY the direction back toward START (previous cell in the actual path)
          if (blockIndex > 0) {
            const prevCell = pathToWrong[blockIndex - 1];
            const dr = cellToBlock.r - prevCell.r;
            const dc = cellToBlock.c - prevCell.c;

            if (dr === -1) {
              // Previous cell is ABOVE current cell
              maze[cellToBlock.r][cellToBlock.c].top = false;
            } else if (dr === 1) {
              // Previous cell is BELOW current cell
              maze[cellToBlock.r][cellToBlock.c].bottom = false;
            } else if (dc === -1) {
              // Previous cell is LEFT of current cell
              maze[cellToBlock.r][cellToBlock.c].left = false;
            } else if (dc === 1) {
              // Previous cell is RIGHT of current cell
              maze[cellToBlock.r][cellToBlock.c].right = false;
            }
          }
        }

        if (iteration >= maxIterations) {
          console.warn(`  ‚ö†Ô∏è END ${idx}: Max iterations reached - forcing complete disconnection`);
          // Force complete disconnection at border connection
          if (endBorderSide === 'top') {
            maze[endCell.r][endCell.c].bottom = true;
            if (endCell.r + 1 < rows) maze[endCell.r + 1][endCell.c].top = true;
          } else if (endBorderSide === 'bottom') {
            maze[endCell.r][endCell.c].top = true;
            if (endCell.r - 1 >= 0) maze[endCell.r - 1][endCell.c].bottom = true;
          } else if (endBorderSide === 'left') {
            maze[endCell.r][endCell.c].right = true;
            if (endCell.c + 1 < cols) maze[endCell.r][endCell.c + 1].left = true;
          } else {
            maze[endCell.r][endCell.c].left = true;
            if (endCell.c - 1 >= 0) maze[endCell.r][endCell.c - 1].right = true;
          }
        }
      } else {
        console.log(`END ${idx}: CORRECT PATH - stays fully connected`);
      }
    });

    console.log('\n‚úì‚úì‚úì ITERATIVE BLOCKING COMPLETE: EXACTLY ONE solution path guaranteed! ‚úì‚úì‚úì');


    // VERIFICATION: Check if START corridor is still open
    console.log('=== START CORRIDOR VERIFICATION ===');
    console.log(`START corridor (${startBorderSide}) still false? ${maze[startCell.r][startCell.c][startBorderSide] === false}`);
    if (maze[startCell.r][startCell.c][startBorderSide] !== false) {
      console.error(`‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è START CORRIDOR WAS OVERRIDDEN! Current value: ${maze[startCell.r][startCell.c][startBorderSide]}`);
    }
    console.log(`Correct END corridor (${endBorderSide}) is false? ${maze[endCells[correctPathIndex].r][endCells[correctPathIndex].c][endBorderSide] === false}`);

    // CRITICAL: Verify and FIX maze to ensure exactly ONE solution path
    console.log('=== VERIFYING MAZE PATHS ===');

    // Check if correct END is reachable
    let pathToCorrect = findMazeSolution(maze, startCell, endCells[correctPathIndex], rows, cols);

    if (!pathToCorrect || pathToCorrect.length === 0) {
      console.warn('‚ö†Ô∏è NO PATH TO CORRECT END - CARVING PATH');
      pathToCorrect = carvePathBetweenCells(maze, startCell, endCells[correctPathIndex], rows, cols, endBorderSide);
      console.log(`‚úì Path carved: ${pathToCorrect.length} cells`);
    } else {
      console.log(`‚úì Correct END reachable: ${pathToCorrect.length} cells`);
    }

    // Verify wrong ENDs are NOT reachable - ITERATIVELY block ALL paths until unreachable
    // Use the verified path to protect it from blocking
    const verifiedPathSet = new Set(pathToCorrect.map(c => `${c.r},${c.c}`));

    endCells.forEach((endCell, idx) => {
      if (idx !== correctPathIndex) {
        const entryDepth = endCorridorDepths[idx] || 5;
        let iteration = 0;
        const MAX_ITERATIONS = 20;
        let pathToWrong;

        // ITERATIVE BLOCKING: Keep blocking until wrong END is unreachable
        while (iteration < MAX_ITERATIONS) {
          pathToWrong = findMazeSolution(maze, startCell, endCell, rows, cols);

          if (!pathToWrong || pathToWrong.length === 0) {
            console.log(`‚úì Wrong END ${idx} unreachable after ${iteration} blocking iteration(s)`);
            break;
          }

          console.warn(`‚ö†Ô∏è Wrong END ${idx} reachable (${pathToWrong.length} cells) - blocking iteration ${iteration + 1}`);

          // Find a safe blocking point that's NOT on the correct path
          const minBlockIndex = Math.max(entryDepth + 2, Math.floor(pathToWrong.length * 0.5));
          let blockIndex = -1;

          // Search from deep to shallow for a safe blocking point
          for (let i = Math.min(minBlockIndex, pathToWrong.length - 2); i >= Math.max(1, entryDepth); i--) {
            const cellKey = `${pathToWrong[i].r},${pathToWrong[i].c}`;
            if (!verifiedPathSet.has(cellKey)) {
              blockIndex = i;
              break;
            }
          }

          if (blockIndex === -1 || blockIndex === 0) {
            // Can't find safe blocking point - try closer to entrance
            for (let i = Math.max(1, entryDepth); i < pathToWrong.length - 1; i++) {
              const cellKey = `${pathToWrong[i].r},${pathToWrong[i].c}`;
              if (!verifiedPathSet.has(cellKey)) {
                blockIndex = i;
                break;
              }
            }
          }

          if (blockIndex === -1 || blockIndex === 0 || blockIndex >= pathToWrong.length - 1) {
            console.error(`‚ùå Cannot safely block wrong END ${idx} - all blocking points conflict with correct path`);
            break;
          }

          // Block the connection BETWEEN cells on the wrong path
          const fromCell = pathToWrong[blockIndex];
          const toCell = pathToWrong[blockIndex + 1];

          // Close the wall between these cells
          if (toCell.r < fromCell.r) { // Moving up
            maze[fromCell.r][fromCell.c].top = true;
            maze[toCell.r][toCell.c].bottom = true;
          } else if (toCell.r > fromCell.r) { // Moving down
            maze[fromCell.r][fromCell.c].bottom = true;
            maze[toCell.r][toCell.c].top = true;
          } else if (toCell.c < fromCell.c) { // Moving left
            maze[fromCell.r][fromCell.c].left = true;
            maze[toCell.r][toCell.c].right = true;
          } else if (toCell.c > fromCell.c) { // Moving right
            maze[fromCell.r][fromCell.c].right = true;
            maze[toCell.r][toCell.c].left = true;
          }

          console.log(`  ‚Üí Blocked connection (${fromCell.r},${fromCell.c})‚Üí(${toCell.r},${toCell.c}) at index ${blockIndex}`);
          iteration++;
        }

        if (iteration >= MAX_ITERATIONS) {
          console.error(`‚ùå Max iterations reached for wrong END ${idx} - may still be reachable`);
        }
      }
    });

    // CRITICAL: Verify correct path is still intact after blocking
    console.log('=== FINAL VERIFICATION ===');
    const finalCorrectPath = findMazeSolution(maze, startCell, endCells[correctPathIndex], rows, cols);
    if (!finalCorrectPath || finalCorrectPath.length === 0) {
      console.error('‚ùå CRITICAL: Correct path was corrupted during blocking - re-carving');
      pathToCorrect = carvePathBetweenCells(maze, startCell, endCells[correctPathIndex], rows, cols, endBorderSide);
    } else {
      console.log(`‚úì Correct path verified: ${finalCorrectPath.length} cells`);
      pathToCorrect = finalCorrectPath; // Update to the final verified path
    }

    // Verify all wrong ENDs are unreachable
    endCells.forEach((endCell, idx) => {
      if (idx !== correctPathIndex) {
        const finalCheck = findMazeSolution(maze, startCell, endCell, rows, cols);
        if (finalCheck && finalCheck.length > 0) {
          console.error(`‚ùå FINAL CHECK: Wrong END ${idx} is STILL reachable (${finalCheck.length} cells)!`);
        } else {
          console.log(`‚úì FINAL CHECK: Wrong END ${idx} is unreachable`);
        }
      }
    });

    // Final verification: use already calculated path info from STEP 3
    const pathsToEndsForReturn = pathMetrics.map((metric, idx) => ({
      endIndex: idx,
      path: pathsToEnds[idx],
      canReach: metric.length > 0,
      turns: metric.turns,
      straightness: metric.straightness
    }));

    // Place END images outside appropriate border
    const itemPositions = [];

    endCells.forEach((cell, idx) => {
      const destinationImage = pathImages[idx % pathImages.length];
      let outsidePos;

      if (mazeDirection === 'bottom-top' || mazeDirection === 'top-bottom') {
        outsidePos = endOutsideMarker(cell.c);
      } else {
        outsidePos = endOutsideMarker(cell.r);
      }

      itemPositions.push({
        ...outsidePos,
        image: destinationImage,
        type: idx === correctPathIndex ? 'end-correct' : 'end-wrong',
        endIndex: idx,
        corridorCell: cell
      });
    });

    console.log(`Placed ${itemPositions.length} END images and ${obstacles.length} obstacles`);

    return {
      mazeWalls: maze,
      startCell: {
        ...startOutsideMarker,
        corridorCell: startCell
      },
      endCell: endCells[correctPathIndex],
      endCells,
      correctPathIndex,
      paths: pathsToEndsForReturn,
      items: itemPositions,
      obstacles: obstacles,
      rows,
      cols,
      mazeDirection,
      wrongPathBehavior,
      isMazeMode: true,
      isChoosePath: true
    };
  }

  // Helper: Generate path from one cell to another
  function generatePathFromTo(start, end, rows, cols) {
    const path = [start];
    const visited = new Set([`${start.r},${start.c}`]);
    let current = { ...start };
    const maxSteps = rows * cols;

    for (let step = 0; step < maxSteps; step++) {
      if (current.r === end.r && current.c === end.c) {
        return path;
      }

      // Find neighbors that move towards the goal
      const neighs = neighbors(current.r, current.c, rows, cols).filter(n => !visited.has(`${n.r},${n.c}`));
      if (neighs.length === 0) break;

      // Sort by distance to goal
      neighs.sort((a, b) => {
        const distA = Math.abs(a.r - end.r) + Math.abs(a.c - end.c);
        const distB = Math.abs(b.r - end.r) + Math.abs(b.c - end.c);
        return distA - distB;
      });

      // Take best move (with some randomness)
      const next = Math.random() < 0.8 ? neighs[0] : neighs[Math.floor(Math.random() * neighs.length)];
      path.push(next);
      visited.add(`${next.r},${next.c}`);
      current = next;
    }

    return path.length >= 3 ? path : null;
  }

  // Helper: Generate dead end path
  function generateDeadEndPath(start, correctPath, rows, cols) {
    const correctSet = new Set(correctPath.map(p => `${p.r},${p.c}`));
    const path = [start];
    const visited = new Set([`${start.r},${start.c}`]);
    let current = { ...start };
    const targetLength = getRandomInt(3, 8);

    for (let step = 0; step < targetLength; step++) {
      const neighs = neighbors(current.r, current.c, rows, cols)
        .filter(n => !visited.has(`${n.r},${n.c}`) && !correctSet.has(`${n.r},${n.c}`));

      if (neighs.length === 0) break;

      const next = neighs[Math.floor(Math.random() * neighs.length)];
      path.push(next);
      visited.add(`${next.r},${next.c}`);
      current = next;
    }

    return path;
  }

  // Helper: Generate wrong destination
  function generateWrongDestination(correctEnd, rows, cols) {
    // Place wrong destination far from correct end
    const wrongR = correctEnd.r < rows / 2 ? rows - 1 : 0;
    const wrongC = Math.floor(Math.random() * cols);
    return { r: wrongR, c: wrongC };
  }

  // Helper: Generate short path
  function generateShortPath(start, rows, cols) {
    const path = [start];
    const visited = new Set([`${start.r},${start.c}`]);
    let current = { ...start };
    const targetLength = getRandomInt(2, 4);

    for (let step = 0; step < targetLength; step++) {
      const neighs = neighbors(current.r, current.c, rows, cols).filter(n => !visited.has(`${n.r},${n.c}`));
      if (neighs.length === 0) break;

      const next = neighs[Math.floor(Math.random() * neighs.length)];
      path.push(next);
      visited.add(`${next.r},${next.c}`);
      current = next;
    }

    return path;
  }

  // Validation function for maze modes
  function validateMazeSettings(gameMode) {
    const errors = [];

    if (gameMode === 'classic-maze') {
      // CLASSIC MAZE: Only validate collectibles (NO start/end/obstacles)
      if (selectedPathImages.length < 1) {
        errors.push('Please select at least 1 Collectible image from the Image Library.');
      }
      // Classic Maze doesn't need start, end, or obstacle images - they're optional
    } else if (gameMode === 'choose-path') {
      // Choose Path needs: 1-3 END images (stored in pathImages array)
      if (selectedPathImages.length < 1) {
        errors.push('Please select at least 1 End image from the Image Library.');
      }
      if (selectedPathImages.length > 3) {
        errors.push('Maximum 3 End images allowed for Choose the Right Path mode.');
      }
    }

    return errors;
  }

  async function generatePathway() {
    clearMessage();
    isGenerating = true; // Prevent undo/redo from saving during generation

    // Get selected game mode
    const gameMode = document.getElementById('gameModeSelect').value;

    // Validate selections based on game mode
    if (gameMode === 'pathway') {
        // Original Picture Pathway validation
        if (!selectedStartImage || !selectedEndImage || selectedPathImages.length < 1 || selectedDistractorImages.length < 1) {
          displayMessage(t('picture.pathway.msg.complete.selections'), 'error');
          generateAnswerKeyBtn.disabled = true;
          downloadAnswerKeyJpegBtn.disabled = true;
          downloadAnswerKeyPdfBtn.disabled = true;
          isGenerating = false;
          return;
        }
    }

    // Run validation for new game modes
    const validationErrors = validateMazeSettings(gameMode);
    if (validationErrors.length > 0) {
        displayMessage(validationErrors.join('<br>'), 'error', 5000);
        isGenerating = false;
        return;
    }

    let solutionPath, gridData, cellTypes, rows, cols, mazeData;

    // Route to appropriate generation function based on game mode
    if (gameMode === 'classic-maze') {
        // Get Classic Maze settings
        const gridSize = parseInt(document.getElementById('mazeGridSize').value) || 15;
        rows = gridSize;
        cols = gridSize;

        // Get number of paths (1-3, only 1 is correct, others are dead-ends)
        const numPaths = parseInt(document.getElementById('mazeNumPaths').value) || 1;

        // Get user-selected copy range for collectibles
        const copiesMin = parseInt(document.getElementById('copiesPerImageMin').value) || 1;
        const copiesMax = parseInt(document.getElementById('copiesPerImageMax').value) || 5;

        // Classic Maze doesn't need collectiblesCount or obstaclesCount
        // Collectibles are placed based on user-selected min/max copies
        // Obstacles are not used in Classic Maze mode

        const config = {
            rows, cols,
            numPaths,              // Number of paths (1-3), only 1 correct
            collectiblesCount: 0,  // Not used
            obstaclesCount: 0,     // Not used - no obstacles in Classic Maze
            copiesMin,             // User-selected minimum copies per image
            copiesMax,             // User-selected maximum copies per image
            startImage: selectedStartImage || null,
            endImage: selectedEndImage || null,
            pathImages: selectedPathImages,
            distractorImages: selectedDistractorImages
        };

        const result = generateClassicMaze(config);
        if (!result) {
            displayMessage(t('picture.pathway.msg.path.generation.failed'), 'error');
            isGenerating = false;
            return;
        }

        // For wall-based maze, store the result directly
        mazeData = result;
        rows = result.rows;
        cols = result.cols;

    } else if (gameMode === 'choose-path') {
        // Re-randomize END images from animals theme every time generate is clicked
        await autoPopulateChoosePathImages();

        // Get Choose the Right Path settings
        const gridSize = parseInt(document.getElementById('choosePathGridSize').value) || 15;
        rows = gridSize;
        cols = gridSize;

        // Get number of paths (1-3, only 1 is correct, others are dead-ends)
        const numPaths = parseInt(document.getElementById('choosePathNumPaths').value) || 3;

        // Use default path length values (advanced settings removed)
        const pathMin = 6;
        const pathMax = 10;
        // Wrong paths always lead to dead ends in Choose Path mode
        const wrongPathBehavior = 'dead-end';

        const config = {
            rows, cols, numPaths, pathMin, pathMax, wrongPathBehavior,
            startImage: selectedStartImage || null,
            endImage: selectedEndImage || null,
            pathImages: selectedPathImages,
            distractorImages: selectedDistractorImages
        };

        const result = generateChooseRightPath(config);
        if (!result) {
            displayMessage(t('picture.pathway.msg.path.generation.failed'), 'error');
            isGenerating = false;
            return;
        }

        // For wall-based maze, store the result directly
        mazeData = result;
        rows = result.rows;
        cols = result.cols;

    } else {
        // Original Picture Pathway mode
        rows = 6;
        cols = 6;

        // Generate solution path
        solutionPath = generatePath(8, 12, rows, cols);
        if (!solutionPath) {
          displayMessage(t('picture.pathway.msg.path.generation.failed'), 'error');
          isGenerating = false;
          return;
        }

        // Helper function to check if adjacent cells have the same image
        const hasAdjacentSameImage = (r, c, imagePath, grid) => {
          const adjacentOffsets = [
            { dr: -1, dc: 0 },  // Up
            { dr: 1, dc: 0 },   // Down
            { dr: 0, dc: -1 },  // Left
            { dr: 0, dc: 1 }    // Right
          ];

          for (const offset of adjacentOffsets) {
            const adjR = r + offset.dr;
            const adjC = c + offset.dc;

            if (adjR >= 0 && adjR < rows && adjC >= 0 && adjC < cols) {
              const adjacentImg = grid[adjR][adjC];
              if (adjacentImg && adjacentImg.path === imagePath) {
                return true;
              }
            }
          }
          return false;
        };

        // Helper function to select image that's not adjacent to same image
        const selectNonAdjacentImage = (r, c, imagePool, grid, maxAttempts = 20) => {
          if (imagePool.length === 0) return null;

          // Try to find a non-adjacent image
          for (let attempt = 0; attempt < maxAttempts; attempt++) {
            const img = imagePool[Math.floor(Math.random() * imagePool.length)];
            if (!hasAdjacentSameImage(r, c, img.path, grid)) {
              return img;
            }
          }

          // Fallback: return random image even if adjacent (shouldn't happen often)
          return imagePool[Math.floor(Math.random() * imagePool.length)];
        };

        // Create grid data with images - WITH ADJACENCY CHECKING
        gridData = Array.from({ length: rows }, () => Array(cols).fill(null));

        // Place start image
        gridData[solutionPath[0].r][solutionPath[0].c] = selectedStartImage;

        // Place path images (with adjacency checking)
        for (let i = 1; i < solutionPath.length - 1; i++) {
            const cell = solutionPath[i];
            const selectedImg = selectNonAdjacentImage(cell.r, cell.c, selectedPathImages, gridData);
            gridData[cell.r][cell.c] = selectedImg;
        }

        // Place end image
        gridData[solutionPath[solutionPath.length - 1].r][solutionPath[solutionPath.length - 1].c] = selectedEndImage;

        // Fill empty cells with distractors - WITH ADJACENCY CHECKING
        let distractorPool = [...selectedDistractorImages];
        if (distractorPool.length === 0) {
            const allAvailableImages = [...allImages, ...uploadedImages];
            if (allAvailableImages.length > 0) {
                while(distractorPool.length < 10) distractorPool.push(allAvailableImages[getRandomInt(0, allAvailableImages.length - 1)]);
            } else {
                 displayMessage(t('picture.pathway.msg.no.distractors'), 'error');
                 isGenerating = false;
                 return;
            }
        }

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (!gridData[r][c]) {
                    const selectedImg = selectNonAdjacentImage(r, c, distractorPool, gridData);
                    gridData[r][c] = selectedImg;
                }
            }
        }

        console.log('Picture Pathway: All images placed with adjacency checking');
    }

    // Store worksheet data for canvas persistence
    if (gameMode === 'classic-maze' || gameMode === 'choose-path') {
        // For wall-based maze modes, store the maze data
        worksheetCanvas.mazeData = mazeData;
    } else {
        worksheetCanvas.solutionPath = solutionPath;
        worksheetCanvas.gridData = gridData;
        if (cellTypes) worksheetCanvas.cellTypes = cellTypes;
    }

    // Store complete puzzle data for regeneration (CRITICAL: follows wordsearch pattern EXACTLY)
    if (gameMode === 'classic-maze' || gameMode === 'choose-path') {
        // Wall-based maze modes
        lastGeneratedData = {
            ...mazeData,  // Spread the maze data (includes isMazeMode, mazeWalls, etc.)
            gameMode: gameMode,
            selectedStartImage: selectedStartImage,
            selectedEndImage: selectedEndImage,
            selectedPathImages: [...selectedPathImages],
            selectedDistractorImages: [...selectedDistractorImages]
        };
    } else {
        lastGeneratedData = {
            gameMode: gameMode,
            solutionPath: solutionPath,
            gridData: gridData,
            cellTypes: cellTypes,
            rows: rows,
            cols: cols,
            selectedStartImage: selectedStartImage,
            selectedEndImage: selectedEndImage,
            selectedPathImages: [...selectedPathImages],
            selectedDistractorImages: [...selectedDistractorImages]
        };
    }

    // CRITICAL: Follow wordsearch pattern EXACTLY
    // - Preserve user-added objects
    // - Remove old generated items
    // - Create header
    // - Create puzzle objects directly (NOT via regenerateCanvasLayout)
    // - Add new objects
    // - Apply z-order

    const userAddedObjects = worksheetCanvas.getObjects().filter(o =>
        !o.isGeneratedItem && !o.isBorder && !o.isBackground &&
        !o.isPageBorder && !o.isHeaderDesc && !o.isHeaderElement
    );

    // Remove ALL puzzle elements
    const oldGeneratedItems = worksheetCanvas.getObjects().filter(o => o.isGeneratedItem);
    oldGeneratedItems.forEach(o => worksheetCanvas.remove(o));

    // Remove old header/border objects
    const oldHeaderItems = worksheetCanvas.getObjects().filter(o =>
        o.isPageBorder || o.isHeaderDesc || o.isHeaderElement
    );
    oldHeaderItems.forEach(o => worksheetCanvas.remove(o));

    // Add header and border
    const headerObjects = createHeaderGroup(worksheetCanvas);
    if (headerObjects) {
        worksheetCanvas.add(...headerObjects);
    }

    // Create puzzle objects directly
    const newObjects = await createPuzzleGrid(lastGeneratedData, false);
    worksheetCanvas.add(...newObjects);

    enforceZOrder(worksheetCanvas);
    userAddedObjects.forEach(obj => obj.bringToFront());
    worksheetCanvas.renderAll();

    // Clear answer key canvas when generating new worksheet
    answerKeyCanvas.clear();
    answerKeyCanvas.backgroundColor = worksheetCanvas.backgroundColor;
    answerKeyCanvas.renderAll();

    // Reset flag and save initial state for undo/redo
    isGenerating = false;
    historyStack = []; // Clear history when new worksheet is generated
    redoStack = [];
    saveCanvasState(); // Save initial state after generation
    updateUndoRedoButtons();

    generateAnswerKeyBtn.disabled = false;
    displayMessage(t('picture.pathway.msg.worksheet.generated'), 'success', 3000);
  }

  async function generateAnswerKeyFromCanvas() {
    if (!lastGeneratedData) {
        displayMessage(t('picture.pathway.msg.generate.first'), "error");
        return;
    }

    // Regenerate answer key canvas using stored data (follows wordsearch pattern)
    await regenerateCanvasLayout(answerKeyCanvas, true);

    document.querySelector('.tab-button[data-tab="answerKeyTab"]').click();
    downloadAnswerKeyJpegBtn.disabled = false;
    downloadAnswerKeyPdfBtn.disabled = false;
    displayMessage(t('picture.pathway.msg.answer.generated'), "success");
  }

  /********************************
   * Download Functions
   ********************************/
  async function downloadImageFile(canvasToExport, fileName) {
      if (!canvasToExport || canvasToExport.getObjects().length === 0) {
          displayMessage(t('picture.pathway.msg.empty.canvas'), 'warning');
          return;
      }
      displayMessage(t('picture.pathway.msg.preparing.file').replace('{fileName}', fileName), 'info', 0);

      const exportOptions = { multiplier: downloadMultiplier, applyPixelLevelGrayscale: grayscaleToggle.checked };

      try {
          const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
          const link = document.createElement('a');
          link.download = fileName;
          link.href = dataURL;
          link.click();
          displayMessage(t('picture.pathway.msg.download.initiated'), 'success', 3000);
      } catch (error) {
          displayMessage(t('picture.pathway.msg.jpeg.error').replace('{message}', error.message), 'error');
      }
  }

  
    // Check if user is on free tier
    function isFreeTier() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('tier') === 'free';
    }

    // Add watermark to canvas before export
    function addWatermarkToCanvas(canvas) {
        if (!isFreeTier()) return;
        
        const watermarkText = new fabric.Text(t('picture.pathway.watermark.main'), {
            fontSize: 40,
            fill: 'rgba(0, 0, 0, 0.2)',
            angle: -45,
            left: canvas.width / 2,
            top: canvas.height / 2,
            originX: 'center',
            originY: 'center',
            selectable: false,
            evented: false,
            fontFamily: 'Arial, sans-serif',
            fontWeight: 'bold'
        });
        
        // Add multiple watermarks across the canvas
        const watermarks = [];
        const spacing = 250;
        for (let x = 0; x < canvas.width; x += spacing) {
            for (let y = 0; y < canvas.height; y += spacing) {
                const wm = new fabric.Text(t('picture.pathway.watermark.small'), {
                    fontSize: 20,
                    fill: 'rgba(0, 0, 0, 0.15)',
                    angle: -45,
                    left: x,
                    top: y,
                    selectable: false,
                    evented: false,
                    fontFamily: 'Arial, sans-serif'
                });
                watermarks.push(wm);
                canvas.add(wm);
            }
        }
        
        // Add main watermark
        canvas.add(watermarkText);
        canvas.renderAll();
        
        return { mainWatermark: watermarkText, watermarks };
    }

    // Remove watermark after export
    function removeWatermarkFromCanvas(canvas, watermarkData) {
        if (!watermarkData) return;
        
        if (watermarkData.mainWatermark) {
            canvas.remove(watermarkData.mainWatermark);
        }
        if (watermarkData.watermarks) {
            watermarkData.watermarks.forEach(wm => canvas.remove(wm));
        }
        canvas.renderAll();
    }

    // Override the original downloadPDF function
    const originalDownloadPDF = typeof downloadPDF !== 'undefined' ? downloadPDF : null;
    if (originalDownloadPDF) {
        window.downloadPDF = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('picture.pathway.msg.generate.content.first'), 'error');
            }
            showMessage(t('picture.pathway.msg.preparing.pdf'), 'info', 0);

            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);

            try {
                const { jsPDF } = window.jspdf;
                const orientation = currentCanvasConfig.width > currentCanvasConfig.height ? 'l' : 'p';
                const pdf = new jsPDF({
                    orientation,
                    unit: 'pt',
                    format: [currentCanvasConfig.width, currentCanvasConfig.height]
                });

                const exportOptions = {
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6,
                    applyPixelLevelGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked
                };

                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                pdf.addImage(dataURL, 'JPEG', 0, 0, currentCanvasConfig.width, currentCanvasConfig.height);

                pdf.save(fileName);
                showMessage(t('picture.pathway.msg.pdf.downloaded'), 'success');
            } catch(e) {
                showMessage(t('picture.pathway.msg.pdf.error'), 'error');
                console.error(e);
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

    // Override the original downloadJPEG function if it exists
    const originalDownloadJPEG = typeof downloadJPEG !== 'undefined' ? downloadJPEG : null;
    if (originalDownloadJPEG) {
        window.downloadJPEG = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('picture.pathway.msg.generate.worksheet.first'), 'error');
            }
            showMessage(t('picture.pathway.msg.preparing.jpeg'), 'info', 0);

            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);

            try {
                const exportOptions = {
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6,
                    applyPixelLevelGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked
                };
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);

                const link = document.createElement('a');
                link.href = dataURL;
                link.download = fileName;
                link.click();
                showMessage(t('picture.pathway.msg.jpeg.initiated'), 'success');
            } catch(e) {
                showMessage(t('picture.pathway.msg.jpeg.error.simple'), 'error');
                console.error(e);
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

async function downloadPDF(canvasToExport, fileName) {
      if (!canvasToExport || canvasToExport.getObjects().length === 0) {
          displayMessage(t('picture.pathway.msg.empty.canvas'), 'warning');
          return;
      }
      displayMessage(t('picture.pathway.msg.preparing.file').replace('{fileName}', fileName), 'info', 0);

      try {
          const { jsPDF } = window.jspdf;
          const orientation = currentCanvasConfig.width > currentCanvasConfig.height ? 'l' : 'p';
          const pdf = new jsPDF({
              orientation,
              unit: 'pt',
              format: [currentCanvasConfig.width, currentCanvasConfig.height]
          });
          const exportOptions = { multiplier: downloadMultiplier, applyPixelLevelGrayscale: grayscaleToggle.checked };
          const imgData = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
          pdf.addImage(imgData, 'JPEG', 0, 0, currentCanvasConfig.width, currentCanvasConfig.height);
          pdf.save(fileName);
          displayMessage(t('picture.pathway.msg.pdf.downloaded.alt'), 'success', 3000);
      } catch (error) {
          displayMessage(t('picture.pathway.msg.pdf.error.detailed').replace('{message}', error.message), "error");
      }
  }
  
  async function getCanvasDataURLWithOptions(canvasInstance, exportOptions) {
      // Save current zoom state
      const currentZoom = canvasInstance.getZoom();
      const currentWidth = canvasInstance.getWidth();
      const currentHeight = canvasInstance.getHeight();
      
      // Reset to actual dimensions for export
      canvasInstance.setZoom(1);
      canvasInstance.setDimensions({
          width: currentCanvasConfig.width,
          height: currentCanvasConfig.height
      });
      
      let dataURL = canvasInstance.toDataURL({
          format: 'jpeg',
          quality: 1.0,
          multiplier: exportOptions.multiplier,
          backgroundColor: canvasInstance.backgroundColor || '#FFFFFF'
      });
      
      // Restore display state
      canvasInstance.setZoom(currentZoom);
      canvasInstance.setDimensions({
          width: currentWidth,
          height: currentHeight
      });
      canvasInstance.renderAll();
      
      if (exportOptions.applyPixelLevelGrayscale) {
          dataURL = await applyGrayscaleToDataURL(dataURL);
      }
      return dataURL;
  }
  
  async function applyGrayscaleToDataURL(dataURL) {
      return new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = () => {
              const tempCanvas = document.createElement('canvas');
              const ctx = tempCanvas.getContext('2d');
              tempCanvas.width = img.width; tempCanvas.height = img.height;
              ctx.drawImage(img, 0, 0);
              const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
              const data = imageData.data;
              for (let i = 0; i < data.length; i += 4) {
                  const gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                  data[i] = data[i + 1] = data[i + 2] = gray;
              }
              ctx.putImageData(imageData, 0, 0);
              resolve(tempCanvas.toDataURL('image/jpeg', 1.0));
          };
          img.onerror = (err) => reject(err);
          img.src = dataURL;
      });
  }

  /********************************
   * Border & Background Logic
   ********************************/
  // These functions are now handled by BulletproofLoader
  function loadBorderThemes() {
      // Deprecated - Now handled by BulletproofLoader.init()
  }

  function loadBackgroundThemes() {
      // Deprecated - Now handled by BulletproofLoader.init()
  }

  function loadBorderImages() {
      const theme = borderThemeSelect.value;
      if (theme === 'none') {
          borderDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.border.message')}</p>`;
          [worksheetCanvas, answerKeyCanvas].forEach(c => {
               if (!c) return;
               const existingBorder = c.getObjects().find(obj => obj.isBorder);
               if (existingBorder) c.remove(existingBorder).renderAll();
          });
          document.querySelectorAll('#borderDictionary .border-thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
          borderOpacitySlider.disabled = true;
          return;
      }

      borderDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.loading.borders').replace('{theme}', theme)}</p>`;
      fetch(`/api/borders/images?theme=${theme}&locale=${currentLocale}`)
          .then(res => { if (!res.ok) throw new Error(t('picture.pathway.msg.borders.error')); return res.json(); })
          .then(data => {
              const borders = data.images || data.borders || data || [];
              renderBorderThumbnails(borders);
          })
          .catch(err => { console.error('Error loading border images:', err); borderDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.borders.error')}</p>`; });
  }

  function loadBackgroundImages() {
      const theme = backgroundThemeSelect.value;
      if (theme === 'none') {
          backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.background.message')}</p>`;
          [worksheetCanvas, answerKeyCanvas].forEach(c => {
               if (!c) return;
               const existingBg = c.getObjects().find(obj => obj.isBackground);
               if (existingBg) c.remove(existingBg).renderAll();
          });
          document.querySelectorAll('#backgroundDictionary .border-thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
          backgroundOpacitySlider.disabled = true;
          return;
      }
      
      backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.loading.backgrounds').replace('{theme}', theme)}</p>`;
      fetch(`/api/backgrounds/images?theme=${theme}&locale=${currentLocale}`)
          .then(res => { if (!res.ok) throw new Error(t('picture.pathway.msg.backgrounds.error')); return res.json(); })
          .then(data => {
              const backgrounds = data.images || data.backgrounds || data || [];
              renderBackgroundThumbnails(backgrounds);
          })
          .catch(err => { console.error('Error loading background images:', err); backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.backgrounds.error')}</p>`; });
  }
  
  function renderBorderThumbnails(borders) {
      borderDictionary.innerHTML = "";
      if (borders.length === 0) { borderDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.no.borders')}</p>`; return; }
      borders.forEach(border => {
          const item = document.createElement("div");
          item.className = "border-thumbnail-item";
          item.innerHTML = `<img src="${border.path}" alt="${border.name}" loading="lazy" />`;
          item.onclick = () => {
              addBorderToCanvas(border.path);
              document.querySelectorAll('#borderDictionary .border-thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
              item.classList.add('selected');
          };
          borderDictionary.appendChild(item);
      });
  }

  function renderBackgroundThumbnails(backgrounds) {
      backgroundDictionary.innerHTML = "";
      if (backgrounds.length === 0) { backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('picture.pathway.msg.no.backgrounds')}</p>`; return; }
      backgrounds.forEach(bg => {
          const item = document.createElement("div");
          item.className = "border-thumbnail-item";
          item.innerHTML = `<img src="${bg.path}" alt="${bg.name}" loading="lazy" />`;
          item.onclick = () => {
              addBackgroundToCanvas(bg.path);
              document.querySelectorAll('#backgroundDictionary .border-thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
              item.classList.add('selected');
          };
          backgroundDictionary.appendChild(item);
      });
  }

  function addBorderToCanvas(path) {
      addOverlayToCanvas(path, 'isBorder', borderOpacitySlider);
  }

  function addBackgroundToCanvas(path) {
      addOverlayToCanvas(path, 'isBackground', backgroundOpacitySlider);
  }

  // Unified overlay function - EXACTLY like addition.html
  async function addOverlayToCanvas(path, propName, opacitySlider) {
      const img = await new Promise((resolve) => fabric.Image.fromURL(path, resolve, { crossOrigin: 'anonymous' }));
      if (!img) return;

      const canvas = getActiveCanvas();
      if (!canvas) return;

      const existing = canvas.getObjects().find(obj => obj[propName]);
      if (existing) canvas.remove(existing);

      // Use ACTUAL canvas dimensions, not display dimensions
      const actualWidth = currentCanvasConfig.width;
      const actualHeight = currentCanvasConfig.height;

      // Scale to 70% of ACTUAL canvas height while preserving aspect ratio
      const targetHeight = actualHeight * 0.7;
      const scaleFactor = targetHeight / img.height;

      img.set({
          [propName]: true,
          originX: 'center',
          originY: 'center',
          left: actualWidth / 2,  // Use actual dimensions for correct centering
          top: actualHeight / 2,  // Use actual dimensions for correct centering
          scaleX: scaleFactor,
          scaleY: scaleFactor,
          selectable: true,
          evented: true,
          opacity: parseFloat(opacitySlider.value),
          borderColor: 'var(--app-accent-primary)',
          cornerColor: 'var(--app-accent-primary)',
          cornerSize: 10,
          transparentCorners: false,
          cornerStyle: 'circle'
      });

      canvas.add(img);
      enforceZOrder(canvas);

      // Auto-select the newly added border/background to show contextual toolbar
      canvas.setActiveObject(img);
      canvas.renderAll();
      opacitySlider.disabled = false;

      const typeName = propName === 'isBorder' ? t('picture.pathway.border.title') : t('picture.pathway.background.title');
      displayMessage(t('picture.pathway.msg.overlay.added').replace('{typeName}', typeName), 'success', 1500);
  }

  function applyBackgroundOpacity() {
      const newOpacity = parseFloat(backgroundOpacitySlider.value);
      const canvas = getActiveCanvas();
      const bg = canvas.getObjects().find(obj => obj.isBackground);
      if (bg) {
          bg.set('opacity', newOpacity);
          canvas.renderAll();
      }
  }

  /********************************
   * Clear All Function
   ********************************/
  function clearAll() {
    includeNameDateCheckbox.checked = false;

    selectedStartImage = null;
    selectedEndImage = null;
    selectedPathImages = [];
    selectedDistractorImages = [];
    renderUploadedImages();
    updateSelectionPreviews();

    pageColorInput.value = '#FFFFFF';

    if(worksheetCanvas) {
        worksheetCanvas.clear();
        worksheetCanvas.backgroundColor = '#fff';
        worksheetCanvas.renderAll();
        worksheetCanvas.solutionPath = null;
        worksheetCanvas.gridData = null;
        lastGeneratedData = null;
    }
    if(answerKeyCanvas) {
        answerKeyCanvas.clear();
        answerKeyCanvas.backgroundColor = '#fff';
        answerKeyCanvas.renderAll();
    }
    
    borderThemeSelect.value = "none";
    borderDictionary.innerHTML = '<p class="dictionary-message">Select a theme to see borders.</p>';
    borderOpacitySlider.value = 1;
    borderOpacitySlider.disabled = true;

    backgroundThemeSelect.value = "none";
    backgroundDictionary.innerHTML = '<p class="dictionary-message">Select a theme for backgrounds.</p>';
    backgroundOpacitySlider.value = 1;
    backgroundOpacitySlider.disabled = true;

    generateAnswerKeyBtn.disabled = true;
    downloadAnswerKeyJpegBtn.disabled = true;
    downloadAnswerKeyPdfBtn.disabled = true;
    
    if (generateDropdownContent) generateDropdownContent.style.display = 'none';
    if (downloadDropdownContent) downloadDropdownContent.style.display = 'none';

    searchInput.value = "";
    themeSelect.value = "all";
    pageSizeSelect.value = "612x792"; customPageSizeInputsDiv.style.display = 'none';
    updateCanvasDisplayDimensions(612, 792, true); // fromLoad=true to skip regeneration
    handleSelectionCleared(null, getActiveCanvas());
    displayMessage(t('picture.pathway.msg.form.cleared'), "success", 2000); 
    loadDictionary();
  }


  /********************************
   * Initial Setup & Event Listeners
   ********************************/
  worksheetCanvas = initializeCanvas(worksheetCanvasElement);
  answerKeyCanvas = initializeCanvas(answerKeyCanvasElement);
  
  worksheetCanvas.backgroundColor = pageColorInput.value;
  answerKeyCanvas.backgroundColor = pageColorInput.value;
  worksheetCanvas.renderAll();
  answerKeyCanvas.renderAll();

  // Initialize zoom display
  updateZoomDisplay();

  function setupCanvasEventListeners(canvas) {
    canvas.on({
      'selection:created': function(e) { handleObjectSelection(e, this); },
      'selection:updated': function(e) { handleObjectSelection(e, this); },
      'selection:cleared': function(e) { handleSelectionCleared(e, this); },
      // Undo/Redo canvas hooks - save state after modifications
      'object:modified': function(e) { saveCanvasState(); },
      'object:added': function(e) { saveCanvasState(); },
      'object:removed': function(e) { saveCanvasState(); }
    });
  }

  setupCanvasEventListeners(worksheetCanvas);
  setupCanvasEventListeners(answerKeyCanvas);
  
  setupGlobalKeydownListener();
  updateCanvasDisplayDimensions(612, 792, true); // fromLoad=true for initial setup

  // Zoom Controls
  zoomInBtn.addEventListener('click', zoomIn);
  zoomOutBtn.addEventListener('click', zoomOut);
  zoomResetBtn.addEventListener('click', zoomReset);

  // Undo/Redo Controls
  undoBtn.addEventListener('click', undo);
  redoBtn.addEventListener('click', redo);
  unlockAllBtn.addEventListener('click', unlockAllObjects);

  clearBtn.addEventListener("click", clearAll);

  generateWorksheetBtn.addEventListener("click", async () => {
    if (generateDropdownContent) generateDropdownContent.style.display = 'none';
    try { await generatePathway(); }
    catch (e) { console.error("Error generating pathway:", e); displayMessage(t('picture.pathway.msg.path.generation.failed'), 'error'); }
  });
  generateAnswerKeyBtn.addEventListener("click", async () => {
    if (generateDropdownContent) generateDropdownContent.style.display = 'none';
    try { await generateAnswerKeyFromCanvas(); }
    catch (e) { console.error("Error generating answer key:", e); displayMessage(t('picture.pathway.msg.path.generation.failed'), 'error'); }
  });
  
  layersBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(layersDropdown); });
  alignBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(alignDropdown); });
  toolbarBringToFrontBtn.addEventListener('click', bringObjectToFront);
  toolbarBringForwardBtn.addEventListener('click', bringObjectForward);
  toolbarSendBackwardBtn.addEventListener('click', sendObjectBackward);
  toolbarSendToBackBtn.addEventListener('click', sendObjectToBack);
  toolbarLockBtn.addEventListener('click', toggleLockSelectedObjects);
  toolbarDeleteBtn.addEventListener('click', deleteSelectedObjects);
  document.querySelectorAll('#alignDropdown button').forEach(button => {
      button.addEventListener('click', (e) => {
          const type = e.currentTarget.id.replace('Btn', '');
          alignObjects(type);
      });
  });

  // Download Listeners
  downloadWorksheetJpegBtn.addEventListener("click", () => downloadImageFile(worksheetCanvas, 'worksheet.jpeg'));
  downloadAnswerKeyJpegBtn.addEventListener("click", () => downloadImageFile(answerKeyCanvas, 'answer_key.jpeg'));
  downloadWorksheetPdfBtn.addEventListener("click", () => downloadPDF(worksheetCanvas, 'worksheet.pdf'));
  downloadAnswerKeyPdfBtn.addEventListener("click", () => downloadPDF(answerKeyCanvas, 'answer_key.pdf'));

  /******************************
   * NEW GAME MODE EVENT LISTENERS
   ******************************/

  // Update image selection dropdown based on game mode
  function updateImageSelectionOptions(gameMode) {
    const selectionTypeSelect = document.getElementById('selectionType');
    selectionTypeSelect.innerHTML = '';

    if (gameMode === 'classic-maze') {
      // Classic Maze: ONLY Collectibles and Decoration (NO start, end, or obstacles)
      selectionTypeSelect.innerHTML = `
        <option value="path" data-translate="picture.pathway.maze.collectibles">Collectibles (4 images recommended)</option>
        <option value="decoration" data-translate="picture.pathway.decoration.image">üé® Decoration (place anywhere)</option>
      `;
    } else if (gameMode === 'choose-path') {
      // Choose Path: ONLY End images (3 needed for the 3 destinations at top)
      selectionTypeSelect.innerHTML = `
        <option value="end" data-translate="picture.pathway.end.image">End Image (3 auto-selected from animals)</option>
      `;
    } else {
      // Picture Pathway (default): Start, End, Path, Distractor, Decoration
      selectionTypeSelect.innerHTML = `
        <option value="start" data-translate="picture.pathway.start.image">Start Image (1 needed)</option>
        <option value="end" data-translate="picture.pathway.end.image">End Image (1 needed)</option>
        <option value="path" data-translate="picture.pathway.path.image">Path Image (‚â•1 needed)</option>
        <option value="distractor" data-translate="picture.pathway.distractor.image">Distractor Image (‚â•6 recommended)</option>
        <option value="decoration" data-translate="picture.pathway.decoration.image">üé® Decoration (place anywhere)</option>
      `;
    }

    // Re-apply translations
    applyTranslations();
  }

  // Update selected images preview labels based on game mode
  function updateSelectionPreviewLabels(gameMode) {
    const startLabel = document.getElementById('startLabel');
    const endLabel = document.getElementById('endLabel');
    const pathLabel = document.getElementById('pathLabel');
    const distractorLabel = document.getElementById('distractorLabel');

    // Start label is always the same
    startLabel.setAttribute('data-translate', 'picture.pathway.start.image');

    // End label is always the same
    endLabel.setAttribute('data-translate', 'picture.pathway.end.image');

    // Get panel elements
    const startPanel = document.getElementById('startPanel');
    const endPanel = document.getElementById('endPanel');
    const pathPanel = document.getElementById('pathPanel');
    const distractorPanel = document.getElementById('distractorPanel');

    if (gameMode === 'classic-maze') {
      // Classic Maze: Show ONLY Collectibles (path)
      startPanel.style.display = 'none';
      endPanel.style.display = 'none';
      pathPanel.style.display = 'block';
      distractorPanel.style.display = 'none';

      pathLabel.setAttribute('data-translate', 'picture.pathway.maze.collectibles');
      pathLabel.textContent = 'Collectibles (1-4 needed)';
    } else if (gameMode === 'choose-path') {
      // Choose Path: Show ONLY End Images (in path section)
      startPanel.style.display = 'none';
      endPanel.style.display = 'none';
      pathPanel.style.display = 'block';
      distractorPanel.style.display = 'none';

      pathLabel.setAttribute('data-translate', 'picture.pathway.end.image');
      pathLabel.textContent = 'End Images (3 auto-selected from animals)';
    } else {
      // Picture Pathway: Show ALL sections
      startPanel.style.display = 'block';
      endPanel.style.display = 'block';
      pathPanel.style.display = 'block';
      distractorPanel.style.display = 'block';

      pathLabel.setAttribute('data-translate', 'picture.pathway.path.image');
      distractorLabel.setAttribute('data-translate', 'picture.pathway.distractor.image');
    }

    // Re-apply translations
    applyTranslations();
  }

  // Auto-populate images for Classic Maze mode
  async function autoPopulateClassicMazeImages() {
    try {
      console.log('Auto-populating Classic Maze images...');

      // Helper function to fetch images from a theme
      async function getThemeImages(themeName) {
        const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
        if (!res.ok) throw new Error(`Failed to load ${themeName} theme`);
        const data = await res.json();
        return data.images || data;
      }

      // Clear ALL previous selections (Classic Maze doesn't use start/end images or obstacles)
      selectedStartImage = null;
      selectedEndImage = null;
      selectedPathImages = [];
      selectedDistractorImages = [];  // No obstacles in Classic Maze

      // Get user-selected number of collectible images (1-4)
      const numImages = parseInt(document.getElementById('numCollectibleImages').value) || 4;

      // Get the user's selected theme (use 'fruits' as fallback if 'all' is selected)
      const selectedTheme = themeSelect.value;
      const themeToUse = (selectedTheme && selectedTheme !== 'all') ? selectedTheme : 'fruits';

      // Auto-select random images from user-selected theme for collectibles
      const themeImages = await getThemeImages(themeToUse);
      if (themeImages.length >= numImages) {
        const shuffledImages = [...themeImages].sort(() => Math.random() - 0.5);
        selectedPathImages = shuffledImages.slice(0, numImages);
        console.log(`Auto-selected ${numImages} collectibles from ${themeToUse} theme:`, selectedPathImages.map(img => img.word));
      } else if (themeImages.length > 0) {
        // If less than requested images available, use what we have
        selectedPathImages = [...themeImages];
        console.log('Auto-selected', selectedPathImages.length, `collectibles from ${themeToUse} theme (less than ${numImages} available)`);
      } else {
        console.error(`No ${themeToUse} images available for collectibles`);
      }

      // Update preview to reflect changes
      updateSelectionPreviews();

      console.log('Classic Maze auto-population complete - collectibles only, no obstacles');
    } catch (error) {
      console.error('Error auto-populating Classic Maze images:', error);
    }
  }

  // Auto-populate images for Choose the Right Path mode
  async function autoPopulateChoosePathImages() {
    try {
      console.log('Auto-populating Choose the Right Path images...');

      // Helper function to fetch images from a theme
      async function getThemeImages(themeName) {
        const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
        if (!res.ok) throw new Error(`Failed to load ${themeName} theme`);
        const data = await res.json();
        return data.images || data;
      }

      // Clear ALL previous selections
      selectedStartImage = null;
      selectedEndImage = null;
      selectedPathImages = [];
      selectedDistractorImages = [];

      // Choose Path needs 3 END images from user-selected theme
      // Get the user's selected theme (use 'fruits' as fallback if 'all' is selected)
      const selectedTheme = themeSelect.value;
      const themeToUse = (selectedTheme && selectedTheme !== 'all') ? selectedTheme : 'fruits';

      // Auto-select 3 DIFFERENT random images from selected theme each time
      const themeImages = await getThemeImages(themeToUse);

      if (themeImages.length >= 3) {
        // Shuffle all images and take first 3 (ensures different images each time)
        const shuffled = [...themeImages].sort(() => Math.random() - 0.5);
        selectedPathImages.push(shuffled[0]);
        selectedPathImages.push(shuffled[1]);
        selectedPathImages.push(shuffled[2]);
        console.log(`Auto-selected 3 random END images from ${themeToUse} theme:`,
          shuffled[0].word, shuffled[1].word, shuffled[2].word);
      } else {
        console.warn(`Not enough ${themeToUse} images available, using all available`);
        selectedPathImages.push(...themeImages);
      }

      console.log(`Auto-selected ${selectedPathImages.length} END images for Choose Path mode from ${themeToUse} theme`);

      // Update preview to reflect changes
      updateSelectionPreviews();

      console.log('Choose the Right Path auto-population complete');
    } catch (error) {
      console.error('Error auto-populating Choose the Right Path images:', error);
    }
  }

  // Game Mode selector - show/hide appropriate accordions and update image selection
  document.getElementById('gameModeSelect').addEventListener('change', async function() {
    const gameMode = this.value;

    // Hide all mode-specific accordions first
    document.getElementById('classicMazeSettingsAccordion').style.display = 'none';
    document.getElementById('choosePathSettingsAccordion').style.display = 'none';

    // Hide/show image selection panels based on mode
    const startPanel = document.getElementById('startSelection').closest('.selection-panel');
    const endPanel = document.getElementById('endSelection').closest('.selection-panel');
    const distractorPanel = document.getElementById('distractorSelection').closest('.selection-panel');

    if (gameMode === 'classic-maze') {
      // CLASSIC MAZE: Hide start, end, and obstacle/distractor panels
      if (startPanel) startPanel.style.display = 'none';
      if (endPanel) endPanel.style.display = 'none';
      if (distractorPanel) distractorPanel.style.display = 'none';
    } else {
      // OTHER MODES: Show all panels
      if (startPanel) startPanel.style.display = '';
      if (endPanel) endPanel.style.display = '';
      if (distractorPanel) distractorPanel.style.display = '';
    }

    // Show appropriate sections based on mode
    if (gameMode === 'classic-maze') {
      document.getElementById('classicMazeSettingsAccordion').style.display = '';
      // Auto-populate with default images for Classic Maze
      await autoPopulateClassicMazeImages();
    } else if (gameMode === 'choose-path') {
      document.getElementById('choosePathSettingsAccordion').style.display = '';
      // Auto-populate with default images for Choose the Right Path
      await autoPopulateChoosePathImages();
    }

    // Update image selection dropdown and preview labels
    updateImageSelectionOptions(gameMode);
    updateSelectionPreviewLabels(gameMode);
  });

  // Initialize with default mode
  const defaultMode = document.getElementById('gameModeSelect').value;
  updateImageSelectionOptions(defaultMode);
  updateSelectionPreviewLabels(defaultMode);

  // Apply initial panel visibility based on default mode
  const startPanel = document.getElementById('startSelection').closest('.selection-panel');
  const endPanel = document.getElementById('endSelection').closest('.selection-panel');
  const distractorPanel = document.getElementById('distractorSelection').closest('.selection-panel');

  if (defaultMode === 'classic-maze') {
    // CLASSIC MAZE: Hide start, end, and obstacle/distractor panels on initial load
    if (startPanel) startPanel.style.display = 'none';
    if (endPanel) endPanel.style.display = 'none';
    if (distractorPanel) distractorPanel.style.display = 'none';
  }

  // Number of Collectible Images selector - re-populate when changed
  document.getElementById('numCollectibleImages').addEventListener('change', async function() {
    const gameMode = document.getElementById('gameModeSelect').value;
    if (gameMode === 'classic-maze') {
      // Re-populate with new number of images
      await autoPopulateClassicMazeImages();
    }
  });

  // Wall control slider elements
  const wallThicknessSlider = document.getElementById('mazeWallThickness');
  const wallThicknessValue = document.getElementById('wallThicknessValue');
  const wallOpacitySlider = document.getElementById('mazeWallOpacity');
  const wallOpacityValue = document.getElementById('wallOpacityValue');
  const choosePathWallThicknessSlider = document.getElementById('choosePathWallThickness');
  const choosePathWallThicknessValue = document.getElementById('choosePathWallThicknessValue');
  const choosePathWallOpacitySlider = document.getElementById('choosePathWallOpacity');
  const choosePathWallOpacityValue = document.getElementById('choosePathWallOpacityValue');

  // REAL-TIME MAZE WALL APPEARANCE UPDATES
  // Function to update all maze walls on the canvas
  function updateMazeWallAppearance() {
    const canvas = getActiveCanvas();
    if (!canvas) return;

    // Determine which mode we're in
    const gameModeSelect = document.getElementById('gameModeSelect');
    const isChoosePath = gameModeSelect && gameModeSelect.value === 'choose-path';

    // Get wall settings based on mode
    const wallColor = isChoosePath
      ? (document.getElementById('choosePathWallColor')?.value || '#4CAF50')
      : (document.getElementById('mazeWallColor')?.value || '#4CAF50');
    const wallThickness = isChoosePath
      ? (parseInt(document.getElementById('choosePathWallThickness')?.value) || 3)
      : (parseInt(document.getElementById('mazeWallThickness')?.value) || 3);
    const wallOpacity = isChoosePath
      ? ((parseInt(document.getElementById('choosePathWallOpacity')?.value) || 100) / 100)
      : ((parseInt(document.getElementById('mazeWallOpacity')?.value) || 100) / 100);

    // Helper function to update walls recursively (handles groups)
    function updateWallsRecursive(objects, wallsUpdated) {
      objects.forEach(obj => {
        // If this object is a Group, recursively update its children
        if (obj.type === 'group' && obj.getObjects) {
          const groupObjects = obj.getObjects();
          wallsUpdated = updateWallsRecursive(groupObjects, wallsUpdated);
          obj.dirty = true; // Mark group as dirty so it re-renders
        }
        // If this is a maze wall, update its properties
        else if (obj.isMazeWall) {
          obj.set({
            stroke: wallColor,
            strokeWidth: obj.type === 'rect' ? wallThickness * 2 : wallThickness, // Outer border is 2x
            opacity: wallOpacity
          });
          wallsUpdated++;
        }
      });
      return wallsUpdated;
    }

    // Find and update all maze wall objects (including those inside groups)
    let wallsUpdated = 0;
    wallsUpdated = updateWallsRecursive(canvas.getObjects(), wallsUpdated);

    console.log(`‚úÖ Real-time update: ${wallsUpdated} maze walls updated`);
    canvas.renderAll();
  }

  // Wire up Classic Maze wall controls for real-time updates
  document.getElementById('mazeWallColor')?.addEventListener('input', updateMazeWallAppearance);
  wallThicknessSlider.addEventListener('input', function() {
    wallThicknessValue.textContent = this.value + 'px';
    updateMazeWallAppearance();
  });
  wallOpacitySlider.addEventListener('input', function() {
    wallOpacityValue.textContent = this.value + '%';
    updateMazeWallAppearance();
  });

  // Wire up Choose Path wall controls for real-time updates
  document.getElementById('choosePathWallColor')?.addEventListener('input', updateMazeWallAppearance);
  choosePathWallThicknessSlider.addEventListener('input', function() {
    choosePathWallThicknessValue.textContent = this.value + 'px';
    updateMazeWallAppearance();
  });
  choosePathWallOpacitySlider.addEventListener('input', function() {
    choosePathWallOpacityValue.textContent = this.value + '%';
    updateMazeWallAppearance();
  });

  // END NEW GAME MODE EVENT LISTENERS

  themeSelect.addEventListener("change", () => {
    selectedTheme = themeSelect.value;
    loadDictionary();
  });
  searchInput.addEventListener("input", () => { if(this.searchTimeout) clearTimeout(this.searchTimeout); this.searchTimeout = setTimeout(loadDictionary, 300); });
  
  borderThemeSelect.addEventListener("change", loadBorderImages);
  borderOpacitySlider.addEventListener('input', () => {
      const canvas = getActiveCanvas();
      const activeBorder = canvas.getObjects().find(obj => obj.isBorder);
      if (activeBorder) {
          activeBorder.set('opacity', parseFloat(borderOpacitySlider.value));
          canvas.renderAll();
      }
  });
  
  backgroundThemeSelect.addEventListener("change", loadBackgroundImages);
  backgroundOpacitySlider.addEventListener('input', applyBackgroundOpacity);


  // Apply translations on initial load
  if (typeof applyTranslations !== 'undefined') {
      applyTranslations();
  }

  // PERFORMANCE: Preload default themes for instant first generation
  async function preloadDefaultTheme() {
    try {
      console.log('üöÄ Preloading default themes for instant first load...');

      // Preload Fruits theme (for Start/End images)
      const fruitsResponse = await fetch(`/api/images?theme=fruits&locale=${currentLocale}`);
      if (fruitsResponse.ok) {
        const fruitsData = await fruitsResponse.json();
        const fruitsImages = fruitsData.images || fruitsData;
        const fruitsCacheKey = `fruits-${currentLocale}`;
        allImagesCache[fruitsCacheKey] = fruitsImages;

        // Preload first 4 fruit images in browser cache
        fruitsImages.slice(0, 4).forEach(imgData => {
          const img = new Image();
          img.src = imgData.path;
        });
        console.log(`‚úÖ Preloaded fruits theme (${fruitsImages.length} images)`);
      }

      // Preload Vegetables theme (for Path images)
      const vegetablesResponse = await fetch(`/api/images?theme=vegetables&locale=${currentLocale}`);
      if (vegetablesResponse.ok) {
        const vegetablesData = await vegetablesResponse.json();
        const vegetablesImages = vegetablesData.images || vegetablesData;
        const vegetablesCacheKey = `vegetables-${currentLocale}`;
        allImagesCache[vegetablesCacheKey] = vegetablesImages;

        // Preload first 4 vegetable images in browser cache
        vegetablesImages.slice(0, 4).forEach(imgData => {
          const img = new Image();
          img.src = imgData.path;
        });
        console.log(`‚úÖ Preloaded vegetables theme (${vegetablesImages.length} images)`);
      }

      // Preload Farm Animals theme (for Distractor images)
      const farmAnimalsResponse = await fetch(`/api/images?theme=farm_animals&locale=${currentLocale}`);
      if (farmAnimalsResponse.ok) {
        const farmAnimalsData = await farmAnimalsResponse.json();
        const farmAnimalsImages = farmAnimalsData.images || farmAnimalsData;
        const farmAnimalsCacheKey = `farm_animals-${currentLocale}`;
        allImagesCache[farmAnimalsCacheKey] = farmAnimalsImages;

        // Preload first 6 farm animal images in browser cache
        farmAnimalsImages.slice(0, 6).forEach(imgData => {
          const img = new Image();
          img.src = imgData.path;
        });
        console.log(`‚úÖ Preloaded farm_animals theme (${farmAnimalsImages.length} images)`);
      }

      console.log('‚úÖ All default themes preloaded successfully');
    } catch (error) {
      // Fail silently - not critical, will fetch on demand if needed
      console.warn('‚ö†Ô∏è Theme preloading failed (non-critical):', error);
    }
  }

  async function generateInitialWorksheet() {
    try {
      console.log('Starting initial worksheet generation...');

      // Wait for themes to load
      let attempts = 0;
      const maxAttempts = 50;
      while (themeSelect.options.length <= 1 && attempts < maxAttempts) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
      }

      // Set page size to Letter portrait (already default)
      pageSizeSelect.value = '612x792';
      const [width, height] = pageSizeSelect.value.split('x').map(Number);
      currentCanvasConfig.width = width;
      currentCanvasConfig.height = height;
      worksheetCanvas.setDimensions({ width, height });
      answerKeyCanvas.setDimensions({ width, height });
      await updateCanvasDisplayDimensions(width, height, true); // fromLoad=true for initial setup

      // PERFORMANCE: Helper function to fetch images from a theme (uses cache if available)
      async function getThemeImages(themeName) {
        const cacheKey = `${themeName}-${currentLocale}`;

        // Check cache first - instant if preloaded!
        if (allImagesCache[cacheKey]) {
          console.log(`‚ö° Using cached ${themeName} theme (instant!)`);
          return allImagesCache[cacheKey];
        }

        // Not in cache - fetch from API
        console.log(`üåê Fetching ${themeName} theme from API...`);
        const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
        if (!res.ok) throw new Error(`Failed to load ${themeName} theme`);
        const data = await res.json();
        const images = data.images || data;

        // Store in cache for next time
        allImagesCache[cacheKey] = images;
        return images;
      }

      // Load Fruits theme for Start and End images
      const fruitsImages = await getThemeImages('fruits');
      if (fruitsImages.length < 2) {
        console.error('Not enough fruits images');
        return;
      }

      // Select random start and end images from fruits
      const shuffledFruits = [...fruitsImages].sort(() => Math.random() - 0.5);
      selectedStartImage = shuffledFruits[0];
      selectedEndImage = shuffledFruits[1];

      // Load Vegetables theme for Path images (4 images)
      const vegetablesImages = await getThemeImages('vegetables');
      if (vegetablesImages.length < 4) {
        console.error('Not enough vegetables images');
        return;
      }
      const shuffledVegetables = [...vegetablesImages].sort(() => Math.random() - 0.5);
      selectedPathImages = shuffledVegetables.slice(0, 4);

      // Load Farm Animals theme for Distractor images (6 images)
      const farmAnimalsImages = await getThemeImages('farm_animals');
      if (farmAnimalsImages.length < 6) {
        console.error('Not enough farm_animals images');
        return;
      }
      const shuffledFarmAnimals = [...farmAnimalsImages].sort(() => Math.random() - 0.5);
      selectedDistractorImages = shuffledFarmAnimals.slice(0, 6);

      // Update UI
      updateSelectionPreviews();

      // Wait a bit and generate
      await new Promise(resolve => setTimeout(resolve, 200));
      await generatePathway();

      console.log('Initial worksheet generated successfully');
    } catch (error) {
      console.error('Error generating initial worksheet:', error);
    }
  }

  // Initial loads
  loadThemes();
  updateSelectionPreviews();
  handleSelectionCleared(null, getActiveCanvas());

  // Initialize BulletproofLoader to handle border/background themes
  // EXACTLY like addition.html and wordsearch.html do it
  if (window.BulletproofLoader) {
      console.log('Initializing BulletproofLoader with locale:', currentLocale);

      window.BulletproofLoader.init({
          borderSelect: borderThemeSelect,
          backgroundSelect: backgroundThemeSelect,
          locale: currentLocale  // EXPLICITLY pass the locale
      }).then(() => {
          console.log('‚úÖ BulletproofLoader initialized successfully');
      }).catch(err => {
          console.error('‚ùå BulletproofLoader failed:', err);
      });
  } else {
      console.warn('‚ö†Ô∏è BulletproofLoader not found');
  }

  // PERFORMANCE: Preload themes then generate instantly (no delay!)
  (async () => {
    await preloadDefaultTheme();
    await generateInitialWorksheet();
  })();
});
</script>
</body>
</html>