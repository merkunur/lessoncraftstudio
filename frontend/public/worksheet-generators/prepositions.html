<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translate="prepositions.page.title">Prepositions Worksheet Generator</title>
    <script src="js/translations-prepositions.js?v=4"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- Enhancement scripts for robust integration -->
    <script src="js/bulletproof-loader.js"></script>
    <script src="js/unified-language-manager.js"></script>
    <script src="js/border-background-sizer.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;700&family=Fredoka:wght@400;500;600&family=Lexend+Deca&family=Nunito:wght@400;700&family=Quicksand:wght@300..700&display=swap" rel="stylesheet" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
        :root {
            --app-font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            --app-bg-dark: #2c2c2e;
            --app-surface-dark: #3a3a3e;
            --app-border-dark: #4a4a4a;
            --app-text-primary-dark-theme: #e0e0e0;
            --app-text-secondary-dark-theme: #a0a0a0;
            --app-accent-primary: #007aff;
            --app-accent-primary-hover: #005ecb;
            --app-accent-secondary: #5856d6;
            --app-accent-danger: #ff3b30;
            --app-bg-light: #f0f2f5;
            --app-surface-light: #ffffff;
            --app-border-light: #dce1e6;
            --app-text-primary-light-theme: #1c1c1e;
            --app-text-secondary-light-theme: #545458;
            --sidebar-width: 340px;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: var(--app-font-stack);
            background: var(--app-bg-light);
            display: flex;
            min-height: 100vh;
            overflow: hidden;
            color: var(--app-text-primary-light-theme);
        }
        .layout { display: flex; flex: 1; overflow: hidden; height: 100vh; }
        .panel {
            width: var(--sidebar-width);
            min-width: var(--sidebar-width);
            background: var(--app-bg-dark);
            color: var(--app-text-primary-dark-theme);
            box-shadow: 2px 0 8px rgba(0,0,0,0.15);
            border-right: 1px solid var(--app-border-dark);
            display: flex;
            flex-direction: column;
            font-size: 14px;
            padding: 0;
            transition: transform 0.3s ease-in-out;
            z-index: 1000;
        }
        .panel-header {
            padding: 20px 25px;
            border-bottom: 1px solid var(--app-border-dark);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header h2 { font-size: 22px; font-weight: 600; color: var(--app-text-primary-dark-theme); margin: 0; }
        .panel-content { overflow-y: auto; flex-grow: 1; padding: 0; }
        .accordion-item { border-bottom: 1px solid var(--app-border-dark); }
        .accordion-item:last-child { border-bottom: none; }
        .accordion-button {
            background-color: transparent;
            color: var(--app-text-primary-dark-theme);
            width: 100%; border: none; text-align: left; padding: 18px 20px;
            font-size: 15px; font-weight: 500; cursor: pointer; display: flex;
            justify-content: space-between; align-items: center; transition: background-color 0.15s ease;
        }
        .accordion-button:hover { background-color: rgba(255,255,255,0.05); }
        .accordion-button::after { content: '\f078'; font-family: 'Font Awesome 5 Free'; font-weight: 900; font-size: 12px; transition: transform 0.2s ease-in-out; }
        .accordion-button.active::after { transform: rotate(-180deg); }
        .accordion-content { padding: 10px 15px 20px 15px; display: none; background-color: transparent; }
        .accordion-content.active { display: block; }
        .accordion-content h4 { font-size: 13px; color: var(--app-text-secondary-dark-theme); margin-top: 10px; margin-bottom: 8px; border-bottom: 1px solid var(--app-border-dark); padding-bottom: 6px; font-weight: 500; }
        .accordion-content h4:first-child { margin-top: 0; }
        .accordion-content label { display: block; font-size: 13px; font-weight: 400; color: var(--app-text-secondary-dark-theme); margin-bottom: 6px; }
        .accordion-content input, .accordion-content select, .accordion-content textarea {
            width: 100%; padding: 8px 10px; font-size: 13px; border-radius: 5px;
            border: 1px solid var(--app-border-dark); background-color: var(--app-surface-dark);
            color: var(--app-text-primary-dark-theme); box-sizing: border-box; margin-bottom: 12px;
        }
        .accordion-content input[type="color"] { width: 100%; padding: 2px; height: 38px; }
        .accordion-content input[type="range"] { padding: 0; }
        .accordion-content input[type="file"] { display: none; }
        .custom-file-input-wrapper {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 12px;
            width: 100%;
        }
        .custom-file-button {
            padding: 8px 16px;
            background-color: var(--app-accent-primary);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        .custom-file-button:hover {
            background-color: var(--app-accent-primary-hover);
        }
        .custom-file-status {
            color: var(--app-text-secondary-dark-theme);
            font-size: 13px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .accordion-content label.checkbox-label { display: flex; align-items: center; font-size: 13px; font-weight: 400; margin-bottom: 12px; cursor: pointer; color: var(--app-text-secondary-dark-theme); }
        .accordion-content input[type="checkbox"] { width: auto; margin-right: 8px; vertical-align: middle; accent-color: var(--app-accent-primary); }
        .accordion-content button {
            background-color: var(--app-surface-dark); color: var(--app-text-primary-dark-theme); border: 1px solid var(--app-border-dark);
            font-weight: 500; width: 100%; padding: 8px 12px; font-size: 13px; border-radius: 5px; margin-top: 5px; cursor: pointer;
        }
        .prepositions-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
        
        /* -- NEW Styles for Image Selection Grids -- */
        .dictionary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(75px, 1fr));
            gap: 12px;
            align-content: flex-start;
            border: 1px solid var(--app-border-dark);
            min-height: 120px;
            max-height: 180px;
            overflow-y: auto;
            background: var(--app-surface-dark);
            padding: 8px !important;
            border-radius: 5px;
            font-size: 13px;
        }
        .dictionary-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            padding: 4px;
            border: 1px solid transparent;
            border-radius: 5px;
            height: auto;
            transition: background-color 0.15s ease, border-color 0.15s ease;
            gap: 0; /* Override previous gap */
        }
        .dictionary-item.selected {
            border-color: var(--app-accent-primary);
            background-color: rgba(0, 122, 255, 0.1);
            color: white;
        }
        .dictionary-item:hover {
            background-color: rgba(255, 255, 255, 0.05);
            color: var(--app-text-primary-dark-theme);
        }
        .dictionary-item img {
            width: 50px;
            height: 50px;
            object-fit: contain;
            border: 1px solid var(--app-border-dark);
            background-color: var(--app-surface-light);
            border-radius: 3px;
            margin-bottom: 5px;
        }
        .dictionary-item span {
            font-size: 11px;
            line-height: 1.2;
            word-break: break-word;
            max-width: 100%;
            color: var(--app-text-secondary-dark-theme);
        }
        .dictionary-item.selected span {
            color: var(--app-text-primary-dark-theme);
        }

        #borderDictionary, #backgroundDictionary { display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start; border: 1px solid var(--app-border-dark); min-height: 120px; max-height: 180px; overflow-y: auto; background: var(--app-surface-dark); padding: 8px; border-radius: 5px; }
        .dictionary-message { width: 100%; text-align: center; padding: 10px; font-size:12px; color: var(--app-text-secondary-dark-theme); margin: auto; }
        .border-thumbnail-item { cursor: pointer; border: 2px solid transparent; border-radius: 4px; padding: 2px; transition: border-color .15s ease; width: 60px; height: 60px; }
        .border-thumbnail-item:hover, .border-thumbnail-item.selected { border-color: var(--app-accent-primary); }
        .border-thumbnail-item img { width: 100%; height: 100%; object-fit: contain; background-color: var(--app-surface-light); border-radius: 2px; }
        .panel-footer { padding: 15px 25px; border-top: 1px solid var(--app-border-dark); margin-top: auto; background-color: var(--app-bg-dark); }
        #message { padding:10px 15px; border-radius:5px; font-size:13px; text-align:center; min-height:20px; font-weight:500; display:none; margin-bottom: 0; border: 1px solid; }
        #message.error { background-color:rgba(255, 59, 48, 0.2); color: var(--app-accent-danger); border-color: var(--app-accent-danger);}
        #message.success { background-color:rgba(52, 199, 89, 0.2); color: #34c759; border-color: #34c759;}
        #message.info { background-color:rgba(0, 122, 255, 0.15); color:var(--app-accent-primary); border-color: var(--app-accent-primary);}
        .main { flex-grow: 1; display: flex; flex-direction: column; position: relative; overflow: hidden; padding: 0; background: var(--app-bg-light); }
        .menu-toggle-btn { display: none; position: absolute; top: 12px; left: 20px; z-index: 20; background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light); border-radius: 6px; width: 38px; height: 38px; font-size: 18px; cursor: pointer; align-items: center; justify-content: center; }
        .menu-toggle-btn:hover { background-color: #e8e8ed; }
        .menu-close-btn { display: none; background: none; border: none; color: var(--app-text-secondary-dark-theme); font-size: 28px; line-height: 1; cursor: pointer; padding: 0 5px; }
        .menu-close-btn:hover { color: var(--app-text-primary-dark-theme); }
        .menu-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); z-index: 999; }
        .menu-overlay.is-active { display: block; }
        .top-right-actions { position: absolute; top: 12px; right: 20px; z-index: 20; display: flex; gap: 10px; align-items: center; }
        .top-right-actions .action-button { padding: 7px 14px; font-size: 13px; font-weight: 500; border-radius: 6px; border: none; color: white; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; }
        .top-right-actions .action-button:active { transform: scale(0.98); }
        .top-right-actions .action-button.accent { background-color: var(--app-accent-primary); }
        .top-right-actions .action-button.accent:hover { background-color: var(--app-accent-primary-hover); }
        .top-right-actions .action-button.danger { background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light); }
        .top-right-actions .action-button.danger:hover { background-color: #e8e8ed; }
        .top-right-actions .action-button.secondary { background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light); }
        .top-right-actions .action-button.secondary:hover { background-color: #e8e8ed; }
        .top-right-actions .action-button:disabled { background-color: #cccccc !important; color: #888888 !important; border-color: #cccccc !important; cursor: not-allowed; transform: none; }
        .dropdown-container { position: relative; display: inline-block; }
        .dropdown-content { display: none; position: absolute; right: 0; top: calc(100% + 5px); background-color: var(--app-surface-light); min-width: 200px; box-shadow: 0px 5px 15px rgba(0,0,0,0.15); border: 1px solid var(--app-border-light); border-radius: 6px; padding: 8px; z-index: 25; }
        .dropdown-content button { width: 100%; padding: 8px 12px; font-size: 13px; border-radius: 4px; box-sizing: border-box; margin-bottom: 6px; background-color: transparent; color: var(--app-text-primary-light-theme); border: none; cursor: pointer; text-align: left; font-weight: 400; transition: background-color 0.15s ease; }
        .dropdown-content button:last-of-type { margin-bottom: 0; }
        .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }
        .dropdown-content button:disabled { background-color: transparent !important; color: var(--app-text-secondary-light-theme) !important; opacity: 0.6; cursor: not-allowed; }
        .dropdown-content .checkbox-label { display: flex; align-items: center; font-size: 13px; font-weight: 400; padding: 6px 12px; margin-top: 4px; margin-bottom: 0; cursor: pointer; color: var(--app-text-primary-light-theme); border-radius: 4px; }
        .dropdown-content .checkbox-label:hover { background-color: rgba(0,0,0,0.05); }
        .dropdown-content .checkbox-label input[type="checkbox"] { width: auto; margin-right: 8px; vertical-align: middle; accent-color: var(--app-accent-primary); }
        .tab-row { display: flex; justify-content: flex-start; padding: 0 20px; border-bottom: 1px solid var(--app-border-light); background-color: var(--app-surface-light); margin-top: 60px; }
        .tab-button { padding: 12px 18px; background: transparent; border: none; border-bottom: 2px solid transparent; color: var(--app-text-secondary-light-theme); font-size: 14px; font-weight: 500; cursor: pointer; transition: color 0.2s ease, border-color 0.2s ease; margin-bottom: -1px; }
        .tab-button:hover { color: var(--app-text-primary-light-theme); }
        .tab-button.active { color: var(--app-accent-primary); border-bottom: 2px solid var(--app-accent-primary); }
        .tab-content-wrapper { flex-grow: 1; display: flex; align-items: flex-start; justify-content: center; padding: 70px 25px 25px 25px; overflow-y: auto; }
        .tab { display: none; width: 100%; margin: 0 auto; }
        .tab.active { display: flex; flex-direction: column; align-items: center; }
        .canvas-container-wrapper { border: 1px solid var(--app-border-light); background-color: var(--app-surface-light); box-shadow: 0 4px 12px rgba(0,0,0,0.1); border-radius: 8px; overflow: visible; margin: auto; position: relative; }
        /* Ensure Fabric.js container doesn't clip */
        .canvas-container { overflow: visible !important; position: relative !important; }
        canvas { display: block; }
        @media (max-width: 1024px) {
            .panel { position: fixed; top: 0; left: 0; height: 100vh; transform: translateX(-100%); }
            .panel.is-open { transform: translateX(0); }
            .menu-toggle-btn { display: flex; }
            .menu-close-btn { display: block; }
            .tab-row { padding-left: 70px; }
        }
        #object-context-toolbar { position: absolute; top: 72px; left: 50%; transform: translateX(-50%); background-color: var(--app-surface-light); border-radius: 6px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); padding: 5px; display: flex; gap: 4px; z-index: 100; align-items: center; border: 1px solid var(--app-border-light); }
        .toolbar-group { display: flex; gap: 2px; align-items: center; padding: 0 4px; }
        .toolbar-group + .toolbar-group { border-left: 1px solid var(--app-border-light); }
        .toolbar-item { position: relative; }
        .context-btn { background: none; border: 1px solid transparent; border-radius: 4px; padding: 5px 7px; cursor: pointer; font-size: 15px; color: var(--app-text-secondary-light-theme); line-height: 1; display: flex; align-items: center; justify-content: center; min-width: 32px; transition: background-color 0.2s, color 0.2s; }
        .context-btn:disabled { color: #c5c5c7; cursor: not-allowed; }
        .context-btn:not(:disabled):hover { background-color: #e8e8ed; color: var(--app-text-primary-light-theme); }
        #toolbarDeleteBtn:not(:disabled) { color: var(--app-accent-danger); }
        #object-context-toolbar .dropdown-content { display: none; position: absolute; top: calc(100% + 5px); left: 50%; transform: translateX(-50%); background-color: var(--app-surface-light); min-width: 150px; box-shadow: 0px 5px 15px rgba(0,0,0,0.15); border: 1px solid var(--app-border-light); border-radius: 6px; padding: 8px; z-index: 101; }
        #object-context-toolbar .dropdown-content button { width: 100%; padding: 8px 12px; font-size: 13px; border-radius: 4px; box-sizing: border-box; margin-bottom: 6px; background-color: transparent; color: var(--app-text-primary-light-theme); border: none; cursor: pointer; text-align: left; font-weight: 400; transition: background-color 0.15s ease; }
        #object-context-toolbar .dropdown-content button:last-of-type { margin-bottom: 0; }
        #object-context-toolbar .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }

        /* Hide scrollbars but keep functionality */
        .panel-content::-webkit-scrollbar,
        .tab-content-wrapper::-webkit-scrollbar,
        .canvas-container-wrapper::-webkit-scrollbar,
        .dictionary-grid::-webkit-scrollbar,
        #borderDictionary::-webkit-scrollbar, 
        #backgroundDictionary::-webkit-scrollbar {
            display: none;
        }

        .panel-content,
        .tab-content-wrapper,
        .canvas-container-wrapper,
        .dictionary-grid,
        #borderDictionary,
        #backgroundDictionary {
            -ms-overflow-style: none;  /* IE and Edge */
            scrollbar-width: none;  /* Firefox */
        }

        /* ============================================
           MODERN UNIFIED HEADER STYLES
           Exact implementation from wordsearch.html lines 251-450
           ============================================ */

        .tab-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
            position: relative;
            z-index: 15;
            border-radius: 0;
            margin: 0;
            gap: 16px;
        }

        .tab-buttons-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .tab-button {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 600;
            border: none;
            background: rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.8);
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
            position: relative;
        }

        .tab-button:hover {
            background: rgba(255, 255, 255, 0.25);
            color: white;
            transform: translateY(-1px);
        }

        .tab-button.active {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Header Actions Container */
        .header-actions {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }

        /* --- Zoom Controls --- */
        .zoom-controls {
            display: flex;
            align-items: center;
            gap: 8px;
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 6px;
            padding: 5px 10px;
            backdrop-filter: blur(10px);
        }

        .zoom-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            color: white;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .zoom-btn:active {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .zoom-percentage {
            min-width: 45px;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            color: white;
            user-select: none;
        }

        /* --- Undo/Redo Controls --- */
        .history-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            background-color: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 6px;
            padding: 5px 10px;
            backdrop-filter: blur(10px);
        }

        .history-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 14px;
            cursor: pointer;
            color: white;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .history-btn:hover:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .history-btn:active:not(:disabled) {
            background-color: rgba(255, 255, 255, 0.15);
        }

        .history-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* --- Dropdown Containers --- */
        .dropdown-container {
            position: relative;
            display: inline-block;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            right: 0;
            background-color: white;
            min-width: 200px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            border-radius: 8px;
            z-index: 1000;
            margin-top: 8px;
            padding: 8px 0;
        }

        .dropdown-content.show {
            display: block;
        }

        .dropdown-content button {
            display: block;
            width: 100%;
            padding: 10px 16px;
            border: none;
            background: none;
            text-align: left;
            cursor: pointer;
            font-size: 14px;
            color: #333;
            transition: background-color 0.2s;
        }

        .dropdown-content button:hover:not(:disabled) {
            background-color: #f5f5f5;
        }

        .dropdown-content button:disabled {
            color: #ccc;
            cursor: not-allowed;
        }

        /* --- Action Buttons --- */
        .action-button {
            padding: 8px 16px;
            font-size: 13px;
            font-weight: 500;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .action-button.accent {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .action-button.accent:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .action-button.download-btn {
            background: rgba(255, 255, 255, 0.95);
            color: #667eea;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        .action-button.download-btn:hover {
            background: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .action-button.danger {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .action-button.danger:hover {
            background: rgba(255, 59, 48, 0.9);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
        }
    </style>
</head>
<body>
    <div class="layout">
        <div id="menuOverlay" class="menu-overlay"></div>
        <div class="panel" id="main-panel">
            <div class="panel-header">
                <h2 data-translate="prepositions_title">Prepositions</h2>
                <button id="menuCloseBtn" class="menu-close-btn">&times;</button>
            </div>
            <div style="padding: 10px 15px; border-bottom: 1px solid var(--app-border-dark);">
                <label for="languageSelect" style="color: var(--app-text-secondary-dark-theme); font-size: 12px; display: block; margin-bottom: 5px;" data-translate="language">Language</label>
                <select id="languageSelect" style="width: 100%; padding: 6px; font-size: 13px; border-radius: 5px; border: 1px solid var(--app-border-dark); background-color: var(--app-surface-dark); color: var(--app-text-primary-dark-theme);">
                    <option value="en" data-translate="language.english">English</option>
                    <option value="de" data-translate="language.german">Deutsch</option>
                    <option value="fr" data-translate="language.french">Français</option>
                    <option value="es" data-translate="language.spanish">Español</option>
                    <option value="pt" data-translate="language.portuguese">Português</option>
                    <option value="it" data-translate="language.italian">Italiano</option>
                    <option value="nl" data-translate="language.dutch">Nederlands</option>
                    <option value="sv" data-translate="language.swedish">Svenska</option>
                    <option value="da" data-translate="language.danish">Dansk</option>
                    <option value="no" data-translate="language.norwegian">Norsk</option>
                    <option value="fi" data-translate="language.finnish">Suomi</option>
                </select>
                <p style="font-size: 12px; color: var(--app-text-secondary-dark-theme); margin-top: 10px;" data-translate="prepositions.language.description">
                    Selects the language for image library content only. UI language is controlled by the main language selector in the header.
                </p>
            </div>
            <div class="panel-content">
                <div class="accordion-item">
                    <button class="accordion-button active" data-translate="page_setup">Page Setup</button>
                    <div class="accordion-content active">
                        <label for="pageSizeSelect" data-translate="paper_size">Paper Size:</label>
                        <select id="pageSizeSelect">
                            <option value="612x792" data-translate="page.size.letter.portrait">Letter Portrait (8.5×11")</option>
                            <option value="792x612" data-translate="page.size.letter.landscape">Letter Landscape (11×8.5")</option>
                            <option value="595x842" data-translate="page.size.a4.portrait">A4 Portrait (210×297mm)</option>
                            <option value="842x595" data-translate="page.size.a4.landscape">A4 Landscape (297×210mm)</option>
                            <option value="1200x1200" data-translate="page.size.square">Square (1200×1200)</option>
                            <option value="custom" data-translate="page.size.custom">Custom</option>
                        </select>
                        <div id="customPageSizeInputs" style="display:none; margin-top: 8px;">
                            <label for="pageWidth" data-translate="width_px">Width (px):</label>
                            <input type="number" id="pageWidth" value="792">
                            <label for="pageHeight" data-translate="height_px">Height (px):</label>
                            <input type="number" id="pageHeight" value="612">
                        </div>
                        <button id="setPageSizeBtn" style="margin-top: 8px;" data-translate="apply_size">Apply Size</button>
                        
                        <h4 style="margin-top:15px;" data-translate="template">Template</h4>
                        <label for="templateSelect" data-translate="prepositions.template.label">Worksheet Template:</label>
                        <select id="templateSelect"></select>

                        <label for="pageColor" style="margin-top:10px;" data-translate="prepositions.page.color">Page Color:</label>
                        <input type="color" id="pageColor" value="#FFFFFF">
                        <h4 data-translate="prepositions.background.title">Background</h4>
                        <label for="backgroundThemeSelect" data-translate="prepositions.background.theme">Background Theme:</label>
                        <select id="backgroundThemeSelect">
                            <option value="none" data-translate="none">None</option>
                        </select>
                        <label for="backgroundOpacity" data-translate="prepositions.background.opacity">Background Opacity:</label>
                        <input type="range" id="backgroundOpacity" min="0" max="1" value="1" step="0.05">
                        <div id="backgroundDictionary"><p class="dictionary-message" data-translate="prepositions.background.message">Select a theme for backgrounds.</p></div>
                        <h4 data-translate="prepositions.border.title">Border</h4>
                        <label for="borderThemeSelect" data-translate="prepositions.border.theme">Border Theme:</label>
                        <select id="borderThemeSelect"><option value="none" data-translate="none">None</option></select>
                        <label for="borderOpacity" data-translate="prepositions.border.opacity">Border Opacity:</label>
                        <input type="range" id="borderOpacity" min="0" max="1" value="1" step="0.05">
                        <div id="borderDictionary"><p class="dictionary-message" data-translate="prepositions.border.message">Select a theme to see borders.</p></div>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-button" data-translate="text_tools">Text Tools</button>
                    <div class="accordion-content">
                        <h4 data-translate="prepositions.text.add.new">Add New Text</h4>
                        <label for="textInput" data-translate="prepositions.text.content">Content:</label><input type="text" id="textInput" data-translate-placeholder="prepositions.text.placeholder" placeholder="Worksheet Title...">
                        <button id="addTextBtn" data-translate="prepositions.text.add.button">Add Text to Worksheet</button>
                        <h4 data-translate="prepositions.text.properties">Selected Text Properties</h4>
                        <label for="textColor" data-translate="prepositions.text.color">Color:</label><input type="color" id="textColor" value="#333333" disabled>
                        <label for="fontSize" data-translate="prepositions.text.size">Size:</label><input type="number" id="fontSize" value="36" min="8" disabled>
                        <label for="fontFamily" data-translate="prepositions.text.font">Font:</label>
                        <select id="fontFamily" disabled>
                            <option value="Lexend Deca" data-translate="font.lexend">Lexend Deca</option>
                            <option value="Baloo 2" data-translate="font.baloo">Baloo 2</option>
                            <option value="Nunito" data-translate="font.nunito">Nunito</option>
                            <option value="Quicksand" data-translate="font.quicksand">Quicksand</option>
                            <option value="Fredoka" data-translate="font.fredoka">Fredoka</option>
                            <option value="Arial" data-translate="font.arial">Arial</option>
                            <option value="Verdana" data-translate="font.verdana">Verdana</option>
                        </select>
                        <label for="textStrokeColor" data-translate="prepositions.text.outline.color">Outline Color:</label><input type="color" id="textStrokeColor" value="#000000" disabled>
                        <label for="textStrokeWidth" data-translate="prepositions.text.outline.width">Outline (0-10):</label><input type="range" id="textStrokeWidth" min="0" max="10" value="0" step="0.5" disabled>
                    </div>
                </div>
                 <div class="accordion-item">
                    <button class="accordion-button" data-translate="configuration">Configuration</button>
                    <div class="accordion-content">
                        <label for="exerciseModeSelect" data-translate="prepositions.exercise.mode">Exercise Mode:</label>
                        <select id="exerciseModeSelect">
                            <option value="fillin" data-translate="prepositions.mode.fillin">Fill-in-the-Blank</option>
                            <option value="multiplechoice" data-translate="prepositions.mode.multiplechoice">Multiple Choice</option>
                        </select>
                        <label for="exerciseCount" data-translate="prepositions.exercises.count">Number of Exercises (1-8):</label>
                        <input type="number" id="exerciseCount" value="8" min="1" max="8">
                        <h4 data-translate="prepositions.select.prepositions">Select Prepositions</h4>
                        <div id="prepositionsGrid" class="prepositions-grid"></div>
                        <label for="includeNameDateCheckbox" class="checkbox-label" style="margin-top: 15px;">
                            <input type="checkbox" id="includeNameDateCheckbox" /><span data-translate="prepositions.include.name.date">Include Name/Date Fields</span>
                        </label>
                    </div>
                </div>

                <div class="accordion-item">
                    <button class="accordion-button" data-translate="item_selection">Item Selection</button>
                    <div class="accordion-content">
                         <label for="itemThemeSelect" data-translate="prepositions.generation.mode">Generation Mode:</label>
                        <select id="itemThemeSelect">
                            <option value="manual" data-translate="prepositions.manual.selection.option">Manual Selection</option>
                            <option value="all" data-translate="prepositions.all.themes.option">All Themes</option>
                        </select>
                        <div id="itemManualSelectionGroup">
                            <label for="themeSelect" data-translate="prepositions.image.theme">Image Theme:</label>
                            <select id="themeSelect"></select>
                            <input type="text" id="searchInput" data-translate-placeholder="prepositions.search.items.placeholder" placeholder="Search item images..." />
                            <div class="dictionary-grid" id="dictionary"><p class="dictionary-message" data-translate="prepositions.loading.themes">Loading themes...</p></div>
                            <p id="selectedCount" style="text-align:right; font-size:12px; margin-top:5px; color: var(--app-text-secondary-dark-theme);" data-translate="prepositions.selected.count">Selected: 0/8</p>
                        </div>
                    </div>
                </div>
                
                <div class="accordion-item">
                    <button class="accordion-button" data-translate="shape_replacement">Shape Replacement</button>
                    <div class="accordion-content">
                        <label for="shapeThemeSelect" data-translate="prepositions.generation.mode">Generation Mode:</label>
                        <select id="shapeThemeSelect">
                            <option value="manual" data-translate="prepositions.manual.shape.selection">Manual Shape Selection</option>
                            <option value="all" data-translate="prepositions.all.themes.option">All Themes</option>
                        </select>
                        <div id="shapeManualSelectionGroup">
                            <label for="shapeImageThemeSelect" data-translate="prepositions.shape.theme">Shape Image Theme:</label>
                            <select id="shapeImageThemeSelect"></select>
                            <input type="text" id="shapeSearchInput" data-translate-placeholder="prepositions.search.shapes.placeholder" placeholder="Search shape images..." />
                            <div class="dictionary-grid" id="shapeDictionary"><p class="dictionary-message" data-translate="prepositions.loading.themes">Loading themes...</p></div>
                            <p id="selectedShapesCount" style="text-align:right; font-size:12px; margin-top:5px; color: var(--app-text-secondary-dark-theme);" data-translate="prepositions.shape.selected.count">Selected: 0/8</p>
                        </div>
                    </div>
                </div>
                
                <div class="accordion-item">
                    <button class="accordion-button" data-translate="upload_custom_images">Upload Custom Images</button>
                    <div class="accordion-content">
                        <label for="imageUploadInput" data-translate="prepositions.upload.select">Select image(s) to upload:</label>
                        <div class="custom-file-input-wrapper">
                            <button type="button" class="custom-file-button" id="customFileButton" data-translate="prepositions.upload.button">Choose files</button>
                            <span class="custom-file-status" id="customFileStatus" data-translate="prepositions.upload.no.file">No file chosen</span>
                        </div>
                        <input type="file" id="imageUploadInput" multiple accept="image/*">
                        <label style="margin-top:10px;" data-translate="prepositions.uploaded.images">Your Uploaded Images:</label>
                        <div class="dictionary-grid" id="uploadedImagesPreview"><p class="dictionary-message" data-translate="prepositions.uploaded.placeholder">Your uploaded images will appear here.</p></div>
                    </div>
                </div>

            </div>
            <div class="panel-footer">
                <div id="message"></div>
            </div>
        </div>
        <div class="main">
            <button id="menuToggleBtn" class="menu-toggle-btn"><i class="fas fa-bars"></i></button>
            
            <div id="object-context-toolbar" style="display:none;">
                <div class="toolbar-group">
                    <div class="toolbar-item">
                        <button class="context-btn" id="layersBtn" data-translate-title="toolbar.layers" title="Layers"><i class="fas fa-layer-group"></i></button>
                        <div class="dropdown-content" id="layersDropdown">
                            <button id="toolbarBringToFrontBtn" data-translate="bringToFront">Bring to Front</button>
                            <button id="toolbarBringForwardBtn" data-translate="bringForward">Bring Forward</button>
                            <button id="toolbarSendBackwardBtn" data-translate="sendBackward">Send Backward</button>
                            <button id="toolbarSendToBackBtn" data-translate="sendToBack">Send to Back</button>
                        </div>
                    </div>
                </div>
                <div class="toolbar-group">
                    <div class="toolbar-item">
                        <button class="context-btn" id="alignBtn" data-translate-title="toolbar.align" title="Align"><i class="fas fa-th"></i></button>
                        <div class="dropdown-content" id="alignDropdown" style="min-width: 220px; padding: 12px;">
                            <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.align.selected">Align Selected:</p>
                            <div><button class="context-btn" id="alignLeftBtn" data-translate-title="toolbar.align.left" title="Align Left"><i class="fas fa-align-left"></i></button><button class="context-btn" id="alignHCenterBtn" data-translate-title="toolbar.center.h" title="Center Horizontally"><i class="fas fa-align-center"></i></button><button class="context-btn" id="alignRightBtn" data-translate-title="toolbar.align.right" title="Align Right"><i class="fas fa-align-right"></i></button></div>
                            <div style="margin-top: 5px;"><button class="context-btn" id="alignTopBtn" data-translate-title="toolbar.align.top" title="Align Top"><i class="fas fa-long-arrow-alt-up"></i></button><button class="context-btn" id="alignVCenterBtn" data-translate-title="toolbar.center.v" title="Center Vertically"><i class="fas fa-grip-lines"></i></button><button class="context-btn" id="alignBottomBtn" data-translate-title="toolbar.align.bottom" title="Align Bottom"><i class="fas fa-long-arrow-alt-down"></i></button></div>
                            <hr style="margin:8px 0; border:none; border-top:1px solid #eee;">
                            <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.align.to.page">Align to Page:</p>
                            <div><button class="context-btn" id="centerHCanvasBtn" data-translate-title="toolbar.center.page.h" title="Center on Page Horizontally"><i class="fas fa-arrows-alt-h"></i></button><button class="context-btn" id="centerVCanvasBtn" data-translate-title="toolbar.center.page.v" title="Center on Page Vertically"><i class="fas fa-arrows-alt-v"></i></button></div>
                        </div>
                    </div>
                </div>
                <div class="toolbar-group">
                    <button class="context-btn" id="toolbarDeleteBtn" data-translate-title="toolbar.delete" title="Delete Selected"><i class="fas fa-trash-alt"></i></button>
                </div>
            </div>

            <div class="tab-row">
                <div class="tab-buttons-container">
                    <button class="tab-button active" data-tab="worksheetTab" data-translate="prepositions.tab.worksheet">Worksheet</button>
                    <button class="tab-button" data-tab="answerKeyTab" data-translate="prepositions.tab.answer">Answer Key</button>
                </div>
                <div class="header-actions">
                    <div class="zoom-controls">
                        <button id="zoomOutBtn" class="zoom-btn" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
                        <span id="zoomPercentage" class="zoom-percentage">100%</span>
                        <button id="zoomInBtn" class="zoom-btn" title="Zoom In"><i class="fas fa-search-plus"></i></button>
                        <button id="zoomResetBtn" class="zoom-btn" title="Reset Zoom"><i class="fas fa-compress-arrows-alt"></i></button>
                    </div>
                    <div class="history-controls">
                        <button id="undoBtn" class="history-btn" title="Undo (Ctrl+Z)" disabled><i class="fas fa-undo"></i></button>
                        <button id="redoBtn" class="history-btn" title="Redo (Ctrl+Y)" disabled><i class="fas fa-redo"></i></button>
                    </div>
                    <div class="dropdown-container">
                        <button id="generateDropdownBtn" class="action-button accent"><span data-translate="generate">Generate</span> <i class="fas fa-caret-down"></i></button>
                        <div id="generateDropdownContent" class="dropdown-content">
                            <button id="generateWorksheetBtn" data-translate="generate_worksheet">New Worksheet</button>
                            <button id="generateAnswerKeyBtn" disabled data-translate="generate_answer_key">Answer Key</button>
                        </div>
                    </div>
                    <div class="dropdown-container">
                        <button id="downloadDropdownBtn" class="action-button download-btn"><span data-translate="prepositions.download">Download</span> <i class="fas fa-caret-down" style="margin-left: 5px;"></i></button>
                        <div id="downloadDropdownContent" class="dropdown-content">
                            <button id="downloadWsJpegBtn" disabled data-translate="prepositions.download.worksheet.jpeg">Worksheet (JPEG)</button>
                            <button id="downloadAkJpegBtn" disabled data-translate="prepositions.download.answer.jpeg">Answer Key (JPEG)</button>
                            <hr style="margin: 6px 0; border-color: #eee;">
                            <button id="downloadWsPdfBtn" disabled data-translate="prepositions.download.worksheet.pdf">Worksheet (PDF)</button>
                            <button id="downloadAkPdfBtn" disabled data-translate="prepositions.download.answer.pdf">Answer Key (PDF)</button>
                            <hr style="margin: 6px 0; border-color: #eee;">
                            <label class="checkbox-label" id="grayscaleLabel">
                                <input type="checkbox" id="grayscaleToggle" /><span data-translate="common.grayscale">Grayscale</span>
                            </label>
                        </div>
                    </div>
                    <button id="clearBtn" class="action-button danger" data-translate="prepositions.clear.all">Clear All</button>
                </div>
            </div>
            <div class="tab-content-wrapper">
                <div class="tab active" id="worksheetTab"><div class="canvas-container-wrapper" id="worksheetCanvasWrapper"><canvas id="worksheetCanvasElement"></canvas></div></div>
                <div class="tab" id="answerKeyTab"><div class="canvas-container-wrapper" id="answerKeyCanvasWrapper"><canvas id="answerKeyCanvasElement"></canvas></div></div>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <script>
        // Set locale variables globally BEFORE DOMContentLoaded
        let uiLocale = 'en';  // UI language (for interface translations) - from URL parameter
        let currentLocale = 'en';  // Content language (for image library) - can be changed by sidebar selector
        const urlParams = new URLSearchParams(window.location.search);
        const localeParam = urlParams.get('locale');
        if (localeParam) {
            uiLocale = localeParam;  // UI language comes from URL (parent app header)
            currentLocale = localeParam;  // Initial content language matches UI language
        }
        window.uiLocale = uiLocale;
        window.currentLocale = currentLocale;
        console.log('[Prepositions] UI locale set to:', uiLocale);
        console.log('[Prepositions] Content locale set to:', currentLocale);

        // Translation function with parameter substitution
        function t(key, params = {}) {
            if (typeof translations === 'undefined') {
                console.warn('Translations not loaded:', key);
                return key;
            }
            // Use uiLocale for UI translations, fallback to currentLocale, then to English
            const locale = window.uiLocale || window.currentLocale || 'en';
            let text = translations[locale]?.[key] || translations.en?.[key] || key;

            // Replace parameters like {count}, {theme}, {type}, etc.
            Object.keys(params).forEach(param => {
                text = text.replace(new RegExp(`\\{${param}\\}`, 'g'), params[param]);
            });

            return text;
        }

        // Apply translations function
        function applyTranslations() {
            document.querySelectorAll('[data-translate]').forEach(el => {
                const key = el.getAttribute('data-translate');
                if (key) el.textContent = t(key);
            });
            document.querySelectorAll('[data-translate-placeholder]').forEach(el => {
                const key = el.getAttribute('data-translate-placeholder');
                if (key) el.placeholder = t(key);
            });
        }
    </script>

    <script>
        // --- App-Specific Constants ---
        const DEFAULT_SHAPES = ['circle', 'cube', 'cylinder', 'heart', 'hexagon', 'square', 'star', 'triangle'];
        const PREPOSITIONS = ['in', 'on top of', 'under', 'next to', 'behind', 'between', 'above', 'in front of'];
        
        // --- Preposition Translations ---
        const PREPOSITION_TRANSLATIONS = {
            'in': {
                'en': 'in', 'de': 'in', 'fr': 'dans', 'es': 'en', 'pt': 'em',
                'it': 'in', 'nl': 'in', 'sv': 'i', 'da': 'i', 'no': 'i', 'fi': 'sisällä'
            },
            'on top of': {
                'en': 'on top of', 'de': 'auf', 'fr': 'sur', 'es': 'encima de', 'pt': 'em cima de',
                'it': 'sopra', 'nl': 'bovenop', 'sv': 'ovanpå', 'da': 'ovenpå', 'no': 'oppå', 'fi': 'päällä'
            },
            'under': {
                'en': 'under', 'de': 'unter', 'fr': 'sous', 'es': 'debajo de', 'pt': 'embaixo de',
                'it': 'sotto', 'nl': 'onder', 'sv': 'under', 'da': 'under', 'no': 'under', 'fi': 'alla'
            },
            'next to': {
                'en': 'next to', 'de': 'neben', 'fr': 'à côté de', 'es': 'al lado de', 'pt': 'ao lado de',
                'it': 'accanto a', 'nl': 'naast', 'sv': 'bredvid', 'da': 'ved siden af', 'no': 'ved siden av', 'fi': 'vieressä'
            },
            'behind': {
                'en': 'behind', 'de': 'hinter', 'fr': 'derrière', 'es': 'detrás de', 'pt': 'atrás de',
                'it': 'dietro', 'nl': 'achter', 'sv': 'bakom', 'da': 'bag', 'no': 'bak', 'fi': 'takana'
            },
            'between': {
                'en': 'between', 'de': 'zwischen', 'fr': 'entre', 'es': 'entre', 'pt': 'entre',
                'it': 'tra', 'nl': 'tussen', 'sv': 'mellan', 'da': 'mellem', 'no': 'mellom', 'fi': 'välissä'
            },
            'above': {
                'en': 'above', 'de': 'über', 'fr': 'au-dessus de', 'es': 'sobre', 'pt': 'acima de',
                'it': 'sopra', 'nl': 'boven', 'sv': 'ovanför', 'da': 'over', 'no': 'over', 'fi': 'yläpuolella'
            },
            'in front of': {
                'en': 'in front of', 'de': 'vor', 'fr': 'devant', 'es': 'delante de', 'pt': 'na frente de',
                'it': 'davanti a', 'nl': 'voor', 'sv': 'framför', 'da': 'foran', 'no': 'foran', 'fi': 'edessä'
            }
        };
        
        // --- Exercise text translations ---
        const EXERCISE_TRANSLATIONS = {
            'is': {
                'en': 'is', 'de': 'ist', 'fr': 'est', 'es': 'está', 'pt': 'está',
                'it': 'è', 'nl': 'is', 'sv': 'är', 'da': 'er', 'no': 'er', 'fi': 'on'
            },
            'the': {
                'en': 'the', 'de': 'dem', 'fr': 'le/la', 'es': 'el/la', 'pt': 'o/a',
                'it': 'il/la', 'nl': 'de', 'sv': 'den', 'da': 'den', 'no': 'den', 'fi': '-'  // Finnish doesn't use articles
            }
        };

        // --- Shape name translations ---
        const SHAPE_TRANSLATIONS = {
            'circle': {
                'en': 'circle', 'de': 'Kreis', 'fr': 'cercle', 'es': 'círculo', 'pt': 'círculo',
                'it': 'cerchio', 'nl': 'cirkel', 'sv': 'cirkel', 'da': 'cirkel', 'no': 'sirkel', 'fi': 'ympyrä'
            },
            'cube': {
                'en': 'cube', 'de': 'Würfel', 'fr': 'cube', 'es': 'cubo', 'pt': 'cubo',
                'it': 'cubo', 'nl': 'kubus', 'sv': 'kub', 'da': 'terning', 'no': 'terning', 'fi': 'kuutio'
            },
            'cylinder': {
                'en': 'cylinder', 'de': 'Zylinder', 'fr': 'cylindre', 'es': 'cilindro', 'pt': 'cilindro',
                'it': 'cilindro', 'nl': 'cilinder', 'sv': 'cylinder', 'da': 'cylinder', 'no': 'sylinder', 'fi': 'sylinteri'
            },
            'heart': {
                'en': 'heart', 'de': 'Herz', 'fr': 'cœur', 'es': 'corazón', 'pt': 'coração',
                'it': 'cuore', 'nl': 'hart', 'sv': 'hjärta', 'da': 'hjerte', 'no': 'hjerte', 'fi': 'sydän'
            },
            'hexagon': {
                'en': 'hexagon', 'de': 'Sechseck', 'fr': 'hexagone', 'es': 'hexágono', 'pt': 'hexágono',
                'it': 'esagono', 'nl': 'zeshoek', 'sv': 'hexagon', 'da': 'sekskant', 'no': 'sekskant', 'fi': 'kuusikulmio'
            },
            'square': {
                'en': 'square', 'de': 'Quadrat', 'fr': 'carré', 'es': 'cuadrado', 'pt': 'quadrado',
                'it': 'quadrato', 'nl': 'vierkant', 'sv': 'kvadrat', 'da': 'kvadrat', 'no': 'kvadrat', 'fi': 'neliö'
            },
            'star': {
                'en': 'star', 'de': 'Stern', 'fr': 'étoile', 'es': 'estrella', 'pt': 'estrela',
                'it': 'stella', 'nl': 'ster', 'sv': 'stjärna', 'da': 'stjerne', 'no': 'stjerne', 'fi': 'tähti'
            },
            'triangle': {
                'en': 'triangle', 'de': 'Dreieck', 'fr': 'triangle', 'es': 'triángulo', 'pt': 'triângulo',
                'it': 'triangolo', 'nl': 'driehoek', 'sv': 'triangel', 'da': 'trekant', 'no': 'trekant', 'fi': 'kolmio'
            }
        };

        // --- Plural shape translations ---
        // Language-specific plural forms for shapes used in "between" exercises
        const PLURAL_SHAPE_TRANSLATIONS = {
            'circle': {
                'en': 'circles', 'de': 'Kreise', 'fr': 'cercles', 'es': 'círculos', 'pt': 'círculos',
                'it': 'cerchi', 'nl': 'cirkels', 'sv': 'cirklar', 'da': 'cirkler', 'no': 'sirkler', 'fi': 'ympyrät'
            },
            'cube': {
                'en': 'cubes', 'de': 'Würfel', 'fr': 'cubes', 'es': 'cubos', 'pt': 'cubos',
                'it': 'cubi', 'nl': 'kubussen', 'sv': 'kuber', 'da': 'terninger', 'no': 'terninger', 'fi': 'kuutiot'
            },
            'cylinder': {
                'en': 'cylinders', 'de': 'Zylinder', 'fr': 'cylindres', 'es': 'cilindros', 'pt': 'cilindros',
                'it': 'cilindri', 'nl': 'cilinders', 'sv': 'cylindrar', 'da': 'cylindre', 'no': 'sylindere', 'fi': 'sylinterit'
            },
            'heart': {
                'en': 'hearts', 'de': 'Herzen', 'fr': 'cœurs', 'es': 'corazones', 'pt': 'corações',
                'it': 'cuori', 'nl': 'harten', 'sv': 'hjärtan', 'da': 'hjerter', 'no': 'hjerter', 'fi': 'sydämet'
            },
            'hexagon': {
                'en': 'hexagons', 'de': 'Sechsecke', 'fr': 'hexagones', 'es': 'hexágonos', 'pt': 'hexágonos',
                'it': 'esagoni', 'nl': 'zeshoeken', 'sv': 'hexagoner', 'da': 'sekskanter', 'no': 'sekskanter', 'fi': 'kuusikulmiot'
            },
            'square': {
                'en': 'squares', 'de': 'Quadrate', 'fr': 'carrés', 'es': 'cuadrados', 'pt': 'quadrados',
                'it': 'quadrati', 'nl': 'vierkanten', 'sv': 'kvadrater', 'da': 'kvadrater', 'no': 'kvadrater', 'fi': 'neliöt'
            },
            'star': {
                'en': 'stars', 'de': 'Sterne', 'fr': 'étoiles', 'es': 'estrellas', 'pt': 'estrelas',
                'it': 'stelle', 'nl': 'sterren', 'sv': 'stjärnor', 'da': 'stjerner', 'no': 'stjerner', 'fi': 'tähdet'
            },
            'triangle': {
                'en': 'triangles', 'de': 'Dreiecke', 'fr': 'triangles', 'es': 'triángulos', 'pt': 'triângulos',
                'it': 'triangoli', 'nl': 'driehoeken', 'sv': 'trianglar', 'da': 'trekanter', 'no': 'trekanter', 'fi': 'kolmiot'
            }
        };

        // --- Global State ---
        // currentLocale already set globally before this script
        let worksheetCanvas, answerKeyCanvas;
        let lastGeneratedAssignments = null;
        
        let selectedItems = [];
        let selectedShapes = [];
        let uploadedImages = [];
        
        let currentItemThemeImages = [];
        let currentShapeThemeImages = [];

        let manualSelectItemTheme = 'all';
        let manualSelectShapeTheme = 'all';
        
        let currentCanvasConfig = { width: 612, height: 792 }; // Letter Portrait default
        let downloadMultiplier = 6;
        let activePopover = null;
        let userZoomLevel = 1.0; // User-controlled zoom level (100% = 1.0)
        let currentTemplatePath = '';
        let currentBorderImagePath = ''; // Global to store path for re-adding
        let currentBackgroundImagePath = ''; // Global to store path for re-adding

        // --- Undo/Redo State ---
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 50;
        let isGenerating = false;  // Flag to prevent saveState during generation
        let isRestoringState = false;  // Flag to prevent saveState during undo/redo

        // --- DOM Element Caching ---
        // Will be initialized after DOM is ready
        let dom = {};

        // --- Utility Functions ---
        const shuffleArray = (arr) => [...arr].sort(() => 0.5 - Math.random());

        // Language-aware pluralization function for shapes
        const pluralizeShape = (shapeKeyEnglish, locale) => {
            if (!shapeKeyEnglish) return '';

            // Look up the plural form in the translations
            const pluralForm = PLURAL_SHAPE_TRANSLATIONS[shapeKeyEnglish]?.[locale];

            // If found, return it; otherwise fallback to English plural
            return pluralForm || PLURAL_SHAPE_TRANSLATIONS[shapeKeyEnglish]?.['en'] || `${shapeKeyEnglish}s`;
        };
        
        function getActiveCanvas() {
            const activeTab = document.querySelector('.tab.active');
            return activeTab && activeTab.id === 'answerKeyTab' ? answerKeyCanvas : worksheetCanvas;
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', initializeApp);
        
        async function initializeApp() {
            // Initialize DOM elements first - CRITICAL: Must happen before any DOM usage
            dom = {
                panel: document.getElementById('main-panel'),
                menuToggleBtn: document.getElementById('menuToggleBtn'),
                menuCloseBtn: document.getElementById('menuCloseBtn'),
                menuOverlay: document.getElementById('menuOverlay'),
                message: document.getElementById('message'),
                pageSizeSelect: document.getElementById('pageSizeSelect'),
                customPageSizeInputs: document.getElementById('customPageSizeInputs'),
                pageWidth: document.getElementById('pageWidth'),
                pageHeight: document.getElementById('pageHeight'),
                setPageSizeBtn: document.getElementById('setPageSizeBtn'),
                templateSelect: document.getElementById('templateSelect'),
                pageColor: document.getElementById('pageColor'),
                borderThemeSelect: document.getElementById('borderThemeSelect'),
                borderOpacity: document.getElementById('borderOpacity'),
                borderDictionary: document.getElementById('borderDictionary'),
                backgroundThemeSelect: document.getElementById('backgroundThemeSelect'),
                backgroundOpacity: document.getElementById('backgroundOpacity'),
                backgroundDictionary: document.getElementById('backgroundDictionary'),
                textInput: document.getElementById('textInput'),
                addTextBtn: document.getElementById('addTextBtn'),
                textColor: document.getElementById('textColor'),
                fontSize: document.getElementById('fontSize'),
                fontFamily: document.getElementById('fontFamily'),
                textStrokeColor: document.getElementById('textStrokeColor'),
                textStrokeWidth: document.getElementById('textStrokeWidth'),
                itemThemeSelect: document.getElementById('itemThemeSelect'),
                themeSelect: document.getElementById('themeSelect'),
                searchInput: document.getElementById('searchInput'),
                dictionary: document.getElementById('dictionary'),
                selectedCount: document.getElementById('selectedCount'),
                shapeThemeSelect: document.getElementById('shapeThemeSelect'),
                shapeImageThemeSelect: document.getElementById('shapeImageThemeSelect'),
                shapeSearchInput: document.getElementById('shapeSearchInput'),
                shapeDictionary: document.getElementById('shapeDictionary'),
                selectedShapesCount: document.getElementById('selectedShapesCount'),
                itemManualSelectionGroup: document.getElementById('itemManualSelectionGroup'),
                shapeManualSelectionGroup: document.getElementById('shapeManualSelectionGroup'),
                imageUploadInput: document.getElementById('imageUploadInput'),
                uploadedImagesPreview: document.getElementById('uploadedImagesPreview'),
                customFileButton: document.getElementById('customFileButton'),
                customFileStatus: document.getElementById('customFileStatus'),
                includeNameDateCheckbox: document.getElementById('includeNameDateCheckbox'),
                exerciseModeSelect: document.getElementById('exerciseModeSelect'),
                exerciseCount: document.getElementById('exerciseCount'),
                prepositionsGrid: document.getElementById('prepositionsGrid'),
                generateDropdownBtn: document.getElementById('generateDropdownBtn'),
                generateDropdownContent: document.getElementById('generateDropdownContent'),
                generateWorksheetBtn: document.getElementById('generateWorksheetBtn'),
                generateAnswerKeyBtn: document.getElementById('generateAnswerKeyBtn'),
                downloadDropdownBtn: document.getElementById('downloadDropdownBtn'),
                downloadDropdownContent: document.getElementById('downloadDropdownContent'),
                downloadWsJpegBtn: document.getElementById('downloadWsJpegBtn'),
                downloadAkJpegBtn: document.getElementById('downloadAkJpegBtn'),
                downloadWsPdfBtn: document.getElementById('downloadWsPdfBtn'),
                downloadAkPdfBtn: document.getElementById('downloadAkPdfBtn'),
                grayscaleToggle: document.getElementById('grayscaleToggle'),
                clearBtn: document.getElementById('clearBtn'),
                worksheetCanvasWrapper: document.getElementById('worksheetCanvasWrapper'),
                answerKeyCanvasWrapper: document.getElementById('answerKeyCanvasWrapper'),
                objectContextToolbar: document.getElementById('object-context-toolbar'),
                layersBtn: document.getElementById('layersBtn'),
                layersDropdown: document.getElementById('layersDropdown'),
                toolbarBringToFrontBtn: document.getElementById('toolbarBringToFrontBtn'),
                toolbarBringForwardBtn: document.getElementById('toolbarBringForwardBtn'),
                toolbarSendBackwardBtn: document.getElementById('toolbarSendBackwardBtn'),
                toolbarSendToBackBtn: document.getElementById('toolbarSendToBackBtn'),
                alignBtn: document.getElementById('alignBtn'),
                alignDropdown: document.getElementById('alignDropdown'),
                toolbarDeleteBtn: document.getElementById('toolbarDeleteBtn'),
                // Zoom controls
                zoomInBtn: document.getElementById('zoomInBtn'),
                zoomOutBtn: document.getElementById('zoomOutBtn'),
                zoomResetBtn: document.getElementById('zoomResetBtn'),
                zoomPercentage: document.getElementById('zoomPercentage'),
                // Undo/Redo controls
                undoBtn: document.getElementById('undoBtn'),
                redoBtn: document.getElementById('redoBtn'),
            };
            
            // Initialize language selector with current content locale
            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect) {
                languageSelect.value = currentLocale;
            }
            
            // Apply translations
            if (typeof applyTranslations === 'function') {
                applyTranslations();
            }
            
            worksheetCanvas = new fabric.Canvas('worksheetCanvasElement', { preserveObjectStacking: true, enableRetinaScaling: true });
            answerKeyCanvas = new fabric.Canvas('answerKeyCanvasElement', { preserveObjectStacking: true, enableRetinaScaling: true });
            
            setupCanvasEventListeners(worksheetCanvas);
            setupCanvasEventListeners(answerKeyCanvas);
            
            dom.pageSizeSelect.value = "612x792"; // Letter Portrait default
            [currentCanvasConfig.width, currentCanvasConfig.height] = [612, 792];
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height, true);
            
            applyPageColor();

            setupEventListeners();
            updateZoomDisplay(); // Initialize zoom display to 100%
            buildPrepositionsChecklist();
            updateGenerateButtonState();
            updateDownloadButtonsState(false, false);
            
            await initializeImageLibrary();
            await loadBorderThemes();
            await loadBackgroundThemes();
            await loadTemplates();
            
            dom.borderOpacity.disabled = true;
            dom.backgroundOpacity.disabled = true;

            // Initialize undo/redo button states
            updateUndoRedoButtons();

            document.querySelector('.tab-button[data-tab="worksheetTab"]').click();
            handleSelectionCleared(null, getActiveCanvas());
        }
        
        function buildPrepositionsChecklist() {
            dom.prepositionsGrid.innerHTML = '';
            PREPOSITIONS.forEach(prep => {
                const label = document.createElement('label');
                label.className = 'checkbox-label';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = prep;
                checkbox.checked = true;
                label.appendChild(checkbox);

                // Show translated preposition based on UI language (not content language)
                const translatedPrep = PREPOSITION_TRANSLATIONS[prep][uiLocale] || prep;
                label.appendChild(document.createTextNode(` ${translatedPrep}`));
                dom.prepositionsGrid.appendChild(label);
            });
        }
        
        function setupCanvasEventListeners(canvas) {
            canvas.on({
                'selection:created': function(e) { handleObjectSelection(e, this); },
                'selection:updated': function(e) { handleObjectSelection(e, this); },
                'selection:cleared': function(e) { handleSelectionCleared(e, this); },
                'object:modified': function(e) {
                    handleObjectModification(e, this);
                    // Only save state for user modifications, not during generation or restore
                    if (!isGenerating && !isRestoringState) {
                        saveState();
                    }
                },
                'object:added': function(e) {
                    // Only save state for user-added objects, not during generation or restore
                    if (!isGenerating && !isRestoringState) {
                        saveState();
                    }
                },
                'object:removed': function(e) {
                    // Only save state for user deletions, not during generation or restore
                    if (!isGenerating && !isRestoringState) {
                        saveState();
                    }
                }
            });
        }

        // --- Event Listener Setup ---
        function setupEventListeners() {
            // Language selector event listener - UnifiedLanguageManager integration
            const languageSelect = document.getElementById('languageSelect');

            // Use UnifiedLanguageManager if available
            if (typeof window.UnifiedLanguageManager !== 'undefined') {
                window.languageManager = window.UnifiedLanguageManager;

                window.languageManager.onLanguageChange(async function(newLocale, oldLocale) {
                    console.log('[Prepositions] Content language changed from', oldLocale, 'to', newLocale);
                    currentLocale = newLocale;
                    window.currentLocale = newLocale;

                    // Rebuild prepositions checklist with new translations for preposition labels
                    buildPrepositionsChecklist();
                    // Reload themes with new locale
                    await initializeImageLibrary();
                    // Re-render dictionaries if needed
                    if (dom.themeSelect.value && dom.themeSelect.value !== 'all') {
                        await handleManualItemThemeChange();
                    }
                    if (dom.shapeImageThemeSelect.value && dom.shapeImageThemeSelect.value !== 'all') {
                        await handleManualShapeThemeChange();
                    }
                });
            } else {
                console.warn('[Prepositions] UnifiedLanguageManager not found, using fallback mode');
                // Fallback: direct event listener
                if (languageSelect) {
                    languageSelect.addEventListener('change', async function() {
                        const newLocale = this.value;
                        console.log('[Prepositions] Content language changed to', newLocale);
                        currentLocale = newLocale;
                        window.currentLocale = newLocale;

                        // Rebuild prepositions checklist with new translations for preposition labels
                        buildPrepositionsChecklist();
                        // Reload themes with new locale
                        await initializeImageLibrary();
                        // Re-render dictionaries if needed
                        if (dom.themeSelect.value && dom.themeSelect.value !== 'all') {
                            await handleManualItemThemeChange();
                        }
                        if (dom.shapeImageThemeSelect.value && dom.shapeImageThemeSelect.value !== 'all') {
                            await handleManualShapeThemeChange();
                        }
                    });
                }
            }
            
            dom.menuToggleBtn.addEventListener('click', () => { dom.panel.classList.add('is-open'); dom.menuOverlay.classList.add('is-active'); });
            dom.menuCloseBtn.addEventListener('click', () => { dom.panel.classList.remove('is-open'); dom.menuOverlay.classList.remove('is-active'); });
            dom.menuOverlay.addEventListener('click', () => { dom.panel.classList.remove('is-open'); dom.menuOverlay.classList.remove('is-active'); });

            document.querySelectorAll('.accordion-button').forEach(button => button.addEventListener('click', () => { const content = button.nextElementSibling; button.classList.toggle('active'); content.style.display = content.style.display === 'block' ? 'none' : 'block'; }));
            setupDropdown(dom.generateDropdownBtn, dom.generateDropdownContent);
            setupDropdown(dom.downloadDropdownBtn, dom.downloadDropdownContent);
            setupPopover(dom.layersBtn, dom.layersDropdown);
            setupPopover(dom.alignBtn, dom.alignDropdown);
            
            dom.grayscaleToggle.parentElement.addEventListener('click', e => e.stopPropagation());

            dom.pageSizeSelect.addEventListener('change', () => { 
                dom.customPageSizeInputs.style.display = dom.pageSizeSelect.value === 'custom' ? 'block' : 'none';
                // Automatically apply page size for non-custom selections
                if (dom.pageSizeSelect.value !== 'custom') {
                    applyPageSize();
                }
            });
            dom.setPageSizeBtn.addEventListener('click', applyPageSize);
            dom.templateSelect.addEventListener("change", handleTemplateChange);
            dom.pageColor.addEventListener('input', applyPageColor);
            dom.borderThemeSelect.addEventListener("change", loadBorderImages);
            dom.borderOpacity.addEventListener("input", updateOpacityForObjectType('isBorder'));
            dom.backgroundThemeSelect.addEventListener("change", loadBackgroundImages);
            dom.backgroundOpacity.addEventListener("input", updateOpacityForObjectType('isBackground'));
            
            dom.addTextBtn.addEventListener('click', addText);
            dom.textInput.addEventListener('input', updateActiveTextObjectProperties);
            dom.textColor.addEventListener('input', updateActiveTextObjectProperties);
            dom.fontSize.addEventListener('input', updateActiveTextObjectProperties);
            dom.fontFamily.addEventListener('change', updateActiveTextObjectProperties);
            dom.textStrokeColor.addEventListener('input', updateActiveTextObjectProperties);
            dom.textStrokeWidth.addEventListener('input', updateActiveTextObjectProperties);

            dom.itemThemeSelect.addEventListener('change', handleItemModeChange);
            dom.themeSelect.addEventListener('change', handleManualItemThemeChange);
            dom.searchInput.addEventListener('input', () => { if(this.searchTimeout) clearTimeout(this.searchTimeout); this.searchTimeout = setTimeout(() => renderDictionary('item'), 300); });
            
            dom.shapeThemeSelect.addEventListener('change', handleShapeModeChange);
            dom.shapeImageThemeSelect.addEventListener('change', handleManualShapeThemeChange);
            dom.shapeSearchInput.addEventListener('input', () => { if(this.searchTimeout) clearTimeout(this.searchTimeout); this.searchTimeout = setTimeout(() => renderDictionary('shape'), 300); });
            
            // Custom file button handler
            dom.customFileButton.addEventListener('click', () => {
                dom.imageUploadInput.click();
            });

            dom.imageUploadInput.addEventListener('change', handleImageUpload);

            dom.generateWorksheetBtn.addEventListener('click', generateWorksheet);
            dom.generateAnswerKeyBtn.addEventListener('click', generateAnswerKey);

            dom.downloadWsJpegBtn.addEventListener("click", () => downloadImageFile(worksheetCanvas, 'prepositions_worksheet'));
            dom.downloadAkJpegBtn.addEventListener("click", () => downloadImageFile(answerKeyCanvas, 'prepositions_answer_key'));
            dom.downloadWsPdfBtn.addEventListener("click", () => downloadPDF(worksheetCanvas, 'prepositions_worksheet'));
            dom.downloadAkPdfBtn.addEventListener("click", () => downloadPDF(answerKeyCanvas, 'prepositions_answer_key'));

            dom.clearBtn.addEventListener('click', clearAll);

            // Zoom Controls (from wordsearch lines 1520-1522)
            dom.zoomInBtn.addEventListener('click', zoomIn);
            dom.zoomOutBtn.addEventListener('click', zoomOut);
            dom.zoomResetBtn.addEventListener('click', zoomReset);

            // Undo/Redo Controls
            dom.undoBtn.addEventListener('click', undo);
            dom.redoBtn.addEventListener('click', redo);

            setupGlobalKeydownListener();
            // Enhanced Layer Controls (4-button z-order system)
            dom.toolbarBringToFrontBtn.addEventListener('click', bringToFront);
            dom.toolbarBringForwardBtn.addEventListener('click', bringObjectForward);
            dom.toolbarSendBackwardBtn.addEventListener('click', sendObjectBackward);
            dom.toolbarSendToBackBtn.addEventListener('click', sendToBack);
            dom.toolbarDeleteBtn.addEventListener('click', deleteSelectedObjects);
            document.querySelectorAll('#alignDropdown button').forEach(button => button.addEventListener('click', (e) => alignObjects(e.currentTarget.id.replace('Btn', ''))));
            
            document.querySelectorAll(".tab-button").forEach(btn => {
                btn.addEventListener("click", function() {
                    const currentActiveCanvas = getActiveCanvas();
                    if (currentActiveCanvas) {
                        currentActiveCanvas.discardActiveObject().renderAll();
                    }
                    handleSelectionCleared(null, currentActiveCanvas);
                    
                    document.querySelectorAll(".tab-button.active").forEach(b => b.classList.remove("active"));
                    this.classList.add("active");
                    document.querySelectorAll(".tab.active").forEach(t => t.classList.remove("active"));
                    const tabId = this.getAttribute("data-tab");
                    document.getElementById(tabId)?.classList.add("active");
                    
                    const newActiveCanvas = getActiveCanvas();
                    if (newActiveCanvas) {
                        newActiveCanvas.calcOffset();
                        newActiveCanvas.renderAll();
                    }
                });
            });
        }

        function setupDropdown(button, content) {
            button.addEventListener('click', (event) => { if (button.disabled) return; content.style.display = content.style.display === 'block' ? 'none' : 'block'; event.stopPropagation(); });
        }
        
        function setupPopover(button, content) {
            button.addEventListener('click', (event) => { const isOpening = content.style.display !== 'block'; closeAllPopovers(); if (isOpening) { content.style.display = 'block'; activePopover = content; } event.stopPropagation(); });
        }

        window.addEventListener('click', (event) => {
            if (dom.generateDropdownContent.style.display === 'block' && !dom.generateDropdownBtn.contains(event.target) && !dom.generateDropdownContent.contains(event.target)) dom.generateDropdownContent.style.display = 'none';
            if (dom.downloadDropdownContent.style.display === 'block' && !dom.downloadDropdownBtn.contains(event.target) && !dom.downloadDropdownContent.contains(event.target)) dom.downloadDropdownContent.style.display = 'none';
            closeAllPopovers();
        });

        function showMessage(msg, type = 'info', duration = 3000) {
            dom.message.textContent = msg;
            dom.message.className = `message ${type}`;
            dom.message.style.display = 'block';
            if (duration > 0) setTimeout(() => { dom.message.style.display = 'none'; dom.message.textContent = ""; }, duration);
        }

        function updateGenerateButtonState() {
            const itemMode = dom.itemThemeSelect.value;
            const exerciseCount = parseInt(dom.exerciseCount.value, 10);
            let enabled = false;
            if (itemMode === 'manual') {
                enabled = selectedItems.length >= exerciseCount;
            } else {
                enabled = true; // Can always attempt to generate from a theme
            }
            dom.generateDropdownBtn.disabled = !enabled;
            dom.generateWorksheetBtn.disabled = !enabled;
            dom.generateAnswerKeyBtn.disabled = !lastGeneratedAssignments;
        }

        function updateDownloadButtonsState(worksheetEnabled, answerKeyEnabled) {
            const anyEnabled = worksheetEnabled || answerKeyEnabled;
            dom.downloadDropdownBtn.disabled = !anyEnabled;
            
            dom.downloadWsJpegBtn.disabled = !worksheetEnabled;
            dom.downloadWsPdfBtn.disabled = !worksheetEnabled;
            
            dom.downloadAkJpegBtn.disabled = !answerKeyEnabled;
            dom.downloadAkPdfBtn.disabled = !answerKeyEnabled;

            if (!anyEnabled) dom.downloadDropdownContent.style.display = 'none';
        }
        
        function applyPageSize() {
            let newWidth, newHeight;
            if (dom.pageSizeSelect.value === 'custom') {
                [newWidth, newHeight] = [parseInt(dom.pageWidth.value), parseInt(dom.pageHeight.value)];
            } else {
                [newWidth, newHeight] = dom.pageSizeSelect.value.split('x').map(Number);
            }
            updateCanvasDisplayDimensions(newWidth || currentCanvasConfig.width, newHeight || currentCanvasConfig.height);
            
            // Update existing template (whiteboard) size based on new orientation
            const isPortrait = currentCanvasConfig.width < currentCanvasConfig.height;
            const HEADER_END = isPortrait ? 175 : 155; // Landscape: moved up 20px
            const BORDER_MARGIN = 34;
            const SIDE_PADDING = 40;
            [worksheetCanvas, answerKeyCanvas].forEach(canvas => {
                const template = canvas.getObjects().find(o => o.isTemplate);
                if (template) {
                    const availableWidth = (currentCanvasConfig.width - (BORDER_MARGIN + SIDE_PADDING) * 2) * 1.05;

                    // Scale to width
                    const scaleFactorX = availableWidth / (template.width * template.scaleX);
                    template.scaleX = template.scaleX * scaleFactorX;

                    // Scale height - portrait reduced by 10%, landscape increased by 30%
                    const BOTTOM_RESERVE = isPortrait ? 180 : 221;
                    const heightMultiplier = isPortrait ? 0.9 : 1.3;
                    const availableHeight = (currentCanvasConfig.height - HEADER_END - BOTTOM_RESERVE) * heightMultiplier;
                    template.scaleY = availableHeight / template.height;

                    // Position whiteboard
                    const whiteboardHeight = template.height * template.scaleY;
                    template.set({
                        left: currentCanvasConfig.width / 2,
                        top: HEADER_END + whiteboardHeight / 2,
                        originX: 'center',
                        originY: 'center'
                    });

                    canvas.renderAll();
                }
            });
            
            showMessage(t("prepositions.msg.page.updated"), "success", 1500);
        }

        async function updateCanvasDisplayDimensions(width, height, fromLoad = false) {
            if (!width || !height) return;
            currentCanvasConfig.width = width;
            currentCanvasConfig.height = height;

            const mainContentAreaStyle = getComputedStyle(document.querySelector('.tab-content-wrapper'));
            const availableWidth = parseFloat(mainContentAreaStyle.width) - parseFloat(mainContentAreaStyle.paddingLeft) - parseFloat(mainContentAreaStyle.paddingRight) - 10;
            const availableHeight = parseFloat(mainContentAreaStyle.height) - parseFloat(mainContentAreaStyle.paddingTop) - parseFloat(mainContentAreaStyle.paddingBottom) - 10;

            // Apply 25% scaling for better visibility
            const isLandscape = width > height;
            const baseScale = 1.25; // Base 25% larger for all
            const landscapeBonus = isLandscape ? 1.25 : 1.0; // Additional 25% for landscape
            const displayScale = baseScale * landscapeBonus;

            // Calculate display dimensions with scaling
            const scaledWidth = width * displayScale;
            const scaledHeight = height * displayScale;

            // Ensure it fits in available space
            const scaleRatio = Math.min(availableWidth / scaledWidth, availableHeight / scaledHeight, 1);

            // Apply user zoom level to the display dimensions (EXACT wordsearch implementation)
            const displayWidth = scaledWidth * scaleRatio * userZoomLevel;
            const displayHeight = scaledHeight * scaleRatio * userZoomLevel;

            [worksheetCanvas, answerKeyCanvas].forEach(c => {
                if (c) {
                    // Apply zoom for display scaling (includes user zoom)
                    const finalZoom = (displayWidth / width);
                    c.setZoom(finalZoom);

                    // Set dimensions AFTER zoom to ensure viewport matches zoomed size
                    c.setDimensions({
                        width: displayWidth,
                        height: displayHeight
                    });

                    c.calcOffset();

                    // Update hit detection areas for all objects after zoom
                    c.getObjects().forEach(obj => {
                        obj.setCoords();
                    });

                    c.renderAll();
                }
            });

            // Update wrapper dimensions to match display size
            [dom.worksheetCanvasWrapper, dom.answerKeyCanvasWrapper].forEach(w => {
                if (w) {
                    w.style.width = `${displayWidth}px`;
                    w.style.height = `${displayHeight}px`;
                }
            });

            dom.pageWidth.value = width;
            dom.pageHeight.value = height;

            if (!fromLoad) {
                // Regenerate headers when page size changes
                await regenerateHeadersOnly();
            }
        }

        function applyPageColor() {
            const color = dom.pageColor.value;
            [worksheetCanvas, answerKeyCanvas].forEach(c => { if(c) { c.backgroundColor = color; c.renderAll(); } });
        }

        function createHeaderGroup(canvas) {
            const defaultHeaders = {
                en: { title: 'Prepositions', description: 'Complete each sentence with the correct preposition!' },
                de: { title: 'Präpositionen', description: 'Vervollständige jeden Satz mit der richtigen Präposition!' },
                fr: { title: 'Prépositions', description: 'Complétez chaque phrase avec la bonne préposition!' },
                es: { title: 'Preposiciones', description: '¡Completa cada frase con la preposición correcta!' },
                it: { title: 'Preposizioni', description: 'Completa ogni frase con la preposizione corretta!' },
                pt: { title: 'Preposições', description: 'Complete cada frase com a preposição correta!' },
                nl: { title: 'Voorzetsels', description: 'Voltooi elke zin met het juiste voorzetsel!' },
                sv: { title: 'Prepositioner', description: 'Fyll i varje mening med rätt preposition!' },
                da: { title: 'Præpositioner', description: 'Fuldfør hver sætning med den rigtige præposition!' },
                no: { title: 'Preposisjoner', description: 'Fullfør hver setning med riktig preposisjon!' },
                fi: { title: 'Prepositiot', description: 'Täydennä jokainen lause oikealla prepositiolla!' }
            };

            const locale = currentLocale || 'en';
            const defaults = defaultHeaders[locale] || defaultHeaders.en;
            const title = defaults.title;
            const description = defaults.description;

            // Get current canvas dimensions for responsive design
            const pageWidth = currentCanvasConfig.width;
            const pageHeight = currentCanvasConfig.height;
            const isLandscape = pageWidth > pageHeight;

            const objects = [];

            // Outer border - responsive to page size (purple for spatial/position theme)
            const margin = 34;
            const strokeWidth = 8;
            const borderWidth = pageWidth - (margin * 2);
            const borderHeight = pageHeight - (margin * 2);

            const outerBorder = new fabric.Rect({
                left: margin,
                top: margin,
                width: borderWidth,
                height: borderHeight,
                fill: 'transparent',
                stroke: '#7B1FA2',
                strokeWidth: strokeWidth,
                rx: 12,
                ry: 12,
                selectable: true,
                hasControls: true,
                isPageBorder: true
            });
            objects.push(outerBorder);

            // COMPACT HEADER for both orientations - stays above whiteboard
            const centerX = pageWidth / 2;
            const headerTop = isLandscape ? 65 : 85; // Landscape: moved up 20px, Portrait: original position
            const headerHeight = 45;
            const maxHeaderWidth = Math.min(400, pageWidth * 0.65);

            // Lavender header background - very compact
            const bgRect = new fabric.Rect({
                left: centerX - maxHeaderWidth / 2,
                top: headerTop,
                width: maxHeaderWidth,
                height: headerHeight,
                fill: '#BA68C8',
                rx: 22,
                ry: 22,
                selectable: true,
                isHeaderElement: true
            });
            objects.push(bgRect);

            // White pill for title - very compact
            const whitePill = new fabric.Rect({
                left: centerX - (maxHeaderWidth - 30) / 2,
                top: headerTop + 8,
                width: maxHeaderWidth - 30,
                height: 29,
                fill: '#FFFFFF',
                rx: 14,
                ry: 14,
                selectable: true,
                isHeaderElement: true
            });
            objects.push(whitePill);

            // Title - compact size
            let titleFontSize = 20;
            if (title.length > 12) titleFontSize = 18;
            if (title.length > 15) titleFontSize = 16;

            const titleText = new fabric.IText(title, {
                left: centerX,
                top: headerTop + 22,
                fontSize: titleFontSize,
                fontFamily: 'Fredoka, sans-serif',
                fontWeight: '700',
                fill: '#6A1B9A',
                textAlign: 'center',
                originX: 'center',
                originY: 'center',
                selectable: true,
                editable: true,
                isHeaderElement: true
            });
            objects.push(titleText);

            // Description text below header
            const descTop = headerTop + headerHeight + 8;
            const descText = new fabric.Textbox(description, {
                left: centerX,
                top: descTop,
                width: Math.min(500, pageWidth * 0.8),
                fontSize: 16,
                fontFamily: 'Quicksand, sans-serif',
                fontWeight: '500',
                fill: '#E91E63',
                textAlign: 'center',
                originX: 'center',
                originY: 'top',
                selectable: true,
                editable: true,
                hasControls: true,
                isHeaderDesc: true,
                isHeaderElement: true
            });
            objects.push(descText);

            return objects;
        }

        function enforceLayerOrder(canvas) {
            if (!canvas) return;
            const background = canvas.getObjects().find(o => o.isBackground);
            const template = canvas.getObjects().find(o => o.isTemplate);
            const border = canvas.getObjects().find(o => o.isBorder);

            // Handle page borders (should be behind everything)
            const pageBorders = canvas.getObjects().filter(o => o.isPageBorder);
            pageBorders.forEach(pb => canvas.sendToBack(pb));

            if(background) canvas.sendToBack(background);
            if(template) canvas.sendToBack(template);
            if(border) canvas.sendToBack(border);

            if(template && background) canvas.bringForward(template);
            if(border && template) canvas.bringForward(border);
            else if (border && background) canvas.bringForward(border);

            // Bring page borders above background but behind everything else
            pageBorders.forEach(pb => {
                if (background) canvas.bringForward(pb);
            });

            canvas.renderAll();
        }

        async function loadTemplates() {
            dom.templateSelect.innerHTML = `<option value="">${t('none')}</option>`;

            try {
                // Load worksheet templates from the API
                const response = await fetch(`/api/templates?appType=prepositions&locale=${currentLocale}`);
                if (response.ok) {
                    const data = await response.json();
                    const templates = data.templates || data;

                    console.log('Loaded worksheet templates:', templates);

                    templates.forEach(template => {
                        const option = new Option(
                            template.displayName || template.name,
                            template.path || template.url || `/images/worksheet_templates/${template.name}`
                        );
                        dom.templateSelect.add(option);
                    });

                    // Select whiteboard by default if available
                    const whiteboardOption = Array.from(dom.templateSelect.options).find(
                        opt => opt.value.includes('whiteboard')
                    );
                    if (whiteboardOption) {
                        dom.templateSelect.value = whiteboardOption.value;
                        currentTemplatePath = whiteboardOption.value;
                    } else {
                        // If no whiteboard found in API response, add hardcoded whiteboard
                        dom.templateSelect.add(new Option('Whiteboard', '/images/prepositions/whiteboard.png'));
                        dom.templateSelect.value = '/images/prepositions/whiteboard.png';
                        currentTemplatePath = '/images/prepositions/whiteboard.png';
                    }
                } else {
                    console.warn('Failed to load worksheet templates from API');
                    // Fallback to hardcoded template
                    dom.templateSelect.add(new Option('Whiteboard', '/images/prepositions/whiteboard.png'));
                    dom.templateSelect.value = '/images/prepositions/whiteboard.png';
                    currentTemplatePath = '/images/prepositions/whiteboard.png';
                }
            } catch (error) {
                console.error('Error loading worksheet templates:', error);
                // Fallback to hardcoded template
                dom.templateSelect.add(new Option('Whiteboard', '/images/prepositions/whiteboard.png'));
                dom.templateSelect.value = '/images/prepositions/whiteboard.png';
                currentTemplatePath = '/images/prepositions/whiteboard.png';
            }

            // Load the selected template on canvas
            if (currentTemplatePath) {
                await addTemplateToCanvases(currentTemplatePath);
            }
        }

        async function handleTemplateChange(event) {
            currentTemplatePath = event ? event.target.value : dom.templateSelect.value;
            [worksheetCanvas, answerKeyCanvas].forEach(canvas => {
                canvas.getObjects().filter(o => o.isTemplate).forEach(o => canvas.remove(o));
            });
            if (currentTemplatePath) {
                await addTemplateToCanvases(currentTemplatePath);
            }
        }

        async function addTemplateToCanvases(path) {
            try {
                const newTemplateImg = await loadImage(path);
                [worksheetCanvas, answerKeyCanvas].forEach(canvas => {
                    if (canvas.getObjects().some(o => o.isTemplate)) return;
                    newTemplateImg.clone(cloned => {
                        // For portrait mode (width < height), scale to full page width
                        // For landscape mode, keep original scaling
                        const actualWidth = currentCanvasConfig.width;
                        const isPortrait = currentCanvasConfig.width < currentCanvasConfig.height;
                        
                        cloned.set({ 
                            isTemplate: true, 
                            selectable: true, 
                            evented: true, 
                            objectCaching: false 
                        });
                        
                        // Header + description ends at ~170px in portrait, ~150px in landscape
                        const HEADER_END = isPortrait ? 175 : 155; // Landscape: moved up 20px
                        const BORDER_MARGIN = 34;
                        const SIDE_PADDING = 40;

                        // Calculate available space (increased by 5% for visual exercises)
                        const availableWidth = (actualWidth - (BORDER_MARGIN + SIDE_PADDING) * 2) * 1.05;

                        if (isPortrait) {
                            // Portrait: Increased whiteboard to fill gap above Q&A text, then reduced by 10%
                            const BOTTOM_RESERVE = 180;
                            const availableHeight = (currentCanvasConfig.height - HEADER_END - BOTTOM_RESERVE) * 0.9;

                            cloned.scaleToWidth(availableWidth);
                            // Scale height to fill available vertical space
                            const targetHeight = availableHeight;
                            cloned.scaleY = targetHeight / cloned.height;

                            cloned.set({
                                left: actualWidth / 2,
                                top: HEADER_END + (cloned.height * cloned.scaleY) / 2,
                                originX: 'center',
                                originY: 'center'
                            });
                        } else {
                            // Landscape: Whiteboard increased by 30%
                            const BOTTOM_RESERVE = 221;
                            const availableHeight = (currentCanvasConfig.height - HEADER_END - BOTTOM_RESERVE) * 1.3;

                            cloned.scaleToWidth(availableWidth);
                            const targetHeight = availableHeight;
                            cloned.scaleY = targetHeight / cloned.height;

                            cloned.set({
                                left: actualWidth / 2,
                                top: HEADER_END + (cloned.height * cloned.scaleY) / 2,
                                originX: 'center',
                                originY: 'center'
                            });
                        }
                        canvas.add(cloned);
                        enforceLayerOrder(canvas);
                    });
                });
            } catch(err) { showMessage(t("prepositions.msg.template.error"), "error"); }
        }

        async function fetchThemesFor(type) { return await fetchFromApi(`/api/${type}/themes?locale=${currentLocale}`, `Failed to load ${type} themes`); }
        async function loadBorderThemes() {
            const themes = await fetchThemesFor('borders');
            dom.borderThemeSelect.innerHTML = `<option value="none">${t('none')}</option>`;
            themes.forEach(theme => {
                const option = document.createElement('option');
                option.value = theme.value;
                option.textContent = theme.displayName;
                dom.borderThemeSelect.appendChild(option);
            });
        }
        async function loadBackgroundThemes() {
            const themes = await fetchThemesFor('backgrounds');
            dom.backgroundThemeSelect.innerHTML = `<option value="none">${t('none')}</option>`;
            themes.forEach(theme => {
                const option = document.createElement('option');
                option.value = theme.value;
                option.textContent = theme.displayName;
                dom.backgroundThemeSelect.appendChild(option);
            });
        }
        async function loadBorderImages() { await loadSpecialImages('border', dom.borderThemeSelect.value, dom.borderDictionary); }
        async function loadBackgroundImages() { await loadSpecialImages('background', dom.backgroundThemeSelect.value, dom.backgroundDictionary); }
        async function loadSpecialImages(type, theme, container) {
            document.querySelectorAll(`.${type}-thumbnail-item.selected`).forEach(el => el.classList.remove('selected'));
            removeObjectByType(`is${type.charAt(0).toUpperCase() + type.slice(1)}`);
            if (theme === 'none') { 
                container.innerHTML = `<p class="dictionary-message">Select a theme to see ${type}s.</p>`; 
                document.getElementById(`${type}Opacity`).disabled = true; 
                if(type === 'border') currentBorderImagePath = '';
                if(type === 'background') currentBackgroundImagePath = '';
                return; 
            }
            container.innerHTML = `<p class="dictionary-message">Loading ${theme} ${type}s...</p>`;
            const data = await fetchFromApi(`/api/${type}s/images?theme=${theme}&locale=${currentLocale}`, `Failed to load images for ${type} theme: ${theme}`);
            const images = data.images || data;
            console.log(`Loaded ${type} images:`, images); // Debug log
            renderSpecialThumbnails(images, type, container);
        }

        function renderSpecialThumbnails(images, type, container) {
            container.innerHTML = "";
            if (!images || images.length === 0) { container.innerHTML = `<p class="dictionary-message">No ${type}s in this theme.</p>`; return; }
            images.forEach(imgData => {
                const displayName = imgData.name || imgData.word;
                const imageSrc = imgData.url || imgData.path; // Handle both url and path properties
                const item = document.createElement("div"); item.className = "border-thumbnail-item"; item.innerHTML = `<img src="${imageSrc}" alt="${displayName}" loading="lazy" crossorigin="anonymous" />`;
                item.onclick = () => { addSpecialImageToCanvas(imageSrc, `is${type.charAt(0).toUpperCase() + type.slice(1)}`, type); document.querySelectorAll(`#${type}Dictionary .border-thumbnail-item.selected`).forEach(el => el.classList.remove('selected')); item.classList.add('selected'); };
                container.appendChild(item);
            });
        }
        function addSpecialImageToCanvas(path, typeKey, typeName) {
            removeObjectByType(typeKey);

            if(typeKey === 'isBorder') currentBorderImagePath = path;
            if(typeKey === 'isBackground') currentBackgroundImagePath = path;

            fabric.Image.fromURL(path, (img) => {
                if (!img) { showMessage(t('prepositions.msg.load.failed', { typeName }), 'error'); return; }
                const opacityInput = document.getElementById(`${typeName}Opacity`);

                const activeCanvas = getActiveCanvas();

                // Use ACTUAL canvas dimensions, not display dimensions (EXACTLY like Addition app)
                const actualWidth = currentCanvasConfig.width;
                const actualHeight = currentCanvasConfig.height;

                // Scale to 70% of ACTUAL canvas height while preserving aspect ratio
                const targetHeight = actualHeight * 0.7;
                const scaleFactor = targetHeight / img.height;

                img.set({
                    [typeKey]: true,
                    originX: 'center',
                    originY: 'center',
                    left: actualWidth / 2,  // Use actual dimensions for correct centering
                    top: actualHeight / 2,   // Use actual dimensions for correct centering
                    scaleX: scaleFactor,
                    scaleY: scaleFactor,
                    selectable: true,
                    evented: true,
                    opacity: parseFloat(opacityInput.value),
                    borderColor: 'var(--app-accent-primary)',
                    cornerColor: 'var(--app-accent-primary)',
                    cornerSize: 10,
                    transparentCorners: false,
                    cornerStyle: 'circle'
                });

                activeCanvas.add(img);
                img.bringToFront(); // Bring to front so user can select it immediately

                // REMOVED: Automatic z-order enforcement for backgrounds and borders
                // Users should have full control over these elements via layer controls

                activeCanvas.renderAll();
                opacityInput.disabled = false;
                const Type = typeName.charAt(0).toUpperCase() + typeName.slice(1);
                showMessage(t('prepositions.msg.item.added', { Type }), 'success', 1500);
            }, { crossOrigin: 'anonymous' });
        }

        function updateOpacityForObjectType(typeKey) {
            return function(event) {
                const newOpacity = parseFloat(event.target.value);
                // Only update opacity on the ACTIVE canvas
                const activeCanvas = getActiveCanvas();
                const obj = activeCanvas?.getObjects().find(o => o[typeKey]);
                if (obj) {
                    obj.set('opacity', newOpacity);
                    activeCanvas.renderAll();
                }
            }
        }
        function removeObjectByType(typeKey) {
            // Only remove from the ACTIVE canvas, not both
            const activeCanvas = getActiveCanvas();
            activeCanvas?.getObjects().filter(o => o[typeKey]).forEach(o => activeCanvas.remove(o));
            activeCanvas?.renderAll();

            if(typeKey === 'isBorder') currentBorderImagePath = '';
            if(typeKey === 'isBackground') currentBackgroundImagePath = '';
        }
        
        // --- Text Tools & Toolbar ---
        function addText() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const textObject = new fabric.Textbox(dom.textInput.value.trim() || t('prepositions.text.default'), {
                left: (currentCanvasConfig.width - 250) / 2,
                top: (currentCanvasConfig.height - 100) / 2,
                fontSize: 48,
                fill: '#333333',
                fontFamily: 'Arial',
                width: 250,
                padding: 8,
                borderColor: 'var(--app-accent-primary)',
                cornerColor: 'var(--app-accent-primary)',
                cornerSize: 10,
                transparentCorners: false,
                cornerStyle: 'circle',
                stroke: '#000000',
                strokeWidth: 0
            });
            activeCanvas.add(textObject).setActiveObject(textObject).renderAll();
        }
        
        function updateActiveTextObjectProperties() { 
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject(); 
            if (activeObject && activeObject.type === 'textbox' && !activeObject.isGeneratedItem && !activeObject.isAnswerKeyItem) { 
                if (activeObject.isEditing) return; activeObject.set({ text: dom.textInput.value, fill: dom.textColor.value, fontSize: parseInt(dom.fontSize.value, 10), fontFamily: dom.fontFamily.value, stroke: dom.textStrokeColor.value, strokeWidth: parseFloat(dom.textStrokeWidth.value) }); 
                activeCanvas.renderAll(); 
            } 
        }
        
        function handleObjectModification(e, canvas) { 
            if (e.target) { 
                if (e.target.isBorder) { dom.borderOpacity.value = e.target.opacity; } 
                if (e.target.isBackground) { dom.backgroundOpacity.value = e.target.opacity; } 
            } 
        }
        
        function handleObjectSelection(e, canvas) {
            dom.objectContextToolbar.style.display = 'flex';
            const activeObject = canvas.getActiveObject();
            const isSingleTextObject = activeObject && activeObject.type === 'textbox' && !activeObject.isGeneratedItem && !activeObject.isAnswerKeyItem && !activeObject.isBorder && !activeObject.isBackground && !activeObject.isTemplate;
            [dom.textInput, dom.textColor, dom.fontSize, dom.fontFamily, dom.textStrokeColor, dom.textStrokeWidth].forEach(c => c.disabled = !isSingleTextObject);
            if (isSingleTextObject) { dom.textInput.value = activeObject.text || ""; dom.textColor.value = activeObject.fill; dom.fontSize.value = activeObject.fontSize; dom.fontFamily.value = activeObject.fontFamily; dom.textStrokeColor.value = activeObject.stroke; dom.textStrokeWidth.value = activeObject.strokeWidth; }
            const isGroup = activeObject && activeObject.type === 'activeSelection';
            document.querySelectorAll('#alignDropdown button').forEach(btn => btn.disabled = btn.id.includes('Canvas') ? isGroup : !isGroup);
        }
        
        function handleSelectionCleared(e, canvas) { 
            dom.objectContextToolbar.style.display = 'none'; 
            closeAllPopovers(); 
            [dom.textColor, dom.fontSize, dom.fontFamily, dom.textStrokeColor, dom.textStrokeWidth].forEach(c => c.disabled = true); 
            dom.textInput.disabled = false; 
        }
        
        function bringObjectForward() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject) {
                activeCanvas.bringForward(activeObject);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        function sendObjectBackward() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject) {
                activeCanvas.sendBackwards(activeObject);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        // ============================================
        // ENHANCED LAYER CONTROLS
        // Exact implementation from wordsearch.html lines 1807-1828
        // ============================================

        function bringToFront() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject) {
                activeCanvas.bringToFront(activeObject);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        function sendToBack() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject) {
                activeCanvas.sendToBack(activeObject);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        // ============================================
        // UNDO/REDO FUNCTIONALITY
        // Exact implementation from wordsearch.html lines 1830-1933
        // ============================================

        function saveState() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;

            const json = activeCanvas.toJSON([
                'selectable', 'evented', 'isGeneratedItem', 'isAnswerKeyItem',
                'isBorder', 'isBackground', 'isTemplate', 'isPageBorder',
                'isHeaderElement', 'isHeaderDesc', 'itemId', 'shapeId',
                'originX', 'originY', 'crossOrigin'
            ]);

            undoStack.push({
                canvasState: JSON.stringify(json),
                backgroundColor: activeCanvas.backgroundColor
            });

            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }

            redoStack = [];
            updateUndoRedoButtons();
        }

        function restoreState(state) {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas || !state) return;

            isRestoringState = true;  // Prevent saveState during restoration

            return new Promise((resolve) => {
                activeCanvas.loadFromJSON(state.canvasState, () => {
                    activeCanvas.backgroundColor = state.backgroundColor;
                    activeCanvas.renderAll();
                    updateUndoRedoButtons();
                    isRestoringState = false;  // Re-enable saveState
                    resolve();
                });
            });
        }

        function undo() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas || undoStack.length === 0) return;

            const currentState = {
                canvasState: JSON.stringify(activeCanvas.toJSON([
                    'selectable', 'evented', 'isGeneratedItem', 'isAnswerKeyItem',
                    'isBorder', 'isBackground', 'isTemplate', 'isPageBorder',
                    'isHeaderElement', 'isHeaderDesc', 'itemId', 'shapeId',
                    'originX', 'originY', 'crossOrigin'
                ])),
                backgroundColor: activeCanvas.backgroundColor
            };

            redoStack.push(currentState);
            const previousState = undoStack.pop();
            restoreState(previousState).then(() => {
                showMessage('Undo', 'info', 1000);
            });
        }

        function redo() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas || redoStack.length === 0) return;

            const currentState = {
                canvasState: JSON.stringify(activeCanvas.toJSON([
                    'selectable', 'evented', 'isGeneratedItem', 'isAnswerKeyItem',
                    'isBorder', 'isBackground', 'isTemplate', 'isPageBorder',
                    'isHeaderElement', 'isHeaderDesc', 'itemId', 'shapeId',
                    'originX', 'originY', 'crossOrigin'
                ])),
                backgroundColor: activeCanvas.backgroundColor
            };

            undoStack.push(currentState);
            const nextState = redoStack.pop();
            restoreState(nextState).then(() => {
                showMessage('Redo', 'info', 1000);
            });
        }

        function updateUndoRedoButtons() {
            if (dom.undoBtn) {
                dom.undoBtn.disabled = undoStack.length === 0;
            }
            if (dom.redoBtn) {
                dom.redoBtn.disabled = redoStack.length === 0;
            }
        }

        function deleteSelectedObjects() { 
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObjects = activeCanvas.getActiveObjects(); 
            if (activeObjects.length > 0) { 
                activeObjects.forEach(obj => { 
                    if (obj.isBorder) { dom.borderThemeSelect.value = 'none'; dom.borderDictionary.innerHTML = `<p class="dictionary-message">${t('prepositions.border.message')}</p>`; }
                    if (obj.isBackground) { dom.backgroundThemeSelect.value = 'none'; dom.backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('prepositions.background.message')}</p>`; } 
                    if (obj.isTemplate) { dom.templateSelect.value = ''; currentTemplatePath = ''; } 
                    activeCanvas.remove(obj); 
                }); 
                activeCanvas.discardActiveObject().renderAll(); 
            } 
            closeAllPopovers(); 
        }
        
        function alignObjects(type) { 
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObj = activeCanvas.getActiveObject(); 
            if (!activeObj) { closeAllPopovers(); return; } 
            if (type.includes('Canvas')) { 
                // Use actual page dimensions for centering, not display dimensions
                if (type === 'centerHCanvas') {
                    activeObj.set({
                        left: currentCanvasConfig.width / 2,
                        originX: 'center'
                    });
                }
                if (type === 'centerVCanvas') {
                    activeObj.set({
                        top: currentCanvasConfig.height / 2,
                        originY: 'center'
                    });
                }
                activeObj.setCoords(); 
            } else if (activeObj.type === 'activeSelection') { 
                const group = activeObj; group.forEachObject(function(obj) { 
                    switch (type) { 
                        case 'alignLeft': obj.set('left', -group.width / 2); break; 
                        case 'alignHCenter': obj.set('left', 0 - (obj.getScaledWidth() / 2)); break; 
                        case 'alignRight': obj.set('left', group.width / 2 - obj.getScaledWidth()); break; 
                        case 'alignTop': obj.set('top', -group.height / 2); break; 
                        case 'alignVCenter': obj.set('top', 0 - (obj.getScaledHeight() / 2)); break; 
                        case 'alignBottom': obj.set('top', group.height / 2 - obj.getScaledHeight()); break; 
                    } 
                }); 
            } 
            activeCanvas.renderAll(); 
            closeAllPopovers(); 
        }

        // ============================================
        // ZOOM FUNCTIONALITY
        // Exact implementation from wordsearch.html lines 1745-1767
        // ============================================

        function zoomIn() {
            // Increase zoom by 25%, max 300%
            userZoomLevel = Math.min(userZoomLevel + 0.25, 3.0);
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function zoomOut() {
            // Decrease zoom by 25%, min 25%
            userZoomLevel = Math.max(userZoomLevel - 0.25, 0.25);
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function zoomReset() {
            // Reset to 100%
            userZoomLevel = 1.0;
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function updateZoomDisplay() {
            if (dom.zoomPercentage) {
                dom.zoomPercentage.textContent = Math.round(userZoomLevel * 100) + '%';
            }
        }

        function closeAllPopovers() { if (activePopover) { activePopover.style.display = 'none'; activePopover = null; } }
        
        function setupGlobalKeydownListener() {
            window.addEventListener('keydown', function(e) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.tagName === 'SELECT')) {
                    if (activeEl.closest('.panel') || activeEl.closest('.dropdown-content')) return;
                }

                // Undo/Redo keyboard shortcuts (Ctrl+Z / Ctrl+Y)
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' || e.key === 'Z') {
                        e.preventDefault();
                        undo();
                        return;
                    }
                    if (e.key === 'y' || e.key === 'Y') {
                        e.preventDefault();
                        redo();
                        return;
                    }
                }

                const activeCanvas = getActiveCanvas();
                if (!activeCanvas) return;
                const activeObject = activeCanvas.getActiveObject();
                if (activeObject && (e.key === 'Delete' || e.key === 'Backspace')) {
                    if (activeObject.isEditing) return;
                    e.preventDefault();
                    deleteSelectedObjects();
                }
            });
        }
        
        async function fetchFromApi(url, errorMessage) { try { const res = await fetch(url); if (!res.ok) throw new Error(`${errorMessage}. Status: ${res.status}`); return await res.json(); } catch (err) { showMessage(err.message, 'error'); return []; } }
        async function initializeImageLibrary() {
            const themePaths = await fetchFromApi(`/api/themes-translated?locale=${currentLocale}`, 'Failed to load themes');
            const selectors = [dom.themeSelect, dom.itemThemeSelect, dom.shapeImageThemeSelect, dom.shapeThemeSelect];
            selectors.forEach(sel => {
                const isModeSelector = sel.id.endsWith('ThemeSelect') && !sel.id.includes('Image');
                sel.innerHTML = `<option value="${isModeSelector ? 'manual' : 'all'}">${isModeSelector ? t('prepositions.manual.selection.option') : t('prepositions.all.themes.option')}</option>`;
                if (isModeSelector) sel.add(new Option(t('prepositions.all.themes.random'), 'all'));
            });

            if (Array.isArray(themePaths)) {
                themePaths.forEach(theme => {
                    const value = theme.value || theme;
                    const displayName = theme.displayName || theme.value || theme;
                    dom.themeSelect.add(new Option(displayName, value));
                    dom.shapeImageThemeSelect.add(new Option(displayName, value));
                    dom.itemThemeSelect.add(new Option(displayName, value));
                    dom.shapeThemeSelect.add(new Option(displayName, value));
                 });
            }
            await renderDictionary('item');
            await renderDictionary('shape');
        }

        function handleItemModeChange() { const isManual = dom.itemThemeSelect.value === 'manual'; dom.itemManualSelectionGroup.style.display = isManual ? 'block' : 'none'; updateGenerateButtonState(); }
        async function handleManualItemThemeChange() { manualSelectItemTheme = dom.themeSelect.value; dom.dictionary.innerHTML = `<p class="dictionary-message">Loading...</p>`; if (manualSelectItemTheme !== 'all') { const response = await fetchFromApi(`/api/images?theme=${encodeURIComponent(manualSelectItemTheme)}&locale=${currentLocale}`, `Failed to load images`); currentItemThemeImages = response.images || response; } await renderDictionary('item'); }
        
        function handleShapeModeChange() { const isManual = dom.shapeThemeSelect.value === 'manual'; dom.shapeManualSelectionGroup.style.display = isManual ? 'block' : 'none'; }
        async function handleManualShapeThemeChange() { manualSelectShapeTheme = dom.shapeImageThemeSelect.value; dom.shapeDictionary.innerHTML = `<p class="dictionary-message">Loading...</p`; if (manualSelectShapeTheme !== 'all') { const response = await fetchFromApi(`/api/images?theme=${encodeURIComponent(manualSelectShapeTheme)}&locale=${currentLocale}`, `Failed to load images`); currentShapeThemeImages = response.images || response; } await renderDictionary('shape'); }

        async function renderDictionary(type) { // type can be 'item' or 'shape'
            const isItem = type === 'item';
            const searchInput = isItem ? dom.searchInput : dom.shapeSearchInput;
            const dictionaryDiv = isItem ? dom.dictionary : dom.shapeDictionary;
            const theme = isItem ? manualSelectItemTheme : manualSelectShapeTheme;
            const themeImages = isItem ? currentItemThemeImages : currentShapeThemeImages;

            const query = searchInput.value.trim().toLowerCase();
            dictionaryDiv.innerHTML = '';
            let imagesToDisplay = [];

            if (theme === 'all') {
                if (!query) {
                    // Load default theme (animals) when no search query
                    dictionaryDiv.innerHTML = `<p class="dictionary-message">${t('prepositions.msg.loading.default')}</p>`;
                    try {
                        const response = await fetchFromApi(`/api/images?theme=animals&locale=${currentLocale}`, `Failed to load default images`);
                        imagesToDisplay = response.images || response;
                    } catch (err) {
                        console.error("Error loading default images:", err);
                        dictionaryDiv.innerHTML = `<p class="dictionary-message">Type to search all images.</p>`;
                        return;
                    }
                } else {
                    dictionaryDiv.innerHTML = `<p class="dictionary-message">Searching...</p>`;
                    const response = await fetchFromApi(`/api/images?search=${encodeURIComponent(query)}&locale=${currentLocale}`, `Failed to search`);
                    imagesToDisplay = response.images || response;
                }
            } else {
                // For specific theme, we need to load the images if not already loaded
                if (!themeImages || themeImages.length === 0) {
                    dictionaryDiv.innerHTML = `<p class="dictionary-message">Loading theme images...</p>`;
                    const response = await fetchFromApi(`/api/images?theme=${encodeURIComponent(theme)}&locale=${currentLocale}`, `Failed to load theme images`);
                    const loadedImages = response.images || response;
                    if (isItem) {
                        currentItemThemeImages = loadedImages;
                    } else {
                        currentShapeThemeImages = loadedImages;
                    }
                    imagesToDisplay = query ? loadedImages.filter(img => {
                        const displayName = img.name || img.word;
                        return displayName.toLowerCase().includes(query);
                    }) : loadedImages;
                } else {
                    imagesToDisplay = query ? themeImages.filter(img => {
                        const displayName = img.name || img.word;
                        return displayName.toLowerCase().includes(query);
                    }) : themeImages;
                }
            }
            const allAvailableImages = [...imagesToDisplay, ...uploadedImages.filter(img => {
                const displayName = img.name || img.word;
                return displayName.toLowerCase().includes(query);
            })];
            
            if (allAvailableImages.length === 0) { dictionaryDiv.innerHTML = `<p class="dictionary-message">No images found.</p>`; return; }

            allAvailableImages.sort((a, b) => {
                const aName = a.name || a.word;
                const bName = b.name || b.word;
                return aName.localeCompare(bName);
            }).forEach(imgData => {
                const item = document.createElement('div');
                item.className = 'dictionary-item';
                const currentSelection = isItem ? selectedItems : selectedShapes;
                if (currentSelection.some(i => i.path === imgData.path)) item.classList.add('selected');
                const displayName = imgData.name || imgData.word;
                item.innerHTML = `<img src="${imgData.path}" alt="${displayName}"/><span>${displayName}</span>`;
                item.onclick = () => handleDictionaryItemClick(imgData, item, type);
                dictionaryDiv.appendChild(item);
            });
        }
        
        function handleDictionaryItemClick(imgData, itemElement, type) {
            const isItem = type === 'item';
            const selectionArray = isItem ? selectedItems : selectedShapes;
            const countEl = isItem ? dom.selectedCount : dom.selectedShapesCount;
            const exerciseCount = parseInt(dom.exerciseCount.value, 10);

            const index = selectionArray.findIndex(i => i.path === imgData.path);
            if (index > -1) {
                selectionArray.splice(index, 1);
                itemElement.classList.remove('selected');
            } else {
                if (selectionArray.length >= exerciseCount) { showMessage(t('prepositions.msg.max.selection', { exerciseCount, type }), 'error'); return; }
                selectionArray.push(imgData);
                itemElement.classList.add('selected');
            }
            countEl.textContent = `Selected: ${selectionArray.length}/${exerciseCount}`;
            if (isItem) updateGenerateButtonState();
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if (!files || files.length === 0) {
                dom.customFileStatus.textContent = t('prepositions.upload.no.file');
                return;
            }

            // Update custom file status
            const count = files.length;
            if (count === 1) {
                dom.customFileStatus.textContent = files[0].name;
            } else {
                dom.customFileStatus.textContent = t('prepositions.upload.files.selected', {count: count});
            }

            Promise.all(Array.from(files).map(file => new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (event) => resolve({ word: file.name.split('.')[0], path: event.target.result, isUploaded: true });
                reader.onerror = reject;
                reader.readAsDataURL(file);
            }))).then(newImages => {
                uploadedImages.push(...newImages);
                renderUploadedImages();
                renderDictionary('item');
                renderDictionary('shape');
            });
            e.target.value = '';
            dom.customFileStatus.textContent = t('prepositions.upload.no.file'); // Reset status
        }
        function renderUploadedImages() { dom.uploadedImagesPreview.innerHTML = ""; if (uploadedImages.length === 0) { dom.uploadedImagesPreview.innerHTML = `<p class="dictionary-message">Your uploaded images appear here.</p>`; return; } uploadedImages.forEach(imgData => { const displayName = imgData.name || imgData.word; const item = document.createElement('div'); item.className = 'dictionary-item'; item.innerHTML = `<img src="${imgData.path}" alt="${displayName}"/><span>${displayName}</span>`; item.onclick = () => handleDictionaryItemClick(imgData, item, 'item'); dom.uploadedImagesPreview.appendChild(item); }); }

        // --- Core Generation Logic ---
        async function generateWorksheet(preserveTransforms = true) {
            isGenerating = true;  // Prevent saveState during generation
            showMessage(t("prepositions.msg.generating"), "info", 0);

            // --- Part B, Step 1: Preserve State ---
            const oldTransforms = {};
            if (preserveTransforms) {
                worksheetCanvas.getObjects().forEach(obj => {
                    if (obj.isGeneratedItem && obj.originalIndex != null) {
                        oldTransforms[obj.originalIndex] = {
                            left: obj.left, top: obj.top,
                            scaleX: obj.scaleX, scaleY: obj.scaleY,
                            angle: obj.angle
                        };
                    }
                });
            }
            const userAddedObjects = worksheetCanvas.getObjects().filter(o => !o.isGeneratedItem && !o.isAnswerKeyItem && !o.isTemplate && !o.isPageBorder && !o.isHeaderElement && !o.isHeaderDesc);
            // NOTE: isBorder and isBackground are NOT excluded - users can now fully control these elements

            // --- Part B, Step 2: Precise Removal ---
            const oldGeneratedItems = worksheetCanvas.getObjects().filter(o => o.isGeneratedItem);
            oldGeneratedItems.forEach(o => worksheetCanvas.remove(o));

            // Remove old headers and borders
            const oldHeaders = worksheetCanvas.getObjects().filter(o => o.isHeaderElement || o.isPageBorder || o.isHeaderDesc);
            oldHeaders.forEach(o => worksheetCanvas.remove(o));
            
            const exerciseCount = parseInt(dom.exerciseCount.value, 10);
            const selectedPreps = Array.from(dom.prepositionsGrid.querySelectorAll('input:checked')).map(cb => cb.value);
            if (selectedPreps.length === 0) { showMessage(t('prepositions.msg.select.preposition'), 'error'); return; }

            let itemsToUse = [];
            if (dom.itemThemeSelect.value === 'manual') {
                if (selectedItems.length < exerciseCount) { showMessage(t('prepositions.msg.select.items', { exerciseCount }), 'error'); return; }
                itemsToUse = shuffleArray(selectedItems).slice(0, exerciseCount);
            } else {
                let themeResponse = (dom.itemThemeSelect.value === 'all') ? await fetchFromApi(`/api/images?search=&locale=${currentLocale}`, 'Failed to fetch all images') : await fetchFromApi(`/api/images?theme=${encodeURIComponent(dom.itemThemeSelect.value)}&locale=${currentLocale}`, 'Failed to fetch theme images');
                let themeImages = themeResponse.images || themeResponse;
                const allAvailable = [...themeImages, ...uploadedImages];
                if (allAvailable.length < exerciseCount) { showMessage(t('prepositions.msg.insufficient.images', { count: allAvailable.length }), 'error'); return; }
                itemsToUse = shuffleArray(allAvailable).slice(0, exerciseCount);
            }

            let shapesToUse = [];
            if (dom.shapeThemeSelect.value === 'manual') {
                shapesToUse = [...selectedShapes];
            } else {
                let themeResponse = (dom.shapeThemeSelect.value === 'all') ? await fetchFromApi(`/api/images?search=&locale=${currentLocale}`, 'Failed to fetch all images') : await fetchFromApi(`/api/images?theme=${encodeURIComponent(dom.shapeThemeSelect.value)}&locale=${currentLocale}`, 'Failed to fetch shape images');
                let themeImages = themeResponse.images || themeResponse;
                const allAvailable = [...themeImages, ...uploadedImages];
                if (allAvailable.length > 0) shapesToUse = shuffleArray(allAvailable).slice(0, exerciseCount);
            }
            const defaultShapesPool = shuffleArray(DEFAULT_SHAPES);
            while(shapesToUse.length < exerciseCount) {
                shapesToUse.push({ isDefault: true, name: defaultShapesPool.pop() || 'circle' });
            }

            lastGeneratedAssignments = [];
            if (selectedPreps.length === PREPOSITIONS.length && exerciseCount === PREPOSITIONS.length) {
                const shuffledPreps = shuffleArray(PREPOSITIONS);
                for(let i=0; i < exerciseCount; i++) {
                    lastGeneratedAssignments.push({ item: itemsToUse[i], shape: shapesToUse[i], preposition: shuffledPreps[i] });
                }
            } else {
                for(let i=0; i < exerciseCount; i++) {
                    lastGeneratedAssignments.push({ item: itemsToUse[i], shape: shapesToUse[i], preposition: selectedPreps[i % selectedPreps.length] });
                }
            }

            // Check exercise mode
            const exerciseMode = dom.exerciseModeSelect.value;
            const newItems = (exerciseMode === 'multiplechoice')
                ? await createMultipleChoiceExercises(false)
                : await createExerciseItems(false);

            // --- Part B, Step 3 & 4: Re-apply and Finalize ---
            newItems.forEach(item => {
                if (preserveTransforms && oldTransforms[item.originalIndex]) {
                    item.set(oldTransforms[item.originalIndex]);
                }
                worksheetCanvas.add(item);
            });

            // Add header and border elements
            const headerElements = createHeaderGroup(worksheetCanvas);
            headerElements.forEach(el => worksheetCanvas.add(el));

            if (dom.includeNameDateCheckbox.checked && !worksheetCanvas.getObjects().find(o=>o.isNameDate)) {
                addNameDateGroup(worksheetCanvas);
            }

            enforceLayerOrder(worksheetCanvas);
            userAddedObjects.forEach(obj => worksheetCanvas.bringToFront(obj));
            worksheetCanvas.renderAll();
            
            updateDownloadButtonsState(true, !!(answerKeyCanvas.getObjects().find(o => o.isAnswerKeyItem)));
            updateGenerateButtonState();
            showMessage(t("prepositions.msg.worksheet.generated"), "success");

            // Re-enable saveState and save current state for undo/redo
            isGenerating = false;
            saveState();
        }

        async function generateAnswerKey(preserveTransforms = true) {
            if (!lastGeneratedAssignments) {
                showMessage(t("prepositions.msg.generate.first"), "error");
                return;
            }
            isGenerating = true;  // Prevent saveState during generation
            showMessage(t("prepositions.msg.generating.answer"), "info", 0);

            // --- Part C, Step 1: Preserve State ---
            const oldTransforms = {};
            if (preserveTransforms) {
                answerKeyCanvas.getObjects().forEach(obj => {
                    if (obj.isAnswerKeyItem && obj.originalIndex != null) {
                        oldTransforms[obj.originalIndex] = {
                            left: obj.left, top: obj.top,
                            scaleX: obj.scaleX, scaleY: obj.scaleY,
                            angle: obj.angle
                        };
                    }
                });
            }
            const userAddedObjects = answerKeyCanvas.getObjects().filter(o => !o.isAnswerKeyItem && !o.isGeneratedItem && !o.isBorder && !o.isBackground && !o.isTemplate && !o.isPageBorder && !o.isHeaderElement && !o.isHeaderDesc);

            // --- Part C, Step 2: Precise Removal ---
            const objectsToRemove = answerKeyCanvas.getObjects().filter(o => o.isAnswerKeyItem || o.isBorder || o.isBackground || o.isTemplate || o.isPageBorder || o.isHeaderElement || o.isHeaderDesc);
            objectsToRemove.forEach(o => answerKeyCanvas.remove(o));
            
            answerKeyCanvas.backgroundColor = worksheetCanvas.backgroundColor;

            // --- Part C, Step 3: Clone Decoratives ---
            const template = worksheetCanvas.getObjects().find(o => o.isTemplate);
            if (template) {
                await new Promise(resolve => template.clone(cloned => {
                    cloned.set({ isTemplate: true });
                    answerKeyCanvas.add(cloned);
                    resolve();
                }));
            }
            const background = worksheetCanvas.getObjects().find(o => o.isBackground);
            if (background) {
                await new Promise(resolve => background.clone(cloned => {
                    cloned.set({ isBackground: true });
                    answerKeyCanvas.add(cloned);
                    resolve();
                }));
            }
            const border = worksheetCanvas.getObjects().find(o => o.isBorder);
             if (border) {
                await new Promise(resolve => border.clone(cloned => {
                    cloned.set({ isBorder: true });
                    answerKeyCanvas.add(cloned);
                    resolve();
                }));
            }

            // Clone header and border elements from worksheet
            const headerElements = worksheetCanvas.getObjects().filter(o => o.isHeaderElement || o.isPageBorder || o.isHeaderDesc);
            for (const headerEl of headerElements) {
                await new Promise(resolve => headerEl.clone(cloned => {
                    cloned.set({
                        isHeaderElement: headerEl.isHeaderElement,
                        isPageBorder: headerEl.isPageBorder,
                        isHeaderDesc: headerEl.isHeaderDesc
                    });
                    answerKeyCanvas.add(cloned);
                    resolve();
                }));
            }

            // Check exercise mode
            const exerciseMode = dom.exerciseModeSelect.value;
            const newItems = (exerciseMode === 'multiplechoice')
                ? await createMultipleChoiceExercises(true)
                : await createExerciseItems(true);

            // --- Part C, Step 4: Re-apply and Finalize ---
            newItems.forEach(item => {
                if (preserveTransforms && oldTransforms[item.originalIndex]) {
                    item.set(oldTransforms[item.originalIndex]);
                }
                answerKeyCanvas.add(item);
            });

            enforceLayerOrder(answerKeyCanvas);
            userAddedObjects.forEach(obj => answerKeyCanvas.bringToFront(obj));
            answerKeyCanvas.renderAll();

            updateDownloadButtonsState(true, true);
            showMessage(t("prepositions.msg.answer.ready"), "success");
            document.querySelector('.tab-button[data-tab="answerKeyTab"]').click();

            // Re-enable saveState and save current state for undo/redo
            isGenerating = false;
            saveState();
        }

        // CRITICAL: Paper switching regeneration system (follows wordsearch pattern EXACTLY)
        async function regenerateHeadersOnly() {
            // Only regenerate if worksheet exists
            if (!lastGeneratedAssignments) return;

            // Regenerate ENTIRE worksheet (not just headers!)
            // CRITICAL: Pass false to NOT preserve transforms during paper size change
            await generateWorksheet(false);

            // Regenerate answer key if it exists
            const hasAnswerKey = answerKeyCanvas && answerKeyCanvas.getObjects().some(o => o.isAnswerKeyItem);
            if (hasAnswerKey) {
                // CRITICAL: Pass false to NOT preserve transforms during paper size change
                await generateAnswerKey(false);
            }
        }

        async function createExerciseItems(isAnswerKey) {
            const exerciseItems = [];
            const isLandscape = currentCanvasConfig.width > currentCanvasConfig.height;
            const isPortrait = !isLandscape;

            // Constants matching whiteboard positioning
            const HEADER_END = isPortrait ? 175 : 155; // Landscape: moved up 20px
            const BORDER_MARGIN = 34;
            const SIDE_PADDING = 40;
            const BOTTOM_RESERVE = isPortrait ? 180 : 221;

            // Calculate whiteboard dimensions (matches addTemplateToCanvases, +5% width, portrait -10% height, landscape +30% height)
            const availableWidth = (currentCanvasConfig.width - (BORDER_MARGIN + SIDE_PADDING) * 2) * 1.05;
            const heightMultiplier = isPortrait ? 0.9 : 1.3;
            const whiteboardHeight = (currentCanvasConfig.height - HEADER_END - BOTTOM_RESERVE) * heightMultiplier;

            const gridCols = 4;
            const gridRows = Math.ceil(lastGeneratedAssignments.length / gridCols);

            // Visual grid positioning - spread across full whiteboard with margins (reduced by 10%)
            const whiteboardTop = HEADER_END;
            const gridTopMargin = 27;
            const gridBottomMargin = 27;
            const gridSideMargin = 40;

            const gridStartY = whiteboardTop + gridTopMargin;
            const gridWidth = availableWidth - (gridSideMargin * 2);
            const gridHeight = whiteboardHeight - gridTopMargin - gridBottomMargin;

            const cellWidth = gridWidth / gridCols;
            const cellHeight = gridHeight / gridRows;

            const itemPromises = lastGeneratedAssignments.map((assignment, i) => {
                const col = i % gridCols;
                const row = Math.floor(i / gridCols);

                // Position cells in grid centered within whiteboard
                const gridStartX = BORDER_MARGIN + SIDE_PADDING + gridSideMargin;
                let cellY = gridStartY + row * cellHeight;

                // Move bottom row up 20px in portrait mode
                if (isPortrait && row === gridRows - 1) {
                    cellY -= 20;
                }

                const cellX = gridStartX + col * cellWidth;
                return createCellGroup(assignment, cellX, cellY, cellWidth, cellHeight, i, isAnswerKey);
            });
            const createdGroups = await Promise.all(itemPromises);
            exerciseItems.push(...createdGroups);
            
            const qaTextParts = [];
            for(let i=0; i < lastGeneratedAssignments.length; i++){
                const assignment = lastGeneratedAssignments[i];
                const shapeNameEnglish = assignment.shape.isDefault ? assignment.shape.name : assignment.shape.word;

                // Translate shape name to current locale
                const shapeName = assignment.shape.isDefault
                    ? (SHAPE_TRANSLATIONS[shapeNameEnglish]?.[currentLocale] || shapeNameEnglish)
                    : shapeNameEnglish;

                // Get translations for current language
                const isText = EXERCISE_TRANSLATIONS['is'][currentLocale] || 'is';
                const theText = EXERCISE_TRANSLATIONS['the'][currentLocale] || 'the';
                const prepositionText = PREPOSITION_TRANSLATIONS[assignment.preposition][currentLocale] || assignment.preposition;

                // For Finnish, skip article if it's "-"
                const articlePart = theText === '-' ? '' : `${theText} `;

                const textTemplate = isAnswerKey
                    ? `{img} ${isText} ${prepositionText} ${articlePart}${assignment.preposition === 'between' ? pluralizeShape(shapeNameEnglish, currentLocale) : shapeName}.`
                    : `{img} ${isText} __________ ${articlePart}${assignment.preposition === 'between' ? pluralizeShape(shapeNameEnglish, currentLocale) : shapeName}.`;
                    
                qaTextParts.push({image: assignment.item, template: textTemplate});
            }

            const qaElements = await buildQuestionBlock(qaTextParts, isAnswerKey);

            // Position Q&A block BELOW the whiteboard with appropriate gap
            const whiteboardEnd = HEADER_END + whiteboardHeight;

            let qaBlockY;
            if (isLandscape) {
                // Landscape: Position QA to be 20px from bottom border
                // Estimate QA block height (8 items in 2 columns = 4 rows, ~22px per row including spacing)
                const estimatedQAHeight = Math.ceil(lastGeneratedAssignments.length / 2) * 22;
                qaBlockY = currentCanvasConfig.height - BORDER_MARGIN - 20 - estimatedQAHeight;
            } else {
                // Portrait: Add comfortable gap between whiteboard and Q&A text
                const gapAfterWhiteboard = 25;
                qaBlockY = whiteboardEnd + gapAfterWhiteboard;
            }

            // Adjust Y position for all Q&A elements
            qaElements.forEach(element => {
                element.set({ top: element.top + qaBlockY });
            });
            
            exerciseItems.push(...qaElements);

            return exerciseItems;
        }

        async function createCellGroup(assignment, x, y, cellW, cellH, index, isAnswerKey) {
            const shapePath = assignment.shape.isDefault ? `/images/prepositions/${assignment.shape.name}.png` : assignment.shape.path;
            const shapeImg = await loadImage(shapePath);
            const itemImg = await loadImage(assignment.item.path);
            const prep = assignment.preposition;

            shapeImg.set({ originX: 'center', originY: 'center' });
            itemImg.set({ originX: 'center', originY: 'center' });

            const baseObjectSizeForCellFit = Math.min(cellW, cellH) * 0.5; 
            
            itemImg.scaleToHeight(baseObjectSizeForCellFit);
            shapeImg.scaleToHeight(baseObjectSizeForCellFit);

            const itemsToGroup = [];
            let bypassFinalScaling = false;

            switch (prep) {
                case 'in': shapeImg.scaleToHeight(cellH * 0.7); itemImg.scaleToHeight(shapeImg.getScaledHeight() * 0.4); itemsToGroup.push(shapeImg, itemImg); break;
                case 'on top of': const g1 = -10, cH1 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g1; itemImg.set({ top: -(cH1 / 2 - itemImg.getScaledHeight() / 2) }); shapeImg.set({ top: (cH1 / 2 - shapeImg.getScaledHeight() / 2) }); itemsToGroup.push(shapeImg, itemImg); break;
                case 'under': const g2 = 20, cH2 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g2; shapeImg.set({ top: -(cH2 / 2 - shapeImg.getScaledHeight() / 2) }); itemImg.set({ top: (cH2 / 2 - itemImg.getScaledHeight() / 2) }); itemsToGroup.push(itemImg, shapeImg); break;
                case 'next to':
                    bypassFinalScaling = true;
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(baseObjectSizeForCellFit);
                    // Position with 30% overlap for closer appearance
                    const widthI_nextto = itemImg.getScaledWidth();
                    const widthS_nextto = shapeImg.getScaledWidth();
                    const overlap_nextto = Math.min(widthI_nextto, widthS_nextto) * 0.3;
                    const totalWidth_nextto = widthI_nextto + widthS_nextto - overlap_nextto;
                    // Item on left, shape on right with 30% overlap
                    itemImg.set({ left: -totalWidth_nextto/2 + widthI_nextto/2 });
                    shapeImg.set({ left: -totalWidth_nextto/2 + widthI_nextto - overlap_nextto + widthS_nextto/2 });
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'behind':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(itemImg.getScaledHeight() * 0.7);
                    // Position for 100% overlap - centers aligned with slight offset
                    const widthI_behind = itemImg.getScaledWidth();
                    const widthS_behind = shapeImg.getScaledWidth();
                    // Slight horizontal offset to show depth
                    const offsetBehind = Math.min(widthS_behind * 0.15, 15);
                    shapeImg.set({
                        top: (itemImg.getScaledHeight() - shapeImg.getScaledHeight()) / 2,
                        left: offsetBehind
                    });
                    itemImg.set({ left: -offsetBehind });
                    // Z-order: item BEHIND shape (item rendered first)
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'between': bypassFinalScaling = true; itemImg.scaleToHeight(baseObjectSizeForCellFit); shapeImg.scaleToHeight(baseObjectSizeForCellFit); const shape2 = await loadImage(shapePath); shape2.set({ originX: 'center', originY: 'center' }).scaleToHeight(baseObjectSizeForCellFit); const g4 = -30, iW = itemImg.getScaledWidth(), sW = shapeImg.getScaledWidth(); shapeImg.set({ left: -(iW / 2 + g4 + sW / 2) }); itemImg.set({ left: 0 }); shape2.set({ left: iW / 2 + g4 + sW / 2 }); itemsToGroup.push(shapeImg, itemImg, shape2); break;
                case 'above': const g5 = 20, cH5 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g5; itemImg.set({ top: -(cH5 / 2 - itemImg.getScaledHeight() / 2) }); shapeImg.set({ top: (cH5 / 2 - itemImg.getScaledHeight() / 2) }); itemsToGroup.push(itemImg, shapeImg); break;
                case 'in front of':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(itemImg.getScaledHeight() * 0.6);
                    // Position for 100% overlap - centers aligned with slight offset
                    const widthI_front = itemImg.getScaledWidth();
                    const widthS_front = shapeImg.getScaledWidth();
                    // Slight horizontal offset to show depth
                    const offsetFront = Math.min(widthS_front * 0.15, 15);
                    shapeImg.set({
                        top: (itemImg.getScaledHeight() - shapeImg.getScaledHeight()) / 2,
                        left: -offsetFront
                    });
                    itemImg.set({ left: offsetFront });
                    // Z-order: item IN FRONT of shape (shape rendered first)
                    itemsToGroup.push(shapeImg, itemImg);
                    break;
                default: itemsToGroup.push(itemImg, shapeImg); break;
            }
            
            let finalGroupObjects = itemsToGroup;
            // ALWAYS apply final scaling to ensure exercises fit within cells
            const tempGroup = new fabric.Group(itemsToGroup, { objectCaching: false });
            // Use 0.85 for more safety margin to prevent overlap
            const scaleFactor = Math.min((cellW * 0.85) / tempGroup.width, (cellH * 0.85) / tempGroup.height);
            tempGroup.scale(scaleFactor);
            finalGroupObjects = tempGroup.destroy().getObjects();

            return new fabric.Group(finalGroupObjects, {
                left: x + cellW / 2, top: y + cellH / 2, originX: 'center', originY: 'center',
                selectable: true, evented: true, objectCaching: false,
                isGeneratedItem: !isAnswerKey, isAnswerKeyItem: isAnswerKey, originalIndex: index,
                borderColor: 'var(--app-accent-primary)', cornerColor: 'var(--app-accent-primary)',
                cornerSize: 8, transparentCorners: false, cornerStyle: 'circle'
            });
        }

        async function buildQuestionBlock(qaItems, isAnswerKey) {
            const allElements = [];
            const lineSpacing = 13;
            const qaGridCols = 2;
            const textBlockMaxWidth = currentCanvasConfig.width * 0.9; 
            const qaColumnWidth = textBlockMaxWidth / qaGridCols;
            let currentYs = Array(qaGridCols).fill(0);
            
            // Calculate base position for Q&A block - ensure it doesn't overlap border
            const baseLeft = Math.max(50, currentCanvasConfig.width * 0.08); // At least 50px from left edge
            
            for (let i = 0; i < qaItems.length; i++) {
                const item = qaItems[i];
                const fabImage = await loadImage(item.image.path);
                fabImage.scaleToHeight(18);

                const exerciseNumber = new fabric.Text(`${i + 1}.`, { 
                    fontSize: 14, fontFamily: 'Arial', fill: '#000000'
                });
                
                const textParts = item.template.split('{img}');
                const textBeforeImage = textParts[0]; 
                const textAfterImage = textParts[1];
                
                // Create editable text
                const mainQuestionText = new fabric.Textbox(`${textBeforeImage}${textAfterImage}`, {
                    fontSize: 14, fontFamily: 'Arial',
                    width: qaColumnWidth - exerciseNumber.width - fabImage.getScaledWidth() - 20,
                    splitByGrapheme: true, fill: '#000000',
                    editable: true,  // Make text editable
                    selectable: true,
                    evented: true,
                    isExerciseText: true,  // Mark as exercise text for identification
                    borderColor: '#007aff',
                    cornerColor: '#007aff',
                    cornerSize: 6,
                    transparentCorners: false,
                    cornerStyle: 'circle'
                });
                
                // Calculate positions
                const col = i % qaGridCols;
                const currentColumnY = currentYs[col];
                const colX = baseLeft + (col * qaColumnWidth);
                
                // Position elements for grouping
                exerciseNumber.set({ 
                    left: 0,
                    top: (Math.max(fabImage.getScaledHeight(), exerciseNumber.height) - exerciseNumber.height) / 2
                });
                
                fabImage.set({ 
                    left: exerciseNumber.width + 5,
                    top: (Math.max(fabImage.getScaledHeight(), exerciseNumber.height) - fabImage.getScaledHeight()) / 2
                });
                
                // Create group for number and image (editable as a block)
                const numberImageGroup = new fabric.Group([exerciseNumber, fabImage], {
                    left: colX,
                    top: currentColumnY + (mainQuestionText.height - Math.max(fabImage.getScaledHeight(), exerciseNumber.height)) / 2,
                    selectable: true,
                    evented: true,
                    isGeneratedItem: !isAnswerKey, 
                    isAnswerKeyItem: isAnswerKey,
                    isNumberImageGroup: true,
                    borderColor: '#28a745',
                    cornerColor: '#28a745',
                    cornerSize: 6,
                    transparentCorners: false,
                    cornerStyle: 'circle'
                });
                
                // Position text separately (remains individually editable)
                mainQuestionText.set({ 
                    left: colX + numberImageGroup.width + 10,
                    top: currentColumnY,
                    isGeneratedItem: !isAnswerKey, 
                    isAnswerKeyItem: isAnswerKey
                });
                
                // Add group and text separately
                allElements.push(numberImageGroup, mainQuestionText);
                currentYs[col] += mainQuestionText.height + lineSpacing;
            }

            // Return elements array instead of group to maintain text editability
            return allElements;
        }

        // Multiple Choice Exercise Generation Function
        async function createMultipleChoiceExercises(isAnswerKey) {
            const exerciseItems = [];
            const isLandscape = currentCanvasConfig.width > currentCanvasConfig.height;
            const isPortrait = !isLandscape;

            // Constants matching whiteboard positioning
            const HEADER_END = isPortrait ? 175 : 155;
            const BORDER_MARGIN = 34;
            const SIDE_PADDING = 40;

            // Calculate available space
            const leftMargin = BORDER_MARGIN + SIDE_PADDING;
            const rightMargin = BORDER_MARGIN + SIDE_PADDING;
            const availableWidth = currentCanvasConfig.width - leftMargin - rightMargin;

            // Layout: Left 30% for prepositions, Right 70% for visual options
            const prepTextWidth = availableWidth * 0.3;
            const visualsWidth = availableWidth * 0.7;
            const prepTextX = leftMargin;
            const visualsX = leftMargin + prepTextWidth + 20; // 20px gap

            // Calculate vertical spacing
            const totalHeight = currentCanvasConfig.height - HEADER_END - BORDER_MARGIN - 60;
            const rowHeight = totalHeight / lastGeneratedAssignments.length;

            let currentY = HEADER_END + 30;

            for (let i = 0; i < lastGeneratedAssignments.length; i++) {
                const assignment = lastGeneratedAssignments[i];
                const prepositionText = PREPOSITION_TRANSLATIONS[assignment.preposition][currentLocale] || assignment.preposition;

                // Create preposition text on the left
                const prepText = new fabric.Text(`${i + 1}. ${prepositionText}`, {
                    left: prepTextX,
                    top: currentY + (rowHeight / 2) - 10,
                    fontSize: 16,
                    fontFamily: 'Arial',
                    fill: '#000000',
                    fontWeight: 'bold',
                    selectable: true,
                    evented: true,
                    isGeneratedItem: !isAnswerKey,
                    isAnswerKeyItem: isAnswerKey
                });
                exerciseItems.push(prepText);

                // Create 3 visual options
                const correctOption = await createCellVisual(assignment, visualsWidth / 3, rowHeight * 0.8, 0, isAnswerKey);

                // Generate 2 distractor options with different prepositions
                const allPreps = [...PREPOSITIONS];
                const distractorPreps = allPreps.filter(p => p !== assignment.preposition);
                const shuffledDistractors = shuffleArray(distractorPreps).slice(0, 2);

                const distractor1Assignment = { ...assignment, preposition: shuffledDistractors[0] };
                const distractor2Assignment = { ...assignment, preposition: shuffledDistractors[1] };

                const distractor1 = await createCellVisual(distractor1Assignment, visualsWidth / 3, rowHeight * 0.8, 1, isAnswerKey);
                const distractor2 = await createCellVisual(distractor2Assignment, visualsWidth / 3, rowHeight * 0.8, 2, isAnswerKey);

                // Randomize option positions if not answer key
                const options = isAnswerKey
                    ? [correctOption, distractor1, distractor2]
                    : shuffleArray([correctOption, distractor1, distractor2]);

                // Position the 3 options horizontally
                const optionWidth = visualsWidth / 3;
                for (let j = 0; j < options.length; j++) {
                    const option = options[j];
                    option.group.set({
                        left: visualsX + (j * optionWidth) + (optionWidth / 2),
                        top: currentY + (rowHeight / 2),
                        originalIndex: i * 10 + j // Unique index for each option
                    });

                    // Add circle overlay for "circle the correct answer" concept
                    if (!isAnswerKey || (isAnswerKey && option.isCorrect)) {
                        const circleRadius = Math.min(optionWidth, rowHeight * 0.8) * 0.6;
                        const circle = new fabric.Circle({
                            left: visualsX + (j * optionWidth) + (optionWidth / 2),
                            top: currentY + (rowHeight / 2),
                            radius: circleRadius,
                            fill: 'transparent',
                            stroke: isAnswerKey && option.isCorrect ? '#00ff00' : '#cccccc',
                            strokeWidth: isAnswerKey && option.isCorrect ? 3 : 1,
                            originX: 'center',
                            originY: 'center',
                            selectable: false,
                            evented: false,
                            isGeneratedItem: !isAnswerKey,
                            isAnswerKeyItem: isAnswerKey
                        });
                        exerciseItems.push(circle);
                    }

                    exerciseItems.push(option.group);
                }

                currentY += rowHeight;
            }

            return exerciseItems;
        }

        // Helper function to create a single visual representation
        async function createCellVisual(assignment, cellW, cellH, optionIndex, isAnswerKey) {
            const shapePath = assignment.shape.isDefault ? `/images/prepositions/${assignment.shape.name}.png` : assignment.shape.path;
            const shapeImg = await loadImage(shapePath);
            const itemImg = await loadImage(assignment.item.path);
            const prep = assignment.preposition;

            shapeImg.set({ originX: 'center', originY: 'center' });
            itemImg.set({ originX: 'center', originY: 'center' });

            const baseObjectSizeForCellFit = Math.min(cellW, cellH) * 0.4;

            itemImg.scaleToHeight(baseObjectSizeForCellFit);
            shapeImg.scaleToHeight(baseObjectSizeForCellFit);

            const itemsToGroup = [];

            switch (prep) {
                case 'in':
                    shapeImg.scaleToHeight(cellH * 0.5);
                    itemImg.scaleToHeight(shapeImg.getScaledHeight() * 0.4);
                    itemsToGroup.push(shapeImg, itemImg);
                    break;
                case 'on top of':
                    const g1 = -10;
                    const cH1 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g1;
                    itemImg.set({ top: -(cH1 / 2 - itemImg.getScaledHeight() / 2) });
                    shapeImg.set({ top: (cH1 / 2 - shapeImg.getScaledHeight() / 2) });
                    itemsToGroup.push(shapeImg, itemImg);
                    break;
                case 'under':
                    const g2 = 20;
                    const cH2 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g2;
                    shapeImg.set({ top: -(cH2 / 2 - shapeImg.getScaledHeight() / 2) });
                    itemImg.set({ top: (cH2 / 2 - itemImg.getScaledHeight() / 2) });
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'next to':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(baseObjectSizeForCellFit);
                    const widthI_nextto = itemImg.getScaledWidth();
                    const widthS_nextto = shapeImg.getScaledWidth();
                    const overlap_nextto = Math.min(widthI_nextto, widthS_nextto) * 0.3;
                    const totalWidth_nextto = widthI_nextto + widthS_nextto - overlap_nextto;
                    itemImg.set({ left: -totalWidth_nextto/2 + widthI_nextto/2 });
                    shapeImg.set({ left: -totalWidth_nextto/2 + widthI_nextto - overlap_nextto + widthS_nextto/2 });
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'behind':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(itemImg.getScaledHeight() * 0.7);
                    const widthI_behind = itemImg.getScaledWidth();
                    const widthS_behind = shapeImg.getScaledWidth();
                    const offsetBehind = Math.min(widthS_behind * 0.15, 15);
                    shapeImg.set({
                        top: (itemImg.getScaledHeight() - shapeImg.getScaledHeight()) / 2,
                        left: offsetBehind
                    });
                    itemImg.set({ left: -offsetBehind });
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'between':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(baseObjectSizeForCellFit);
                    const shape2 = await loadImage(shapePath);
                    shape2.set({ originX: 'center', originY: 'center' }).scaleToHeight(baseObjectSizeForCellFit);
                    const g4 = -30;
                    const iW = itemImg.getScaledWidth();
                    const sW = shapeImg.getScaledWidth();
                    shapeImg.set({ left: -(iW / 2 + g4 + sW / 2) });
                    itemImg.set({ left: 0 });
                    shape2.set({ left: iW / 2 + g4 + sW / 2 });
                    itemsToGroup.push(shapeImg, itemImg, shape2);
                    break;
                case 'above':
                    const g5 = 20;
                    const cH5 = itemImg.getScaledHeight() + shapeImg.getScaledHeight() + g5;
                    itemImg.set({ top: -(cH5 / 2 - itemImg.getScaledHeight() / 2) });
                    shapeImg.set({ top: (cH5 / 2 - itemImg.getScaledHeight() / 2) });
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
                case 'in front of':
                    itemImg.scaleToHeight(baseObjectSizeForCellFit);
                    shapeImg.scaleToHeight(itemImg.getScaledHeight() * 0.6);
                    const widthI_front = itemImg.getScaledWidth();
                    const widthS_front = shapeImg.getScaledWidth();
                    const offsetFront = Math.min(widthS_front * 0.15, 15);
                    shapeImg.set({
                        top: (itemImg.getScaledHeight() - shapeImg.getScaledHeight()) / 2,
                        left: -offsetFront
                    });
                    itemImg.set({ left: offsetFront });
                    itemsToGroup.push(shapeImg, itemImg);
                    break;
                default:
                    itemsToGroup.push(itemImg, shapeImg);
                    break;
            }

            // Apply final scaling to fit in cell
            const tempGroup = new fabric.Group(itemsToGroup, { objectCaching: false });
            const scaleFactor = Math.min((cellW * 0.75) / tempGroup.width, (cellH * 0.75) / tempGroup.height);
            tempGroup.scale(scaleFactor);
            const finalGroupObjects = tempGroup.destroy().getObjects();

            const visualGroup = new fabric.Group(finalGroupObjects, {
                originX: 'center',
                originY: 'center',
                selectable: true,
                evented: true,
                objectCaching: false,
                isGeneratedItem: !isAnswerKey,
                isAnswerKeyItem: isAnswerKey,
                borderColor: 'var(--app-accent-primary)',
                cornerColor: 'var(--app-accent-primary)',
                cornerSize: 8,
                transparentCorners: false,
                cornerStyle: 'circle'
            });

            return { group: visualGroup, isCorrect: optionIndex === 0 };
        }

        function addNameDateGroup(canvasInstance) { const nameText = new fabric.Textbox(t("prepositions.name.field"), { fontSize: 16, fontFamily: 'Arial' }); const dateText = new fabric.Textbox(t("prepositions.date.field"), { left: nameText.width + 30, fontSize: 16, fontFamily: 'Arial' }); const group = new fabric.Group([nameText, dateText], { left: 50, top: 20, isNameDate: true, borderColor: 'var(--app-accent-primary)', cornerColor: 'var(--app-accent-primary)', cornerSize: 8, transparentCorners: false, cornerStyle: 'circle' }); canvasInstance.add(group); }
        async function loadImage(url) { return new Promise((resolve) => fabric.Image.fromURL(url, resolve, { crossOrigin: 'anonymous' })); }

        // --- File Download ---
        async function getFabricCanvasDataURLWithOptions(canvasInstance, exportOpts) { canvasInstance.discardActiveObject().renderAll(); let dataURL = canvasInstance.toDataURL({ format: 'jpeg', quality: 1.0, multiplier: exportOpts.multiplier }); if (exportOpts.applyGrayscale) dataURL = await applyGrayscaleToDataURL(dataURL); return dataURL; }
        async function applyGrayscaleToDataURL(dataURL) { return new Promise((resolve) => { const img = new Image(); img.onload = () => { const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img, 0, 0); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data; for (let i = 0; i < data.length; i += 4) { const gray = data[i] * 0.2126 + data[i + 1] * 0.7152 + data[i + 2] * 0.0722; data[i] = data[i + 1] = data[i + 2] = gray; } ctx.putImageData(imageData, 0, 0); resolve(canvas.toDataURL('image/jpeg', 1.0)); }; img.crossOrigin = "Anonymous"; img.src = dataURL; }); }
        async function downloadImageFile(canvasToExport, baseFilename) { 
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                showMessage(t('prepositions.msg.empty.canvas'), 'error');
                return;
            }
            showMessage(t('prepositions.msg.preparing.jpeg'), 'info', 0); 
            const exportOpts = { multiplier: downloadMultiplier, applyGrayscale: dom.grayscaleToggle.checked }; 
            try { 
                const dataURL = await getFabricCanvasDataURLWithOptions(canvasToExport, exportOpts); 
                const link = document.createElement('a'); 
                link.download = `${baseFilename}.jpeg`; 
                link.href = dataURL; 
                link.click();
                showMessage(t('prepositions.msg.jpeg.initiated'), 'success');
            } catch (e) { 
                showMessage(t('prepositions.msg.jpeg.error', { message: e.message }), 'error'); 
            }
        }
        
    // Check if user is on free tier
    function isFreeTier() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('tier') === 'free';
    }

    // Add watermark to canvas before export
    function addWatermarkToCanvas(canvas) {
        if (!isFreeTier()) return;
        
        const watermarkText = new fabric.Text(t('prepositions.watermark.main'), {
            fontSize: 40,
            fill: 'rgba(0, 0, 0, 0.2)',
            angle: -45,
            left: canvas.width / 2,
            top: canvas.height / 2,
            originX: 'center',
            originY: 'center',
            selectable: false,
            evented: false,
            fontFamily: 'Arial, sans-serif',
            fontWeight: 'bold'
        });
        
        // Add multiple watermarks across the canvas
        const watermarks = [];
        const spacing = 250;
        for (let x = 0; x < canvas.width; x += spacing) {
            for (let y = 0; y < canvas.height; y += spacing) {
                const wm = new fabric.Text(t('prepositions.watermark.small'), {
                    fontSize: 20,
                    fill: 'rgba(0, 0, 0, 0.15)',
                    angle: -45,
                    left: x,
                    top: y,
                    selectable: false,
                    evented: false,
                    fontFamily: 'Arial, sans-serif'
                });
                watermarks.push(wm);
                canvas.add(wm);
            }
        }
        
        // Add main watermark
        canvas.add(watermarkText);
        canvas.renderAll();
        
        return { mainWatermark: watermarkText, watermarks };
    }

    // Remove watermark after export
    function removeWatermarkFromCanvas(canvas, watermarkData) {
        if (!watermarkData) return;
        
        if (watermarkData.mainWatermark) {
            canvas.remove(watermarkData.mainWatermark);
        }
        if (watermarkData.watermarks) {
            watermarkData.watermarks.forEach(wm => canvas.remove(wm));
        }
        canvas.renderAll();
    }

    // Override the original downloadPDF function if it exists, otherwise create it
    const originalDownloadPDF = typeof downloadPDF !== 'undefined' ? downloadPDF : null;
    if (originalDownloadPDF || true) {  // Always create the function
        window.downloadPDF = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('prepositions.msg.generate.content.first'), 'error');
            }
            showMessage(t('prepositions.msg.preparing.pdf'), 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const { jsPDF } = window.jspdf;
                // Use actual page dimensions from currentCanvasConfig
                const orientation = currentCanvasConfig.width > currentCanvasConfig.height ? 'l' : 'p';
                const pdf = new jsPDF({ 
                    orientation, 
                    unit: 'pt', 
                    format: [currentCanvasConfig.width, currentCanvasConfig.height] 
                });
                
                // Save current zoom and dimensions
                const currentZoom = canvasToExport.getZoom();
                const currentWidth = canvasToExport.getWidth();
                const currentHeight = canvasToExport.getHeight();
                
                // Reset to actual dimensions for export
                canvasToExport.setZoom(1);
                canvasToExport.setDimensions({
                    width: currentCanvasConfig.width,
                    height: currentCanvasConfig.height
                });

                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: dom.grayscaleToggle && dom.grayscaleToggle.checked 
                };
                
                const dataURL = await getFabricCanvasDataURLWithOptions(canvasToExport, exportOptions);
                pdf.addImage(dataURL, 'JPEG', 0, 0, currentCanvasConfig.width, currentCanvasConfig.height);
                
                // Restore display dimensions
                canvasToExport.setZoom(currentZoom);
                canvasToExport.setDimensions({
                    width: currentWidth,
                    height: currentHeight
                });
                canvasToExport.renderAll();
                
                pdf.save(fileName);
                showMessage(t('prepositions.msg.pdf.downloaded'), 'success');
            } catch(e) {
                showMessage(t('prepositions.msg.pdf.error'), 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

    // Override the original downloadJPEG function if it exists
    const originalDownloadJPEG = typeof downloadJPEG !== 'undefined' ? downloadJPEG : null;
    if (originalDownloadJPEG) {
        window.downloadJPEG = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('prepositions.msg.generate.worksheet.first'), 'error');
            }
            showMessage(t('prepositions.msg.preparing.jpeg'), 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked 
                };
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = fileName;
                link.click();
                showMessage(t('prepositions.msg.jpeg.initiated.alt'), 'success');
            } catch(e) { 
                showMessage(t('prepositions.msg.jpeg.error.simple'), 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

// Removed duplicate - using watermark-enabled version above
        
        // --- Clear & Reset ---
        function clearAll() {
            worksheetCanvas.clear(); answerKeyCanvas.clear();
            worksheetCanvas.backgroundColor = '#FFFFFF'; answerKeyCanvas.backgroundColor = '#FFFFFF';
            dom.pageColor.value = '#FFFFFF';
            lastGeneratedAssignments = null; selectedItems = []; selectedShapes = []; uploadedImages = [];
            dom.itemThemeSelect.value = 'manual'; dom.themeSelect.value = 'all'; dom.searchInput.value = '';
            dom.shapeThemeSelect.value = 'manual'; dom.shapeImageThemeSelect.value = 'all'; dom.shapeSearchInput.value = '';

            currentTemplatePath = '';
            currentBorderImagePath = '';
            currentBackgroundImagePath = '';

            const defaultTemplateOption = Array.from(dom.templateSelect.options).find(opt => opt.value.includes('whiteboard'));
            if (defaultTemplateOption) { dom.templateSelect.value = defaultTemplateOption.value; currentTemplatePath = defaultTemplateOption.value; }
            else { dom.templateSelect.value = ''; currentTemplatePath = ''; }
            if (currentTemplatePath) {
                addTemplateToCanvases(currentTemplatePath);
            }

            dom.borderThemeSelect.value = 'none'; dom.borderDictionary.innerHTML = `<p class="dictionary-message">${t('prepositions.border.message')}</p>`;
            dom.backgroundThemeSelect.value = 'none'; dom.backgroundDictionary.innerHTML = `<p class="dictionary-message">${t('prepositions.background.message')}</p>`;
            dom.includeNameDateCheckbox.checked = false; dom.grayscaleToggle.checked = false;
            dom.pageSizeSelect.value = "612x792"; updateCanvasDisplayDimensions(612,792, true); // Letter Portrait default
            dom.exerciseCount.value = 8;
            dom.prepositionsGrid.querySelectorAll('input').forEach(cb => cb.checked = true);

            handleItemModeChange(); handleShapeModeChange();
            renderDictionary('item'); renderDictionary('shape');
            renderUploadedImages(); 
            updateGenerateButtonState(); 
            updateDownloadButtonsState(false, false);
            showMessage(t("prepositions.msg.cleared"), "success");
        }

        async function generateInitialWorksheet() {
            try {
                console.log('Starting initial worksheet generation...');

                // Wait for themes to load
                let attempts = 0;
                const maxAttempts = 50;
                while (dom.itemThemeSelect.options.length <= 2 && attempts < maxAttempts) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }

                // Set page size to Letter portrait (already default)
                dom.pageSizeSelect.value = '612x792';
                currentCanvasConfig.width = 612;
                currentCanvasConfig.height = 792;
                updateCanvasDisplayDimensions(612, 792, true);

                // Set Animals theme
                dom.itemThemeSelect.value = 'animals';
                dom.itemThemeSelect.dispatchEvent(new Event('change'));

                // All prepositions are already checked by default (line 758)
                // Ensure all checkboxes are checked
                dom.prepositionsGrid.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);

                // Wait a bit for UI to update
                await new Promise(resolve => setTimeout(resolve, 200));

                // Generate worksheet
                await generateWorksheet();

                console.log('Initial worksheet generated successfully');
            } catch (error) {
                console.error('Error generating initial worksheet:', error);
            }
        }

        // Call initial worksheet generation after a delay
        setTimeout(() => generateInitialWorksheet(), 1000);

    </script>
</body>
</html>