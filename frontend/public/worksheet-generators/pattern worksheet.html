<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pattern Worksheet Generator</title>
  <script src="js/translations.js"></script>
  <script src="js/bulletproof-loader.js"></script>
  <script src="js/unified-language-manager.js"></script>
  <script src="js/border-background-sizer.js"></script>
  <script src="js/auto-fix-system.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;700&family=Fredoka:wght@400;500;600&family=Lexend+Deca&family=Nunito:wght@400;700&family=Quicksand:wght@300..700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" xintegrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    :root {
        /* Standardized Theme Colors */
        --app-font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --app-bg-dark: #2c2c2e;
        --app-surface-dark: #3a3a3e;
        --app-border-dark: #4a4a4a;
        --app-text-primary-dark-theme: #e0e0e0;
        --app-text-secondary-dark-theme: #a0a0a0;
        --app-bg-light: #f0f2f5;
        --app-surface-light: #ffffff;
        --app-border-light: #dce1e6;
        --app-text-primary-light-theme: #1c1c1e;
        --app-text-secondary-light-theme: #545458;
        --app-accent-primary: #007aff;
        --app-accent-primary-hover: #005ecb;
        --app-accent-danger: #ff3b30;
        --sidebar-width: 340px;
    }

    /* Global Reset & Layout */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--app-font-stack);
      display: flex;
      margin: 0;
      height: 100vh;
      background-color: var(--app-bg-light);
      overflow: hidden;
      color: var(--app-text-primary-light-theme);
      position: relative;
    }
    .layout {
        display: flex;
        flex: 1;
        overflow: hidden;
        height: 100vh;
        position: relative;
    }

    /* Sidebar Panel */
    .panel {
      width: var(--sidebar-width);
      min-width: var(--sidebar-width);
      background-color: var(--app-bg-dark);
      color: var(--app-text-primary-dark-theme);
      box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      overflow-y: hidden;
      z-index: 10;
      padding: 0;
      transition: transform 0.3s ease-in-out;
    }

    .panel-header {
        padding: 20px 25px;
        text-align: left;
        border-bottom: 1px solid var(--app-border-dark);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .panel-header h2 {
        font-size: 22px;
        font-weight: 600;
        color: var(--app-text-primary-dark-theme);
        margin: 0;
    }
    .panel-content {
        overflow-y: auto;
        flex-grow: 1;
        padding: 10px 15px;
    }

    /* Accordion Styles */
    .accordion-item {
        background-color: transparent;
        border: none;
        border-bottom: 1px solid var(--app-border-dark);
        margin-bottom: 0;
        border-radius: 0;
        overflow: hidden;
    }
    .accordion-item:last-child {
        border-bottom: none;
    }
    .accordion-button {
        background-color: transparent;
        color: var(--app-text-primary-dark-theme);
        width: 100%;
        border: none;
        text-align: left;
        padding: 18px 10px;
        font-size: 15px;
        font-weight: 500;
        cursor: pointer;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: background-color 0.15s ease;
    }
    .accordion-button:hover {
        background-color: rgba(255,255,255,0.05);
    }
    .accordion-button::after {
        content: '\f078';
        font-family: 'Font Awesome 5 Free';
        font-weight: 900;
        font-size: 12px;
        transition: transform 0.2s ease-in-out;
    }
    .accordion-button.active::after {
        transform: rotate(-180deg);
    }
    .accordion-content {
        padding: 10px 10px 20px 10px;
        display: none;
        background-color: transparent;
        border-top: none;
    }
    .accordion-content.active {
        display: block;
    }
     .accordion-content h4 {
        font-size: 13px;
        color: var(--app-text-secondary-dark-theme);
        margin-top: 15px;
        margin-bottom: 8px;
        border-bottom: 1px solid var(--app-border-dark);
        padding-bottom: 6px;
        font-weight: 500;
    }
     .accordion-content h4:first-child {
        margin-top: 0;
     }

    .accordion-content label {
        display: block;
        font-size: 13px;
        font-weight: 400;
        color: var(--app-text-secondary-dark-theme);
        margin-bottom: 6px;
    }
    .accordion-content input[type="text"],
    .accordion-content input[type="number"],
    .accordion-content textarea,
    .accordion-content select {
        width: 100%;
        padding: 8px 10px;
        font-size: 13px;
        border-radius: 5px;
        border: 1px solid var(--app-border-dark);
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        box-sizing: border-box;
        margin-bottom: 12px;
    }
    .accordion-content input[type="file"] {
      color: var(--app-text-secondary-dark-theme);
      background-color: var(--app-surface-dark);
      border: 1px solid var(--app-border-dark);
      border-radius: 5px;
      padding: 8px;
      font-size: 13px;
      margin-bottom: 12px;
      width: 100%;
    }
     .accordion-content input[type="file"]::file-selector-button {
        margin-right: 10px;
        border: 1px solid var(--app-border-dark);
        background: var(--app-bg-dark);
        padding: 4px 8px;
        border-radius: 3px;
        color: var(--app-text-primary-dark-theme);
        cursor: pointer;
     }
    .accordion-content input[type="color"] {
         width: 100%; padding: 2px; height: 38px; margin-bottom: 12px; border-radius: 5px; border-color: var(--app-border-dark);
    }
    .accordion-content input[type="range"] { width:100%; padding: 0; margin-bottom: 12px;}
    .accordion-content input[type="number"] { -moz-appearance: textfield; }
    .accordion-content input[type="number"]::-webkit-outer-spin-button,
    .accordion-content input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }
    .accordion-content input[type="checkbox"] { width: auto; margin-right: 8px; vertical-align: middle; accent-color: var(--app-accent-primary); }
    .accordion-content label.checkbox-label { display: flex; align-items: center; font-size: 13px; font-weight: 400; margin-bottom: 12px; cursor: pointer; color: var(--app-text-secondary-dark-theme); }

    .accordion-content button {
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        border: 1px solid var(--app-border-dark);
        font-weight: 500;
        width: 100%;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 5px;
        margin-bottom: 10px;
    }
    .accordion-content button:hover { background-color: rgba(255,255,255,0.1); }
     .accordion-content button:active { transform: scale(0.98); }

    .disabled-controls { opacity: 0.6; pointer-events: none; }
    .disabled-controls * { pointer-events: none; }
    
    #dictionary, #uploadedImagesPreview, #assignedImages {
        border: 1px solid var(--app-border-dark);
        padding:10px;
        max-height: 180px;
        overflow-y:auto;
        background-color: var(--app-surface-dark);
        border-radius:5px;
        margin-bottom:10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
    }
     #assignedImages { min-height: 70px; border-style: dashed; border-color: var(--app-accent-primary); justify-content: center;}

    #dictionary p.dictionary-message, #uploadedImagesPreview p.dictionary-message {
        width: 100%; text-align: center; padding: 10px; font-size:12px; color: var(--app-text-secondary-dark-theme); margin: 0; align-self: center;
    }
    .dictionary-item {
        padding:8px; cursor:pointer; border: 1px solid transparent; font-size:13px; transition: background-color .15s ease, border-color .15s ease;
        display:flex; flex-direction: column; align-items:center; border-radius: 4px; background-color: rgba(255,255,255,0.05);
    }
    .dictionary-item:hover { background-color: rgba(255,255,255,0.1); border-color: var(--app-accent-primary); color: var(--app-text-primary-dark-theme); }
    .dictionary-item.selected-for-pattern { border-color: var(--app-accent-primary); background-color: rgba(0, 122, 255, 0.2); }
    .dictionary-item img { width: 50px; height: 50px; object-fit: contain; border:1px solid var(--app-border-dark); border-radius:3px; background-color: var(--app-surface-light); margin-bottom: 5px; }
    .dictionary-item span { font-size: 10px; text-align: center; word-break: break-word; max-width: 50px; color: var(--app-text-secondary-dark-theme); }
    .dictionary-item:hover span, .dictionary-item.selected-for-pattern span { color: var(--app-text-primary-dark-theme); }
    
    .assigned-item { display: flex; flex-direction: column; align-items: center; cursor: pointer; padding: 4px; border-radius: 4px; transition: background-color .15s ease; }
    .assigned-item:hover { background-color: rgba(255, 59, 48, 0.2); }
    .assigned-item img { width: 60px; height: 60px; object-fit: contain; border: 1px solid var(--app-accent-primary); background-color: var(--app-surface-light); border-radius: 3px; }
    .assigned-item .placeholder { width: 60px; height: 60px; border: 2px dashed var(--app-border-dark); display: flex; flex-direction: column; align-items: center; justify-content: center; font-size: 20px; color: var(--app-text-secondary-dark-theme); background-color: transparent; border-radius: 3px; padding: 4px; text-align: center;}
    .assigned-item .placeholder .symbol-text { font-size: 16px; font-weight: bold; }
    .assigned-item .placeholder .symbol-desc { font-size: 9px; }
    .assigned-item span { margin-top: 3px; font-weight: 500; font-size: 12px; }

    #borderDictionary, #backgroundDictionary {
        border: 1px solid var(--app-border-dark); padding: 8px; max-height: 140px; overflow-y: auto; background-color: var(--app-surface-dark);
        border-radius: 5px; margin-top: 8px; display: flex; flex-wrap: wrap; gap: 8px; align-content: flex-start;
    }
    .border-thumbnail-item {
        cursor: pointer; border: 2px solid transparent; border-radius: 4px; padding: 2px; transition: border-color .15s ease; width: 60px; height: 60px;
    }
    .border-thumbnail-item:hover, .border-thumbnail-item.selected { border-color: var(--app-accent-primary); }
    .border-thumbnail-item img { width: 100%; height: 100%; object-fit: contain; background-color: var(--app-surface-light); border-radius: 2px; }

    .panel-footer { padding: 15px 25px; border-top: 1px solid var(--app-border-dark); margin-top: auto; background-color: var(--app-bg-dark); }
    #message { padding:10px 15px; border-radius:5px; font-size:13px; text-align:center; min-height:20px; font-weight:500; display:none; margin-bottom: 0; border-width: 1px; border-style: solid; }
    #message.error { background-color:rgba(255, 59, 48, 0.2); color: var(--app-accent-danger); border-color: var(--app-accent-danger); }
    #message.success { background-color:rgba(52, 199, 89, 0.2); color: #34c759; border-color: #34c759; }
    #message.info { background-color:rgba(0, 122, 255, 0.15); color:var(--app-accent-primary); border-color: var(--app-accent-primary); }

    /* Main Content Area */
    .main { flex-grow: 1; display: flex; flex-direction: column; position: relative; overflow: hidden; padding: 0; background-color: var(--app-bg-light); }
    
    /* Responsive Controls */
    .menu-toggle-btn { display: none; position: absolute; top: 12px; left: 20px; z-index: 20; background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme);
        border: 1px solid var(--app-border-light); border-radius: 6px; width: 38px; height: 38px; font-size: 18px; cursor: pointer; align-items: center; justify-content: center;
    }
    .menu-toggle-btn:hover { background-color: #e8e8ed; }
    .menu-close-btn { display: none; background: none; border: none; color: var(--app-text-secondary-dark-theme); font-size: 28px; line-height: 1; cursor: pointer; padding: 0 5px; }
    .menu-close-btn:hover { color: var(--app-text-primary-dark-theme); }
    .menu-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.4); z-index: 998; }
    .menu-overlay.is-active { display: block; }

    /* Top Right Actions Area */
    .top-right-actions { position: absolute; top: 12px; right: 20px; z-index: 20; display: flex; gap: 10px; align-items: center; }
    .top-right-actions .action-button { padding: 7px 14px; font-size: 13px; font-weight: 500; border-radius: 6px; border: none; color: white; cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; }
    .top-right-actions .action-button:active { transform: scale(0.98); }
    .top-right-actions .action-button.accent { background-color: var(--app-accent-primary); }
    .top-right-actions .action-button.accent:hover { background-color: var(--app-accent-primary-hover); }
    .top-right-actions .action-button.danger { background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light); }
    .top-right-actions .action-button.danger:hover { background-color: #e8e8ed; }
    .top-right-actions .action-button.secondary { background-color: var(--app-surface-light); color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light); }
    .top-right-actions .action-button.secondary:hover { background-color: #e8e8ed; }
    .top-right-actions .action-button:disabled { background-color: #cccccc !important; color: #888888 !important; border-color: #cccccc !important; cursor: not-allowed; transform: none; }

    .dropdown-container { position: relative; display: inline-block; }
    .dropdown-content { display: none; position: absolute; right: 0; top: calc(100% + 5px); background-color: var(--app-surface-light); min-width: 200px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15); border: 1px solid var(--app-border-light); border-radius: 6px; padding: 8px; z-index: 25; }
    .dropdown-content button { width: 100%; padding: 8px 12px; font-size: 13px; border-radius: 4px; box-sizing: border-box; margin-bottom: 6px;
        background-color: transparent; color: var(--app-text-primary-light-theme); border: none; cursor: pointer; text-align: left; font-weight: 400; transition: background-color 0.15s ease; }
    .dropdown-content button:last-of-type { margin-bottom: 0; }
    .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content button:disabled { background-color: transparent !important; color: var(--app-text-secondary-light-theme) !important; opacity: 0.6; cursor: not-allowed; }
    .dropdown-content .checkbox-label { display: flex; align-items: center; font-size: 13px; font-weight: 400; padding: 6px 12px; margin-top: 4px; margin-bottom: 0;
        cursor: pointer; color: var(--app-text-primary-light-theme); border-radius: 4px; }
    .dropdown-content .checkbox-label:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content .checkbox-label input[type="checkbox"] { width: auto; margin-right: 8px; vertical-align: middle; accent-color: var(--app-accent-primary); }

    .tab-row { display: flex; gap: 0; justify-content: flex-start; padding: 0 20px; border-bottom: 1px solid var(--app-border-light); background-color: var(--app-surface-light); margin-top: 60px; }
    .tab-button { padding: 12px 18px; background: transparent; border: none; border-bottom: 2px solid transparent; color: var(--app-text-secondary-light-theme);
        font-size: 14px; font-weight: 500; border-radius: 0; cursor: pointer; transition: color 0.2s ease, border-color 0.2s ease; margin-right: 10px; margin-bottom: -1px; }
    .tab-button:hover { color: var(--app-text-primary-light-theme); }
    .tab-button.active { color: var(--app-accent-primary); border-bottom: 2px solid var(--app-accent-primary); }

    .tab-content-wrapper { flex-grow: 1; display: flex; align-items: flex-start; justify-content: center; padding: 25px; overflow-y: auto; }
    .tab { display: none; width: 100%; height: 100%; margin: 0 auto; }
    .tab.active { display: flex; flex-direction: column; }

    .canvas-container-wrapper { 
        border: none; 
        background-color: var(--app-surface-light); 
        box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
        border-radius: 8px; 
        overflow: visible !important;  /* CRITICAL: Changed from auto to prevent clipping */
        margin: auto; 
    }
    
    /* Ensure Fabric.js container doesn't clip */
    .canvas-container { 
        overflow: visible !important;
        position: relative !important;
    }
    canvas { display: block; }

    /* Contextual Toolbar CSS */
    #object-context-toolbar {
        position: absolute; top: 72px; left: 50%; transform: translateX(-50%); background-color: var(--app-surface-light); border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.15); padding: 5px; display: flex; flex-direction: row; gap: 4px; z-index: 100; align-items: center; border: 1px solid var(--app-border-light);
    }
    .toolbar-group { display: flex; gap: 2px; align-items: center; padding: 0 4px; }
    .toolbar-group + .toolbar-group { border-left: 1px solid var(--app-border-light); }
    .toolbar-item { position: relative; }
    .context-btn {
        background: none; border: 1px solid transparent; border-radius: 4px; padding: 5px 7px; cursor: pointer; font-size: 15px; color: var(--app-text-secondary-light-theme);
        line-height: 1; display: flex; align-items: center; justify-content: center; min-width: 32px; transition: background-color 0.2s, color 0.2s;
    }
    .context-btn:disabled { color: #c5c5c7; cursor: not-allowed; }
    .context-btn:not(:disabled):hover { background-color: #e8e8ed; color: var(--app-text-primary-light-theme); }
    #toolbarDeleteBtn:not(:disabled) { color: var(--app-accent-danger); }
    #object-context-toolbar .dropdown-content {
        display: none; position: absolute; top: calc(100% + 5px); left: 50%; transform: translateX(-50%); background-color: var(--app-surface-light); min-width: 150px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15); border: 1px solid var(--app-border-light); border-radius: 6px; padding: 8px; z-index: 101;
    }
    #object-context-toolbar .dropdown-content button {
        width: 100%; padding: 8px 12px; font-size: 13px; border-radius: 4px; box-sizing: border-box; margin-bottom: 6px; background-color: transparent;
        color: var(--app-text-primary-light-theme); border: none; cursor: pointer; text-align: left; font-weight: 400; transition: background-color 0.15s ease;
    }
    #object-context-toolbar .dropdown-content button:last-of-type { margin-bottom: 0; }
    #object-context-toolbar .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }
    
    /* Responsive Styles */
    @media (max-width: 1024px) {
        :root { --sidebar-width: 300px; }
        .panel { position: fixed; top: 0; left: 0; height: 100vh; z-index: 1000; transform: translateX(-100%); }
        .panel.is-open { transform: translateX(0); }
        .menu-toggle-btn { display: flex; }
        .menu-close-btn { display: block; }
        .tab-row { padding: 0 15px 0 70px; }
    }
  </style>
</head>
<body>
  <div class="layout">
    <div id="menuOverlay" class="menu-overlay"></div>
    <div class="panel">
      <div class="panel-header">
        <h2 data-translate-key="patternSettings">Pattern Settings</h2>
        <button id="menuCloseBtn" class="menu-close-btn">&times;</button>
      </div>
      
      <div class="panel-content">
        
        <!-- Language Settings Accordion -->
        <div class="accordion-item">
            <button class="accordion-button active" data-translate="settings">Language Settings</button>
            <div class="accordion-content active">
                <label for="languageSelect" data-translate="language">Language:</label>
                <select id="languageSelect">
                    <option value="en">English</option>
                    <option value="de">Deutsch</option>
                    <option value="fr">Français</option>
                    <option value="es">Español</option>
                    <option value="pt">Português</option>
                    <option value="it">Italiano</option>
                    <option value="nl">Nederlands</option>
                    <option value="sv">Svenska</option>
                    <option value="da">Dansk</option>
                    <option value="no">Norsk</option>
                    <option value="fi">Suomi</option>
                </select>
            </div>
        </div>
        
        <div class="accordion-item">
            <button class="accordion-button active">Page Setup</button>
            <div class="accordion-content active">
                <label for="pageSizeSelect">Page Size:</label>
                <select id="pageSizeSelect">
                    <option value="612x792">Letter Portrait (8.5×11")</option>
                    <option value="792x612">Letter Landscape (11×8.5")</option>
                    <option value="595x842">A4 Portrait (210×297mm)</option>
                    <option value="842x595">A4 Landscape (297×210mm)</option>
                    <option value="1200x1200">Square (1200x1200)</option>
                    <option value="custom">Custom</option>
                </select>
                <div id="customPageSizeInputs" style="display:none;">
                    <label for="pageWidth">Width (px):</label>
                    <input type="number" id="pageWidth" value="612">
                    <label for="pageHeight">Height (px):</label>
                    <input type="number" id="pageHeight" value="792">
                </div>
                <label for="pageColor">Page Color:</label>
                <input type="color" id="pageColor" value="#FFFFFF">
                <button id="setPageSizeBtn">Apply Size</button>
                
                <h4>Background</h4>
                <label for="backgroundThemeSelect">Background Theme:</label>
                <select id="backgroundThemeSelect"><option value="none">None</option></select>
                <div id="backgroundDictionary"><p class="dictionary-message">Select a theme.</p></div>
                <label for="backgroundOpacitySlider">Background Opacity:</label>
                <input type="range" id="backgroundOpacitySlider" min="0" max="1" step="0.05" value="1" disabled>

                <h4>Border</h4>
                <label for="borderThemeSelect">Border Theme:</label>
                <select id="borderThemeSelect"><option value="none">None</option></select>
                <div id="borderDictionary"><p class="dictionary-message">Select a theme.</p></div>
                <label for="borderOpacitySlider">Border Opacity:</label>
                <input type="range" id="borderOpacitySlider" min="0" max="1" value="1" step="0.05" disabled>
            </div>
        </div>

        <div class="accordion-item">
            <button class="accordion-button">Text Tools</button>
            <div class="accordion-content">
                <h4>Add New Text</h4>
                <label for="textInput">Content:</label><input type="text" id="textInput" placeholder="Hello!">
                <button id="addTextBtn">Add Text</button>
                <h4>Selected Text Properties</h4>
                <label for="textColor">Color:</label><input type="color" id="textColor" value="#333333" disabled>
                <label for="fontSize">Size:</label><input type="number" id="fontSize" value="48" min="8" disabled>
                <label for="fontFamily">Font:</label>
                <select id="fontFamily" disabled>
                    <option value="Lexend Deca">Lexend Deca</option>
                    <option value="Baloo 2">Baloo 2</option>
                    <option value="Nunito">Nunito</option>
                    <option value="Quicksand">Quicksand</option>
                    <option value="Fredoka">Fredoka</option>
                    <option value="Arial">Arial</option>
                    <option value="Verdana">Verdana</option>
                </select>
                <label for="textStrokeColor">Outline Color:</label><input type="color" id="textStrokeColor" value="#000000" disabled>
                <label for="textStrokeWidth">Outline (0-10):</label><input type="range" id="textStrokeWidth" min="0" max="10" value="0" step="0.5" disabled>
            </div>
        </div>
        
        <div class="accordion-item">
            <button class="accordion-button">Pattern Settings</button>
            <div class="accordion-content">
                <h4>Global Settings</h4>
                <label for="exerciseCount">Number of Exercises (1-8):</label>
                <input type="number" id="exerciseCount" value="3" min="1" max="8">
                <label for="worksheetThemeSelect">Overall Worksheet Theme:</label>
                <select id="worksheetThemeSelect">
                    <option value="none">None (Use individual settings)</option>
                </select>
                <label class="checkbox-label">
                    <input type="checkbox" id="useWorksheetThemeCheckbox"> Use Overall Worksheet Theme
                </label>
                <label class="checkbox-label" id="includeNumbersLabel">
                    <input type="checkbox" id="includeNumbersCheckbox" checked> Include Puzzle Numbers
                </label>
                <label class="checkbox-label">
                    <input type="checkbox" id="randomStartCheckbox"> Start from random element
                </label>
                
                <div id="individualPuzzleConfigContainer">
                    <h4>Individual Puzzle Settings</h4>
                    <label for="configurePuzzleSelect">Configure Puzzle:</label>
                    <select id="configurePuzzleSelect">
                      </select>
                    <label for="patternSelect">Pattern Type:</label>
                    <select id="patternSelect">
                      <option value="AB">AB (2 images)</option>
                      <option value="AAB">AAB (2 images)</option>
                      <option value="ABB">ABB (2 images)</option>
                      <option value="ABC">ABC (3 images)</option>
                      <option value="AABB">AABB (2 images)</option>
                      <option value="ABBC">ABBC (3 images)</option>
                      <option value="AABC">AABC (3 images)</option>
                      <option value="ABCC">ABCC (3 images)</option>
                      <option value="ABCD">ABCD (4 images)</option>
                    </select>
                    <label for="questionTypeSelect">Question Type:</label>
                    <select id="questionTypeSelect">
                      <option value="blank">Blank Box</option>
                      <option value="options">Choose from Options</option>
                    </select>
                    <label class="checkbox-label" id="randomBlankLabel">
                        <input type="checkbox" id="randomBlankCheckbox"> Random blank box position
                    </label>
                    <h4>Images for Selected Puzzle</h4>
                    <label for="themeSelect">Image Theme:</label>
                    <select id="themeSelect"></select>
                    <label>Assigned Images:</label>
                    <div id="assignedImages"></div>
                </div>
            </div>
        </div>

        <div class="accordion-item">
            <button class="accordion-button">Image Library</button>
            <div class="accordion-content">
                <label for="searchInput">Search Images:</label>
                <input type="text" id="searchInput" placeholder="e.g., apple, car" />
                <label>Available Images (Click to assign):</label>
                <div id="dictionary"><p class='dictionary-message'>Select a theme to see images.</p></div>
            </div>
        </div>

        <div class="accordion-item">
            <button class="accordion-button">Upload Custom Images</button>
            <div class="accordion-content">
                <label for="imageUploadInput">Select image(s) to upload:</label>
                <input type="file" id="imageUploadInput" multiple accept="image/*">
                <label style="margin-top:10px;">Your Uploaded Images:</label>
                <div id="uploadedImagesPreview">
                    <p class="dictionary-message">Your uploaded images will appear here.</p>
                </div>
            </div>
        </div>

      </div>
      <div class="panel-footer">
          <div id="message"></div>
      </div>
    </div>

    <div class="main">
      <button id="menuToggleBtn" class="menu-toggle-btn"><i class="fas fa-bars"></i></button>
      
      <div id="object-context-toolbar" style="display:none;">
          <div class="toolbar-group">
              <div class="toolbar-item">
                  <button class="context-btn" id="layersBtn" title="Layers"><i class="fas fa-layer-group"></i></button>
                  <div class="dropdown-content" id="layersDropdown">
                      <button id="toolbarBringForwardBtn">Bring Forward</button>
                      <button id="toolbarSendBackwardBtn">Send Backward</button>
                  </div>
              </div>
          </div>
          <div class="toolbar-group">
              <div class="toolbar-item">
                  <button class="context-btn" id="alignBtn" title="Align"><i class="fas fa-th"></i></button>
                  <div class="dropdown-content" id="alignDropdown" style="min-width: 220px; padding: 12px;">
                      <p style="font-size:11px; margin-bottom:5px; color:#555;">Align Selected:</p>
                      <div>
                          <button class="context-btn" id="alignLeftBtn" title="Align Left"><i class="fas fa-align-left"></i></button>
                          <button class="context-btn" id="alignHCenterBtn" title="Center Horizontally"><i class="fas fa-align-center"></i></button>
                          <button class="context-btn" id="alignRightBtn" title="Align Right"><i class="fas fa-align-right"></i></button>
                      </div>
                      <div style="margin-top: 5px;">
                          <button class="context-btn" id="alignTopBtn" title="Align Top"><i class="fas fa-long-arrow-alt-up"></i></button>
                          <button class="context-btn" id="alignVCenterBtn" title="Center Vertically"><i class="fas fa-grip-lines"></i></button>
                          <button class="context-btn" id="alignBottomBtn" title="Align Bottom"><i class="fas fa-long-arrow-alt-down"></i></button>
                      </div>
                      <hr style="margin:8px 0; border:none; border-top:1px solid #eee;">
                      <p style="font-size:11px; margin-bottom:5px; color:#555;">Align to Page:</p>
                      <div>
                          <button class="context-btn" id="centerHCanvasBtn" title="Center on Page Horizontally"><i class="fas fa-arrows-alt-h"></i></button>
                          <button class="context-btn" id="centerVCanvasBtn" title="Center on Page Vertically"><i class="fas fa-arrows-alt-v"></i></button>
                      </div>
                  </div>
              </div>
          </div>
          <div class="toolbar-group">
              <button class="context-btn" id="toolbarDeleteBtn" title="Delete Selected"><i class="fas fa-trash-alt"></i></button>
          </div>
      </div>

      <div class="top-right-actions">
          <div class="dropdown-container">
            <button id="generateDropdownBtn" class="action-button accent">Generate <i class="fas fa-caret-down"></i></button>
            <div id="generateDropdownContent" class="dropdown-content">
                <button id="generateWorksheetBtn">Generate Worksheet</button>
                <button id="generateAnswerKeyBtn" disabled>Generate Answer Key</button>
            </div>
          </div>
        <div class="dropdown-container">
            <button id="downloadDropdownBtn" class="action-button secondary" disabled>Download <i class="fas fa-caret-down"></i></button>
            <div id="downloadDropdownContent" class="dropdown-content">
                <button id="downloadWsJpegBtn">Worksheet (JPEG)</button>
                <button id="downloadAkJpegBtn" disabled>Answer Key (JPEG)</button>
                <button id="downloadWsPdfBtn">Worksheet (PDF)</button>
                <button id="downloadAkPdfBtn" disabled>Answer Key (PDF)</button>
                <label class="checkbox-label">
                    <input type="checkbox" id="grayscaleToggle" />Grayscale
                </label>
            </div>
        </div>
        <button id="clearBtn" class="action-button danger">Clear All</button>
      </div>

      <div class="tab-row">
        <button class="tab-button active" data-tab="worksheetTab">Worksheet</button>
        <button class="tab-button" data-tab="answerKeyTab">Answer Key</button>
      </div>
      <div class="tab-content-wrapper">
        <div class="tab active" id="worksheetTab">
            <div class="canvas-container-wrapper" id="worksheetCanvasWrapper">
                <canvas id="worksheetCanvasElement"></canvas>
            </div>
        </div>
        <div class="tab" id="answerKeyTab">
             <div class="canvas-container-wrapper" id="answerKeyCanvasWrapper">
                <canvas id="answerKeyCanvasElement"></canvas>
            </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // MUST BE GLOBAL - Before DOMContentLoaded for proper enhancement script initialization
    let currentLocale = 'en';
    let currentCanvasConfig = { width: 612, height: 792 };

    // Initialize locale from URL if present
    const urlParams = new URLSearchParams(window.location.search);
    const localeParam = urlParams.get('locale');
    if (localeParam) {
        currentLocale = localeParam;
    }
    // Set globally for all enhancement scripts
    window.currentLocale = currentLocale;
    
    document.addEventListener("DOMContentLoaded", function() {
        // --- CACHED DOM ELEMENTS ---
        const ui = {
            panel: document.querySelector('.panel'),
            menuToggleBtn: document.getElementById('menuToggleBtn'),
            menuCloseBtn: document.getElementById('menuCloseBtn'),
            menuOverlay: document.getElementById('menuOverlay'),
            accordionButtons: document.querySelectorAll('.accordion-button'),
            message: document.getElementById('message'),
            clearBtn: document.getElementById('clearBtn'),
            
            // Page Setup
            pageSizeSelect: document.getElementById('pageSizeSelect'),
            customPageSizeInputs: document.getElementById('customPageSizeInputs'),
            pageWidth: document.getElementById('pageWidth'),
            pageHeight: document.getElementById('pageHeight'),
            setPageSizeBtn: document.getElementById('setPageSizeBtn'),
            pageColor: document.getElementById('pageColor'),
            backgroundThemeSelect: document.getElementById('backgroundThemeSelect'),
            backgroundDictionary: document.getElementById('backgroundDictionary'),
            backgroundOpacitySlider: document.getElementById('backgroundOpacitySlider'),
            borderThemeSelect: document.getElementById('borderThemeSelect'),
            borderDictionary: document.getElementById('borderDictionary'),
            borderOpacitySlider: document.getElementById('borderOpacitySlider'),

            // Text Tools
            textInput: document.getElementById('textInput'),
            addTextBtn: document.getElementById('addTextBtn'),
            textColor: document.getElementById('textColor'),
            fontSize: document.getElementById('fontSize'),
            fontFamily: document.getElementById('fontFamily'),
            textStrokeColor: document.getElementById('textStrokeColor'),
            textStrokeWidth: document.getElementById('textStrokeWidth'),

            // Pattern Settings
            exerciseCount: document.getElementById('exerciseCount'),
            worksheetThemeSelect: document.getElementById('worksheetThemeSelect'),
            useWorksheetThemeCheckbox: document.getElementById('useWorksheetThemeCheckbox'),
            includeNumbersCheckbox: document.getElementById('includeNumbersCheckbox'),
            randomStartCheckbox: document.getElementById('randomStartCheckbox'),
            individualPuzzleConfigContainer: document.getElementById('individualPuzzleConfigContainer'),
            configurePuzzleSelect: document.getElementById('configurePuzzleSelect'),
            patternSelect: document.getElementById('patternSelect'),
            questionTypeSelect: document.getElementById('questionTypeSelect'),
            randomBlankLabel: document.getElementById('randomBlankLabel'),
            randomBlankCheckbox: document.getElementById('randomBlankCheckbox'),
            themeSelect: document.getElementById('themeSelect'),
            assignedImages: document.getElementById('assignedImages'),
            
            // Image Library
            searchInput: document.getElementById('searchInput'),
            dictionary: document.getElementById('dictionary'),
            imageUploadInput: document.getElementById('imageUploadInput'),
            uploadedImagesPreview: document.getElementById('uploadedImagesPreview'),

            // Main Content Area
            worksheetCanvasWrapper: document.getElementById('worksheetCanvasWrapper'),
            worksheetCanvasElement: document.getElementById('worksheetCanvasElement'),
            answerKeyCanvasWrapper: document.getElementById('answerKeyCanvasWrapper'),
            answerKeyCanvasElement: document.getElementById('answerKeyCanvasElement'),
            
            // Top Right Actions
            generateDropdownBtn: document.getElementById('generateDropdownBtn'),
            generateDropdownContent: document.getElementById('generateDropdownContent'),
            generateWorksheetBtn: document.getElementById('generateWorksheetBtn'),
            generateAnswerKeyBtn: document.getElementById('generateAnswerKeyBtn'),
            downloadDropdownBtn: document.getElementById('downloadDropdownBtn'),
            downloadDropdownContent: document.getElementById('downloadDropdownContent'),
            downloadWsJpegBtn: document.getElementById('downloadWsJpegBtn'),
            downloadAkJpegBtn: document.getElementById('downloadAkJpegBtn'),
            downloadWsPdfBtn: document.getElementById('downloadWsPdfBtn'),
            downloadAkPdfBtn: document.getElementById('downloadAkPdfBtn'),
            grayscaleToggle: document.getElementById('grayscaleToggle'),

            // Contextual Toolbar
            objectContextToolbar: document.getElementById('object-context-toolbar'),
            layersBtn: document.getElementById('layersBtn'),
            layersDropdown: document.getElementById('layersDropdown'),
            toolbarBringForwardBtn: document.getElementById('toolbarBringForwardBtn'),
            toolbarSendBackwardBtn: document.getElementById('toolbarSendBackwardBtn'),
            alignBtn: document.getElementById('alignBtn'),
            alignDropdown: document.getElementById('alignDropdown'),
            toolbarDeleteBtn: document.getElementById('toolbarDeleteBtn'),
        };
        ui.allToolbarButtons = ui.objectContextToolbar.querySelectorAll('.context-btn');

        // --- STATE MANAGEMENT ---
        let worksheetCanvas, answerKeyCanvas;
        // currentCanvasConfig already declared globally above
        const downloadMultiplier = 6;
        
        let puzzleConfigs = [];
        let currentPuzzleSetupIndex = 0;
        let useGlobalWorksheetTheme = false;
        
        let allImagesData = { themes: {}, uploads: [] };
        let lastGeneratedPuzzles = [];
        
        let activePopover = null;

        // --- INITIALIZATION ---
        function initializeApp() {
            initializeCanvases();
            setupEventListeners();
            
            // Apply translations on load
            if (typeof applyTranslations !== 'undefined') {
                applyTranslations();
            }
            
            updateExerciseCount();
            loadAllAssetThemes();
            updateUIForCurrentPuzzle();
            toggleIndividualPuzzleControls(true);
            handleSelectionCleared(null, null);
            toggleRandomBlankOption();
        }

        function initializeCanvases() {
            // Set initial canvas dimensions
            const initialWidth = currentCanvasConfig.width;
            const initialHeight = currentCanvasConfig.height;
            
            worksheetCanvas = new fabric.Canvas(ui.worksheetCanvasElement, {
                width: initialWidth,
                height: initialHeight,
                preserveObjectStacking: true,
                enableRetinaScaling: true,
                selection: true,
                selectionColor: 'rgba(100, 100, 255, 0.3)',
                selectionBorderColor: 'rgba(100, 100, 255, 0.8)',
                selectionLineWidth: 2
            });
            answerKeyCanvas = new fabric.Canvas(ui.answerKeyCanvasElement, {
                width: initialWidth,
                height: initialHeight,
                preserveObjectStacking: true,
                enableRetinaScaling: true,
                selection: true,
                selectionColor: 'rgba(100, 100, 255, 0.3)',
                selectionBorderColor: 'rgba(100, 100, 255, 0.8)',
                selectionLineWidth: 2
            });
            
            // Apply display scaling
            updateCanvasDisplayDimensions(initialWidth, initialHeight);
            
            setupCanvasEventListeners(worksheetCanvas);
            setupCanvasEventListeners(answerKeyCanvas);
        }
        
        // Update object coordinates on window resize
        window.addEventListener('resize', () => {
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        });

        function updateExerciseCount() {
            const count = parseInt(ui.exerciseCount.value, 10);
            const currentLength = puzzleConfigs.length;

            if (count > currentLength) {
                for (let i = currentLength; i < count; i++) {
                     puzzleConfigs.push({
                        patternType: 'AB',
                        questionType: 'blank',
                        images: [],
                        patternElements: ['A', 'B'],
                        imageLibraryTheme: 'all'
                    });
                    updateRequiredImagesForPuzzleConfig(puzzleConfigs[i]);
                }
            } else if (count < currentLength) {
                puzzleConfigs.length = count;
            }
            
            ui.configurePuzzleSelect.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const option = document.createElement('option');
                option.value = i;
                option.textContent = `Puzzle ${i + 1} Settings`;
                ui.configurePuzzleSelect.appendChild(option);
            }
            
            if (currentPuzzleSetupIndex >= count) {
                currentPuzzleSetupIndex = Math.max(0, count - 1);
                ui.configurePuzzleSelect.value = currentPuzzleSetupIndex;
            }
            updateUIForCurrentPuzzle();
        }

        function updateRequiredImagesForPuzzleConfig(config) {
            config.patternElements = Array.from(new Set(config.patternType.split('')));
            const uniqueSymbolsCount = config.patternElements.length;
            const newSelectedImages = new Array(uniqueSymbolsCount).fill(null);
            
            const currentValidImages = config.images.filter(img => img && img.path);
            const pathsAdded = new Set();
            let newSelectionIndex = 0;
            
            for (let i = 0; i < currentValidImages.length && newSelectionIndex < uniqueSymbolsCount; i++) {
                if (!pathsAdded.has(currentValidImages[i].path)) {
                    newSelectedImages[newSelectionIndex] = currentValidImages[i];
                    pathsAdded.add(currentValidImages[i].path);
                    newSelectionIndex++;
                }
            }
            config.images = newSelectedImages;
        }
        
        function loadAllAssetThemes() {
            fetch(`/api/themes-translated?locale=${currentLocale}`)
              .then(res => res.ok ? res.json() : Promise.reject('Failed to load themes'))
              .then(themePaths => {
                  const themeFragment = document.createDocumentFragment();
                  const worksheetThemeFragment = document.createDocumentFragment();
                  
                  const allOpt = document.createElement('option');
                  allOpt.value = 'all';
                  allOpt.textContent = 'All Images (Search required)';
                  themeFragment.appendChild(allOpt);

                  const noneOpt = document.createElement('option');
                  noneOpt.value = 'none';
                  noneOpt.textContent = 'None (Use individual settings)';
                  worksheetThemeFragment.appendChild(noneOpt);

                  themePaths.forEach(theme => {
                    const opt = document.createElement("option");
                    opt.value = theme.value || theme;
                    opt.textContent = theme.displayName || theme;
                    themeFragment.appendChild(opt.cloneNode(true));
                    worksheetThemeFragment.appendChild(opt);
                  });
                  ui.themeSelect.innerHTML = '';
                  ui.themeSelect.appendChild(themeFragment);
                  ui.worksheetThemeSelect.innerHTML = '';
                  ui.worksheetThemeSelect.appendChild(worksheetThemeFragment);
                  
                  // Load initial dictionary images after themes are loaded
                  if (puzzleConfigs.length > 0) {
                      loadDictionaryImages(false);
                  }
              })
              .catch(err => { console.error("Error loading themes:", err); showMessage(err.message, 'error'); });

            // Border and background themes will be populated by BulletproofLoader
        }
        
        function getActiveCanvas() {
            const activeTab = document.querySelector('.tab.active');
            // If the answer key tab is active, return that canvas, otherwise default to the worksheet canvas.
            return activeTab && activeTab.id === 'answerKeyTab' ? answerKeyCanvas : worksheetCanvas;
        }

        function setupEventListeners() {
            // Language selector
            const languageSelect = document.getElementById('languageSelect');
            if (languageSelect) {
                languageSelect.value = currentLocale;
                languageSelect.addEventListener('change', function() {
                    const newLocale = this.value;
                    const url = new URL(window.location);
                    url.searchParams.set('locale', newLocale);
                    window.location.href = url.toString();
                    // Reload current theme images if any
                    if (puzzleConfigs.length > 0) {
                        loadDictionaryImages(false);
                    }
                });
            }
            
            ui.menuToggleBtn.addEventListener('click', () => { ui.panel.classList.add('is-open'); ui.menuOverlay.classList.add('is-active'); });
            ui.menuCloseBtn.addEventListener('click', () => { ui.panel.classList.remove('is-open'); ui.menuOverlay.classList.remove('is-active'); });
            ui.menuOverlay.addEventListener('click', () => { ui.panel.classList.remove('is-open'); ui.menuOverlay.classList.remove('is-active'); });

            ui.accordionButtons.forEach(button => {
              button.addEventListener('click', () => {
                  button.classList.toggle('active');
                  button.nextElementSibling.classList.toggle('active');
              });
            });

            ui.pageSizeSelect.addEventListener('change', handlePageSizeChange);
            ui.setPageSizeBtn.addEventListener('click', applyCustomPageSize);
            ui.pageColor.addEventListener('input', applyPageColor);
            ui.borderThemeSelect.addEventListener("change", loadBorderImages);
            ui.borderOpacitySlider.addEventListener('input', applyBorderOpacity);
            ui.backgroundThemeSelect.addEventListener("change", loadBackgroundImages);
            ui.backgroundOpacitySlider.addEventListener('input', applyBackgroundOpacity);

            ui.addTextBtn.addEventListener('click', addText);
            ui.textInput.addEventListener('input', updateActiveTextObjectProperties);
            ui.textColor.addEventListener('input', updateActiveTextObjectProperties);
            ui.fontSize.addEventListener('input', updateActiveTextObjectProperties);
            ui.fontFamily.addEventListener('change', updateActiveTextObjectProperties);
            ui.textStrokeColor.addEventListener('input', updateActiveTextObjectProperties);
            ui.textStrokeWidth.addEventListener('input', updateActiveTextObjectProperties);
            
            ui.exerciseCount.addEventListener('change', updateExerciseCount);

            ui.useWorksheetThemeCheckbox.addEventListener('change', (e) => {
                useGlobalWorksheetTheme = e.target.checked;
                toggleIndividualPuzzleControls(!useGlobalWorksheetTheme);
            });
            ui.configurePuzzleSelect.addEventListener('change', (e) => {
                currentPuzzleSetupIndex = parseInt(e.target.value, 10);
                updateUIForCurrentPuzzle();
            });
            ui.patternSelect.addEventListener('change', updateRequiredImagesForCurrentPuzzle);
            ui.questionTypeSelect.addEventListener('change', () => {
                if (puzzleConfigs[currentPuzzleSetupIndex]) {
                    puzzleConfigs[currentPuzzleSetupIndex].questionType = ui.questionTypeSelect.value;
                }
                toggleRandomBlankOption();
            });
            ui.themeSelect.addEventListener('change', () => {
                if (puzzleConfigs[currentPuzzleSetupIndex]) {
                    puzzleConfigs[currentPuzzleSetupIndex].imageLibraryTheme = ui.themeSelect.value;
                    loadDictionaryImages(true);
                }
            });
            
            let searchTimeout;
            ui.searchInput.addEventListener("input", () => {
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(() => loadDictionaryImages(false), 300);
            });
            ui.imageUploadInput.addEventListener('change', handleImageUpload);

            setupDropdown(ui.generateDropdownBtn, ui.generateDropdownContent);
            setupDropdown(ui.downloadDropdownBtn, ui.downloadDropdownContent);
            ui.generateWorksheetBtn.addEventListener('click', handleGenerateWorksheet);
            ui.generateAnswerKeyBtn.addEventListener('click', handleGenerateAnswerKey);
            
            // New Download Listeners
            ui.downloadWsJpegBtn.addEventListener("click", () => downloadImageFile(worksheetCanvas, 'jpeg', 'pattern_worksheet'));
            ui.downloadAkJpegBtn.addEventListener("click", () => downloadImageFile(answerKeyCanvas, 'jpeg', 'pattern_answer_key'));
            ui.downloadWsPdfBtn.addEventListener("click", () => downloadPDF(worksheetCanvas, 'pattern_worksheet.pdf'));
            ui.downloadAkPdfBtn.addEventListener("click", () => downloadPDF(answerKeyCanvas, 'pattern_answer_key.pdf'));


            // Prevent dropdown from closing on label click
            ui.downloadDropdownContent.addEventListener('click', (e) => {
                if (e.target.closest('.checkbox-label')) {
                    e.stopPropagation();
                }
            });
            
            document.querySelectorAll(".tab-button").forEach(btn => {
                btn.addEventListener("click", () => {
                  document.querySelectorAll(".tab-button.active").forEach(b => b.classList.remove("active"));
                  btn.classList.add("active");
                  document.querySelectorAll(".tab.active").forEach(t => t.classList.remove("active"));
                  document.getElementById(btn.dataset.tab).classList.add("active");
                  
                  const activeCanvas = getActiveCanvas();
                  if (activeCanvas) {
                      activeCanvas.discardActiveObject().renderAll();
                      handleSelectionCleared(null, activeCanvas); // Reset UI controls
                  }
                });
            });
            
            ui.clearBtn.addEventListener("click", clearAll);
            setupToolbarListeners();
            setupGlobalKeydownListener();
        }
        
        function setupCanvasEventListeners(canvas) {
            canvas.on({
                'selection:created': function(e) { handleObjectSelection(e, this); },
                'selection:updated': function(e) { handleObjectSelection(e, this); },
                'selection:cleared': function(e) { handleSelectionCleared(e, this); }
            });
        }
        
        function toggleRandomBlankOption() {
            const isBlankQuestion = ui.questionTypeSelect.value === 'blank';
            ui.randomBlankLabel.style.display = isBlankQuestion ? 'flex' : 'none';
            if (!isBlankQuestion) {
                ui.randomBlankCheckbox.checked = false;
            }
        }
        
        function setupDropdown(button, content) {
            if (!button || !content) return;
            button.addEventListener('click', (event) => {
                event.stopPropagation();
                const isVisible = content.style.display === 'block';
                closeAllPopovers();
                if (!isVisible) {
                    content.style.display = 'block';
                    activePopover = content;
                }
            });
        }

        function showMessage(msg, type = 'info', duration = 3000) {
            ui.message.textContent = msg;
            ui.message.className = `message ${type}`;
            ui.message.style.display = 'block';
            if (duration > 0) {
                setTimeout(() => { if (ui.message.textContent === msg) ui.message.style.display = 'none'; }, duration);
            }
        }
        
        function updateUIForCurrentPuzzle() {
            if (!puzzleConfigs[currentPuzzleSetupIndex]) return;
            const config = puzzleConfigs[currentPuzzleSetupIndex];
            ui.patternSelect.value = config.patternType;
            ui.questionTypeSelect.value = config.questionType;
            ui.themeSelect.value = config.imageLibraryTheme;
            toggleRandomBlankOption();
            loadDictionaryImages(false);
            updateAssignedImagesPanel();
        }
        
        function updateRequiredImagesForCurrentPuzzle() {
            const config = puzzleConfigs[currentPuzzleSetupIndex];
            if (!config) return;
            config.patternType = ui.patternSelect.value;
            updateRequiredImagesForPuzzleConfig(config);
            loadDictionaryImages(false);
            updateAssignedImagesPanel();
        }
        
        function updateAssignedImagesPanel() {
            ui.assignedImages.innerHTML = '';
            const config = puzzleConfigs[currentPuzzleSetupIndex];
            if (!config) return;

            config.patternElements.forEach((elementSymbol, index) => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'assigned-item';
                itemDiv.dataset.index = index;
                itemDiv.onclick = () => deselectAssignedImage(index);

                const image = config.images[index];
                if (image && image.path) {
                    const img = document.createElement('img');
                    img.src = image.path;
                    img.alt = image.word;
                    itemDiv.appendChild(img);
                } else {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'placeholder';
                    placeholder.innerHTML = `<div class="symbol-text">${elementSymbol}</div><div class="symbol-desc">Click an image below</div>`;
                    itemDiv.appendChild(placeholder);
                }
                const span = document.createElement('span');
                span.textContent = `Element ${elementSymbol}`;
                itemDiv.appendChild(span);
                ui.assignedImages.appendChild(itemDiv);
            });
        }

        function deselectAssignedImage(index) {
            const config = puzzleConfigs[currentPuzzleSetupIndex];
            config.images[index] = null;
            updateAssignedImagesPanel();
            loadDictionaryImages(false);
        }

        function toggleIndividualPuzzleControls(enable) {
            ui.individualPuzzleConfigContainer.classList.toggle('disabled-controls', !enable);
        }

        function clearAll() {
            ui.exerciseCount.value = 3;
            updateExerciseCount();
            currentPuzzleSetupIndex = 0;
            ui.configurePuzzleSelect.value = "0";
            ui.worksheetThemeSelect.value = "none";
            useGlobalWorksheetTheme = false;
            ui.useWorksheetThemeCheckbox.checked = false;
            ui.randomStartCheckbox.checked = false;
            ui.randomBlankCheckbox.checked = false;
            toggleIndividualPuzzleControls(true);
            ui.searchInput.value = "";
            lastGeneratedPuzzles = [];
            allImagesData.uploads = [];

            [worksheetCanvas, answerKeyCanvas].forEach(c => {
                if (c) {
                    c.clear();
                    c.backgroundColor = '#FFFFFF';
                    c.renderAll();
                }
            });
            ui.pageColor.value = '#FFFFFF';
            ui.pageSizeSelect.value = "612x792";
            updateCanvasDisplayDimensions(612, 792);

            ui.borderThemeSelect.value = "none";
            ui.borderDictionary.innerHTML = '<p class="dictionary-message">Select a theme.</p>';
            ui.borderOpacitySlider.value = 1;
            ui.borderOpacitySlider.disabled = true;
            ui.backgroundThemeSelect.value = "none";
            ui.backgroundDictionary.innerHTML = '<p class="dictionary-message">Select a theme.</p>';
            ui.backgroundOpacitySlider.value = 1;
            ui.backgroundOpacitySlider.disabled = true;

            updateUIForCurrentPuzzle();
            renderUploadedImages();
            handleSelectionCleared(null, null);
            
            ui.generateAnswerKeyBtn.disabled = true;
            ui.downloadDropdownBtn.disabled = true;
            ui.downloadAkJpegBtn.disabled = true;
            ui.downloadAkPdfBtn.disabled = true;

            
            showMessage("All settings cleared.", "success", 2000);
        }

        async function loadDictionaryImages(resetSearch = true) {
            if (resetSearch) ui.searchInput.value = "";
            
            const currentConfig = puzzleConfigs[currentPuzzleSetupIndex];
            if (!currentConfig) return;

            const selectedTheme = currentConfig.imageLibraryTheme;
            const query = ui.searchInput.value.trim().toLowerCase();
            
            let imagesToRender = [];
            ui.dictionary.innerHTML = `<p class="dictionary-message">Loading images...</p>`;

            try {
                if (selectedTheme === 'all') {
                    if (!query) {
                        // Load animals theme by default when "All Themes" is selected with no search
                        const res = await fetch(`/api/images?theme=animals&locale=${currentLocale}`);
                        if (!res.ok) throw new Error(`Failed to load default theme`);
                        const data = await res.json();
                    imagesToRender = data.images || data; // Handle both old and new API formats
                    } else {
                        const res = await fetch(`/api/images?search=${encodeURIComponent(query)}&locale=${currentLocale}`);
                        if (!res.ok) throw new Error(`Failed to search for "${query}"`);
                        const data = await res.json();
                    imagesToRender = data.images || data; // Handle both old and new API formats
                    }
                } else {
                    const res = await fetch(`/api/images?theme=${encodeURIComponent(selectedTheme)}&locale=${currentLocale}`);
                    if (!res.ok) throw new Error(`Failed to load images for theme`);
                    const data = await res.json();
                const themeImages = data.images || data; // Handle both old and new API formats
                    allImagesData.themes[selectedTheme] = themeImages;
                    imagesToRender = query ? themeImages.filter(img => img.word.toLowerCase().includes(query)) : themeImages;
                }
                renderDictionaryFromData(imagesToRender, query);
            } catch (err) {
                console.error("Error loading dictionary:", err);
                ui.dictionary.innerHTML = `<p class='dictionary-message'>Error loading images.</p>`;
                showMessage(err.message, 'error');
            }
        }
        
        function renderDictionaryFromData(images, query) {
            ui.dictionary.innerHTML = "";
            if (images.length === 0) {
                ui.dictionary.innerHTML = `<p class="dictionary-message">No images found${query ? ` matching "${query}"` : ''}.</p>`;
                return;
            }

            const currentConfig = puzzleConfigs[currentPuzzleSetupIndex];
            const assignedPaths = new Set(currentConfig.images.map(img => img ? img.path : null));

            images.sort((a, b) => a.word.localeCompare(b.word)).forEach(img => {
                const item = document.createElement("div");
                item.className = "dictionary-item";
                if (assignedPaths.has(img.path)) item.classList.add('selected-for-pattern');
                
                const displayName = img.name || img.word;
                item.innerHTML = `<img src="${img.path}" alt="${displayName}" loading="lazy"/><span>${displayName}</span>`;
                item.onclick = () => assignImageToPattern(img);
                ui.dictionary.appendChild(item);
            });
        }
        
        function assignImageToPattern(imageToAssign) {
            const config = puzzleConfigs[currentPuzzleSetupIndex];
            const isAlreadySelected = config.images.some(img => img && img.path === imageToAssign.path);
            if (isAlreadySelected) {
                showMessage('This image is already assigned to this puzzle.', 'info', 2000);
                return;
            }

            const availableSlotIndex = config.images.findIndex(img => img === null);
            if (availableSlotIndex > -1) {
                config.images[availableSlotIndex] = imageToAssign;
                updateAssignedImagesPanel();
                loadDictionaryImages(false);
            } else {
                showMessage('All image slots for this pattern are full. Click an assigned image to remove it first.', 'error');
            }
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if(!files || files.length === 0) return;
            
            Array.from(files).forEach(file => {
                if(!file.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const newImage = { word: file.name.split('.')[0], path: event.target.result };
                    if (!allImagesData.uploads.some(img => img.path === newImage.path)) {
                        allImagesData.uploads.push(newImage);
                    }
                    renderUploadedImages();
                };
                reader.readAsDataURL(file);
            });
            ui.imageUploadInput.value = '';
        }

        function renderUploadedImages() {
            ui.uploadedImagesPreview.innerHTML = "";
            if (allImagesData.uploads.length === 0) {
                ui.uploadedImagesPreview.innerHTML = `<p class="dictionary-message">Your uploaded images will appear here.</p>`;
                return;
            }
            allImagesData.uploads.forEach(img => {
                const item = document.createElement("div");
                item.className = "dictionary-item";
                const displayName = img.name || img.word;
                item.innerHTML = `<img src="${img.path}" alt="${displayName}" loading="lazy"/><span>${displayName}</span>`;
                item.onclick = () => assignImageToPattern(img);
                ui.uploadedImagesPreview.appendChild(item);
            });
        }
        
        async function handleGenerateWorksheet() {
            showMessage('Building puzzle data...', 'info', 0);
            ui.generateDropdownContent.style.display = 'none';

            try {
                lastGeneratedPuzzles = await buildPuzzlesData();
                if (!lastGeneratedPuzzles || lastGeneratedPuzzles.length === 0) {
                    showMessage("Failed to build puzzle data. Check configurations.", "error");
                    return;
                }
                showMessage('Rendering worksheet...', 'info', 0);
                await renderWorksheetFromData(lastGeneratedPuzzles);

                ui.generateAnswerKeyBtn.disabled = false;
                ui.downloadDropdownBtn.disabled = false;
                showMessage("Worksheet generated successfully!", "success");
            } catch (err) {
                console.error("Error generating worksheet:", err);
                showMessage(err.message, "error");
            }
        }

        async function handleGenerateAnswerKey() {
            ui.generateDropdownContent.style.display = 'none';
            if (lastGeneratedPuzzles.length === 0) {
                showMessage("Please generate a worksheet first.", "error");
                return;
            }
            showMessage('Rendering answer key...', 'info', 0);

            try {
                await renderAnswerKeyFromData(lastGeneratedPuzzles);
                document.querySelector('.tab-button[data-tab="answerKeyTab"]').click();
                
                ui.downloadAkJpegBtn.disabled = false;
                ui.downloadAkPdfBtn.disabled = false;
                showMessage("Answer key generated!", "success");
            } catch (err) {
                console.error("Error generating answer key:", err);
                showMessage(err.message, "error");
            }
        }
        
        async function buildPuzzlesData() {
            const puzzlesToGenerateConfig = [];
            const exerciseCount = parseInt(ui.exerciseCount.value, 10);
            
            const globalOptions = {
                includeNumbers: ui.includeNumbersCheckbox.checked,
                randomStart: ui.randomStartCheckbox.checked
            };

            if (useGlobalWorksheetTheme) {
                const theme = ui.worksheetThemeSelect.value;
                if (theme === 'none') {
                    throw new Error("Please select an overall theme or uncheck 'Use Overall Worksheet Theme'.");
                }
                for (let i = 0; i < exerciseCount; i++) {
                    const randomPattern = getRandomElement(Object.keys(PATTERNS));
                    const numImagesNeeded = PATTERNS[randomPattern];
                    const randomImages = await getRandomImages(theme, numImagesNeeded);
                    const questionType = getRandomElement(['blank', 'options']);
                    puzzlesToGenerateConfig.push({ 
                        ...globalOptions,
                        randomBlank: ui.randomBlankCheckbox.checked && questionType === 'blank',
                        patternType: randomPattern, 
                        images: randomImages, 
                        questionType: questionType, 
                        puzzleNumber: globalOptions.includeNumbers ? i + 1 : null, 
                        imageLibraryTheme: theme 
                    });
                }
            } else {
                for (let i = 0; i < exerciseCount; i++) {
                    const config = puzzleConfigs[i];
                    const isComplete = config && config.images.filter(img => img).length === config.patternElements.length;
                    
                    if (isComplete) {
                        puzzlesToGenerateConfig.push({ 
                            ...config, 
                            ...globalOptions,
                            randomBlank: ui.randomBlankCheckbox.checked && config.questionType === 'blank',
                            images: config.images.filter(img => img), 
                            puzzleNumber: globalOptions.includeNumbers ? i + 1 : null 
                        });
                    } else {
                        showMessage(`Puzzle ${i + 1} is incomplete and will be generated randomly.`, 'info', 4000);
                        
                        const allThemes = Array.from(ui.worksheetThemeSelect.options).map(opt => opt.value).filter(v => v !== 'none');
                        const randomTheme = getRandomElement(allThemes) || 'all';
                        
                        const randomPattern = getRandomElement(Object.keys(PATTERNS));
                        const numImagesNeeded = PATTERNS[randomPattern];
                        const randomImages = await getRandomImages(randomTheme, numImagesNeeded);
                        const questionType = getRandomElement(['blank', 'options']);
                        
                        puzzlesToGenerateConfig.push({ 
                            ...globalOptions,
                            randomBlank: ui.randomBlankCheckbox.checked && questionType === 'blank',
                            patternType: randomPattern, 
                            images: randomImages,
                            questionType: questionType, 
                            puzzleNumber: globalOptions.includeNumbers ? i + 1 : null, 
                            imageLibraryTheme: randomTheme 
                        });
                    }
                }
            }
            
            const finalPuzzles = [];
            for (const config of puzzlesToGenerateConfig) {
                const puzzleDetails = await generateSinglePatternLogic(config);
                finalPuzzles.push({ ...config, ...puzzleDetails });
            }
            return finalPuzzles;
        }
        
        const PATTERNS = { 'AB': 2, 'AAB': 2, 'ABB': 2, 'ABC': 3, 'AABB': 2, 'ABBC': 3, 'AABC': 3, 'ABCC': 3, 'ABCD': 4 };

        async function generateSinglePatternLogic(config) {
            const { patternType, images, questionType, imageLibraryTheme, randomStart, randomBlank } = config;
            if (!images || images.length < PATTERNS[patternType]) {
                console.error("Not enough images for pattern:", patternType);
                return { displayRow: [], answerImage: null, options: [], fullAnsweredSequence: [] };
            }
            
            const imageMap = {};
            const uniqueSymbols = Array.from(new Set(patternType.split('')));
            uniqueSymbols.forEach((symbol, i) => { imageMap[symbol] = images[i]; });
            
            const patternUnitSequence = patternType.split('').map(sym => imageMap[sym]);
            
            let fullSequence = [];
            for (let i = 0; i < 5; i++) { 
                fullSequence.push(...patternUnitSequence);
            }

            let displayRow;
            let answerImage;
            let finalSequenceForAnswerKey;
            
            const thirdSetPartialLength = Math.floor(Math.random() * patternType.length);
            let itemsToShowCount = (patternType.length * 2) + thirdSetPartialLength;
            
            const startOffset = randomStart ? Math.floor(Math.random() * patternType.length) : 0;
            
            displayRow = fullSequence.slice(startOffset, startOffset + itemsToShowCount);
            answerImage = fullSequence[startOffset + itemsToShowCount];
            
            if (questionType === 'blank' && randomBlank && displayRow.length > 0) {
                const blankIndex = Math.floor(Math.random() * displayRow.length);
                answerImage = displayRow[blankIndex]; 
                finalSequenceForAnswerKey = [...displayRow]; 
                displayRow[blankIndex] = { isBlank: true }; 
            } else {
                finalSequenceForAnswerKey = [...displayRow, answerImage];
            }

            let options = [];
            if (questionType === 'options') {
                let uniqueAvailableImages = [...new Map(images.map(item => [item.path, item])).values()];
                options.push(answerImage);
                
                let wrongAnswerPool = uniqueAvailableImages.filter(img => img.path !== answerImage.path);
                wrongAnswerPool = wrongAnswerPool.sort(() => Math.random() - 0.5);

                for (let i = 0; i < 2; i++) {
                    if (wrongAnswerPool.length > i) {
                        options.push(wrongAnswerPool[i]);
                    }
                }

                while (options.length < 3) {
                    const fallbackImage = await getOneRandomImage(imageLibraryTheme, options.map(o => o.path));
                    if (fallbackImage) {
                        options.push(fallbackImage);
                    } else {
                        options.push(answerImage);
                    }
                }
                
                options = options.slice(0, 3).sort(() => Math.random() - 0.5); 
            }
            
            return { displayRow, answerImage, options, fullAnsweredSequence: finalSequenceForAnswerKey };
        }

        async function getOneRandomImage(themeName, excludePaths = []) {
            let imagePool = [...allImagesData.uploads];
            const excludeSet = new Set(excludePaths);
            try {
                if (themeName && themeName !== 'all') {
                    if (!allImagesData.themes[themeName]) {
                         const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
                         if(res.ok) allImagesData.themes[themeName] = await res.json();
                    }
                    if(allImagesData.themes[themeName]) imagePool.push(...allImagesData.themes[themeName]);
                } else {
                    const res = await fetch(`/api/images?theme=animals&locale=${currentLocale}`);
                    if(res.ok) imagePool.push(...(await res.json()));
                }

                const filteredPool = imagePool.filter(img => !excludeSet.has(img.path));
                if (filteredPool.length > 0) {
                    return getRandomElement(filteredPool);
                }
                return null;
            } catch (err) {
                console.error("Failed to fetch fallback image:", err);
                return null;
            }
        }

        async function getRandomImages(themeName, count) {
            let imagePool = [...allImagesData.uploads];
            if (themeName !== 'all') {
                if (!allImagesData.themes[themeName]) {
                    const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
                    allImagesData.themes[themeName] = await res.json();
                }
                imagePool.push(...allImagesData.themes[themeName]);
            } else {
                const res = await fetch(`/api/images?theme=animals&locale=${currentLocale}`);
                imagePool.push(...(await res.json()));
            }
            
            if (imagePool.length === 0) throw new Error(`No images found for theme '${themeName}'.`);
            const uniqueImagePool = [...new Map(imagePool.map(item => [item.path, item])).values()];
            if (uniqueImagePool.length < count) throw new Error(`Not enough unique images in theme '${themeName}' for this pattern.`);

            const results = [];
            const shuffled = uniqueImagePool.sort(() => 0.5 - Math.random());
            for (let i = 0; i < count; i++) {
                results.push(shuffled[i]);
            }
            return results;
        }

        function enforceZOrder(canvas) {
            if (!canvas) return;
            const background = canvas.getObjects().find(o => o.isBackground);
            if (background) canvas.sendToBack(background);

            const border = canvas.getObjects().find(o => o.isBorder);
            if (border) {
                canvas.sendToBack(border);
                if (background) canvas.bringForward(border);
            }
        }
        
        async function renderWorksheetFromData(puzzlesToRender) {
            const canvas = worksheetCanvas;
            const oldTransforms = {};
            const userAddedObjects = canvas.getObjects().filter(o => !o.isWorksheetItem && !o.isBorder && !o.isBackground);

            // Step 1: Preserve state
            canvas.getObjects().forEach(obj => {
                if (obj.isWorksheetItem) {
                    oldTransforms[obj.originalIndex] = {
                        left: obj.left, top: obj.top,
                        scaleX: obj.scaleX, scaleY: obj.scaleY, angle: obj.angle
                    };
                }
            });
            
            // Step 2: Precise removal of old content
            const oldGeneratedItems = canvas.getObjects().filter(o => o.isWorksheetItem);
            oldGeneratedItems.forEach(o => canvas.remove(o));

            // Step 3: Regenerate and Re-apply transforms
            const puzzleCardGroups = await createPuzzleCardGroups(puzzlesToRender, 'worksheet');

            // Check if we need to relayout (when count changes or first generation)
            const needsRelayout = puzzleCardGroups.length !== Object.keys(oldTransforms).length || 
                                 Object.keys(oldTransforms).length === 0;
            
            if (needsRelayout) {
                // Add all cards first
                puzzleCardGroups.forEach(card => {
                    canvas.add(card);
                });
                // Then layout all cards properly
                layoutAndRenderPuzzleCards(canvas, puzzleCardGroups);
            } else {
                // Preserve existing positions only if count hasn't changed
                puzzleCardGroups.forEach(card => {
                    const savedTransform = oldTransforms[card.originalIndex];
                    if (savedTransform) {
                        card.set(savedTransform);
                    }
                    // Ensure cards are always selectable
                    card.set({
                        selectable: true,
                        evented: true
                    });
                    canvas.add(card);
                    card.setCoords(); // Update hit detection immediately after adding
                });
            }
            
            // Step 4: Finalize Canvas and Z-Order
            enforceZOrder(canvas);
            userAddedObjects.forEach(obj => obj.bringToFront());
            
            // Ensure all worksheet items are selectable
            canvas.getObjects().forEach(obj => {
                if (obj.isWorksheetItem) {
                    obj.set({
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true
                    });
                    obj.setCoords(); // Update hit detection area
                }
            });
            
            canvas.renderAll();
            canvas.selection = true;
            canvas.interactive = true;
            
            // Final update of all object coordinates for proper hit detection
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
        }

        async function renderAnswerKeyFromData(puzzlesToRender) {
            const canvas = answerKeyCanvas;
            const oldTransforms = {};
            const userAddedObjects = canvas.getObjects().filter(o => !o.isAnswerKeyItem && !o.isBorder && !o.isBackground);
            
            // Step 1: Preserve state
            canvas.getObjects().forEach(obj => {
                if (obj.isAnswerKeyItem) {
                    oldTransforms[obj.originalIndex] = {
                        left: obj.left, top: obj.top,
                        scaleX: obj.scaleX, scaleY: obj.scaleY, angle: obj.angle
                    };
                }
            });

            // Step 2: Precise Removal
            const objectsToRemove = canvas.getObjects().filter(o => o.isAnswerKeyItem || o.isBorder || o.isBackground);
            objectsToRemove.forEach(o => canvas.remove(o));

            // Step 3: Clone Decoratives
            const background = worksheetCanvas.getObjects().find(o => o.isBackground);
            if (background) {
                await new Promise(resolve => background.clone(cloned => {
                    cloned.set({ isBackground: true }); 
                    canvas.add(cloned);
                    resolve();
                }));
            }
            const border = worksheetCanvas.getObjects().find(o => o.isBorder);
            if (border) {
                 await new Promise(resolve => border.clone(cloned => {
                    cloned.set({ isBorder: true });
                    canvas.add(cloned);
                    resolve();
                }));
            }
            
            // Step 4: Regenerate, Re-apply, and Finalize
            const puzzleCardGroups = await createPuzzleCardGroups(puzzlesToRender, 'answerKey');
            
            // Check if we need to relayout (when count changes or first generation)
            const needsRelayout = puzzleCardGroups.length !== Object.keys(oldTransforms).length || 
                                 Object.keys(oldTransforms).length === 0;
            
            if (needsRelayout) {
                // Add all cards first
                puzzleCardGroups.forEach(card => {
                    canvas.add(card);
                });
                // Then layout all cards properly
                layoutAndRenderPuzzleCards(canvas, puzzleCardGroups);
            } else {
                // Preserve existing positions only if count hasn't changed
                puzzleCardGroups.forEach(card => {
                    const savedTransform = oldTransforms[card.originalIndex];
                    if (savedTransform) {
                        card.set(savedTransform);
                    }
                    // Ensure cards are always selectable
                    card.set({
                        selectable: true,
                        evented: true
                    });
                    canvas.add(card);
                    card.setCoords(); // Update hit detection immediately after adding
                });
            }

            enforceZOrder(canvas);
            userAddedObjects.forEach(obj => obj.bringToFront());
            
            // Ensure all answer key items are selectable
            canvas.getObjects().forEach(obj => {
                if (obj.isAnswerKeyItem) {
                    obj.set({
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true
                    });
                    obj.setCoords(); // Update hit detection area
                }
            });
            
            canvas.renderAll();
            canvas.selection = true;
            canvas.interactive = true;
            
            // Final update of all object coordinates for proper hit detection
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
        }
        
        async function createPuzzleCardGroups(puzzles, mode) {
            const cardPromises = puzzles.map((puzzleData, index) => createSinglePuzzleCard(puzzleData, mode, index));
            return Promise.all(cardPromises);
        }

        async function createSinglePuzzleCard(puzzleData, mode, index) {
            // MAXIMIZE CARD SIZE
            const isLandscape = currentCanvasConfig.width > currentCanvasConfig.height;
            
            // Larger card configuration for maximum visibility
            const cardPadding = 20;
            const contentElements = [];
            const spacing = 15;
            
            // Larger item height for better visibility
            const itemHeight = 70;
            
            // Allow cards to be wider - we'll scale them to fit later
            const maxContentWidth = currentCanvasConfig.width * 0.8;

            let numberText, sequenceGroup, questionGroup, arrow;
            
            if (puzzleData.puzzleNumber) {
                numberText = new fabric.Text(`${puzzleData.puzzleNumber}.`, {
                    fontSize: 24, fontWeight: 'bold', fill: '#333'
                });
            }

            const sequenceToRender = (mode === 'worksheet') ? puzzleData.displayRow : puzzleData.fullAnsweredSequence;
            sequenceGroup = await createPatternRowGroup(sequenceToRender, false, itemHeight);
            
            if (mode === 'worksheet') {
                arrow = new fabric.Text('➡️', { fontSize: 30, fill: '#333' });
                if (puzzleData.questionType === 'blank' && !puzzleData.randomBlank) {
                    const boxSize = 80;
                    const blankBox = new fabric.Rect({ width: boxSize, height: boxSize, fill: '#e9f5ff', stroke: '#0284c7', strokeWidth: 2, strokeDashArray: [5, 5] });
                    const qMark = new fabric.Text('?', { left: boxSize / 2, top: boxSize / 2, fontSize: 40, fill: '#0284c7', originX: 'center', originY: 'center' });
                    questionGroup = new fabric.Group([blankBox, qMark]);
                } else if (puzzleData.questionType === 'options') {
                    const optionsGroup = await createPatternRowGroup(puzzleData.options, true, itemHeight);
                    const boxPadding = 15;
                    const optionsBox = new fabric.Rect({ 
                        width: optionsGroup.width + boxPadding * 2, 
                        height: optionsGroup.height + boxPadding * 2, 
                        fill: '#e9f5ff', 
                        stroke: '#0284c7',
                        strokeWidth: 1, 
                        rx: 10, 
                        ry: 10 
                    });
                    optionsGroup.set({ left: boxPadding, top: boxPadding });
                    questionGroup = new fabric.Group([optionsBox, optionsGroup]);
                }
            }

            let unscaledWidth = sequenceGroup.width;
            if (numberText) unscaledWidth += numberText.width + spacing;
            if (mode === 'worksheet' && (questionGroup || (puzzleData.questionType === 'blank' && !puzzleData.randomBlank))) {
                unscaledWidth += spacing + arrow.width + spacing + (questionGroup ? questionGroup.width : 0);
            }

            const scaleFactor = unscaledWidth > maxContentWidth ? maxContentWidth / unscaledWidth : 1;
            
            if (numberText) numberText.scale(scaleFactor);
            sequenceGroup.scale(scaleFactor);
            if(arrow) arrow.scale(scaleFactor);
            if(questionGroup) questionGroup.scale(scaleFactor);

            let currentX = cardPadding;
            let cardHeight = (itemHeight * scaleFactor) + (cardPadding * 2);
            let contentCenterY = cardHeight / 2;

            const allRowElements = [];
            if (numberText) allRowElements.push(numberText);
            allRowElements.push(sequenceGroup);
            if (mode === 'worksheet' && (questionGroup || (puzzleData.questionType === 'blank' && !puzzleData.randomBlank))) {
                allRowElements.push(arrow);
                if (questionGroup) allRowElements.push(questionGroup);
            }
            
            allRowElements.forEach(el => {
                el.set({ left: currentX, top: contentCenterY, originY: 'center' });
                contentElements.push(el);
                currentX += el.getScaledWidth() + (spacing * scaleFactor);
            });
            
            const cardWidth = currentX - (spacing * scaleFactor) + cardPadding;

            const cardBackground = new fabric.Rect({
                width: cardWidth, height: cardHeight,
                fill: 'white', stroke: '#e0e0e0', strokeWidth: 1,
                rx: 10, ry: 10, shadow: 'rgba(0,0,0,0.1) 0px 2px 4px'
            });
            contentElements.unshift(cardBackground);
            
            return new fabric.Group(contentElements, {
                isWorksheetItem: mode === 'worksheet',
                isAnswerKeyItem: mode === 'answerKey',
                originalIndex: index,
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                lockScalingFlip: true,
                borderColor: '#007aff',
                cornerColor: '#007aff',
                cornerSize: 12,
                transparentCorners: false,
                cornerStyle: 'circle'
            });
        }
        
        async function createPatternRowGroup(images, isOptions = false, itemHeight = 70) {
            if (!images || images.length === 0) return new fabric.Group([]);
            
            const spacing = 10;
            const fabricObjects = [];
            const itemPromises = [];

            images.forEach(itemData => {
                if (itemData && itemData.isBlank) {
                    itemPromises.push(Promise.resolve({ isBlank: true }));
                } else if (itemData && itemData.path) {
                    itemPromises.push(new Promise(resolve => {
                        fabric.Image.fromURL(itemData.path, (img) => {
                            if (img) resolve(img);
                            else {
                                console.warn("Could not load image:", itemData.path);
                                resolve(null);
                            }
                        }, { crossOrigin: 'anonymous' });
                    }));
                } else {
                    itemPromises.push(Promise.resolve(null));
                }
            });

            const loadedItems = (await Promise.all(itemPromises)).filter(item => item !== null);
            if (loadedItems.length === 0) return new fabric.Group([]);

            let currentX = 0;
            loadedItems.forEach(item => {
                let fabricObj;
                if (item.isBlank) {
                    const boxSize = itemHeight;
                    const blankBox = new fabric.Rect({ width: boxSize, height: boxSize, fill: '#e9f5ff', stroke: '#0284c7', strokeWidth: 2, strokeDashArray: [5, 5] });
                    const qMark = new fabric.Text('?', { left: boxSize / 2, top: boxSize / 2, fontSize: boxSize * 0.6, fill: '#0284c7', originX: 'center', originY: 'center' });
                    fabricObj = new fabric.Group([blankBox, qMark]);
                } else {
                    fabricObj = item;
                     if (isOptions) {
                        fabricObj.set({ stroke: '#a0a0a0', strokeWidth: 1, strokeDashArray: [4, 4] });
                    }
                }
                
                fabricObj.scaleToHeight(itemHeight);
                fabricObj.set({ left: currentX, top: 0, originX: 'left', originY: 'top' });
                fabricObjects.push(fabricObj);
                currentX += fabricObj.getScaledWidth() + spacing;
            });
            
            return new fabric.Group(fabricObjects, {
                height: itemHeight,
                width: currentX > 0 ? currentX - spacing : 0
            });
        }

        function layoutAndRenderPuzzleCards(canvas, cards) {
            if (!cards || cards.length === 0) return;
            
            const pageWidth = currentCanvasConfig.width;
            const pageHeight = currentCanvasConfig.height;
            const isLandscape = pageWidth > pageHeight;
            const exerciseCount = cards.length;
            
            // SIMPLE, CLEAR MARGINS - consistent for professional look
            const margin = {
                top: Math.round(pageHeight * 0.08),
                bottom: Math.round(pageHeight * 0.08),
                left: Math.round(pageWidth * 0.08),
                right: Math.round(pageWidth * 0.08)
            };
            
            // Available space for content
            const availableWidth = pageWidth - margin.left - margin.right;
            const availableHeight = pageHeight - margin.top - margin.bottom;
            
            // FIXED COLUMN LOGIC as per requirements
            let columns, rows;
            
            if (isLandscape) {
                // Landscape: 1 column for ≤5 exercises, 2 columns for >5
                columns = exerciseCount <= 5 ? 1 : 2;
            } else {
                // Portrait: ALWAYS 1 column, regardless of exercise count
                columns = 1;
            }
            
            rows = Math.ceil(exerciseCount / columns);
            
            // EVENLY DISTRIBUTE exercises across the page
            // Calculate spacing to fill the entire available height
            const horizontalSpacing = columns > 1 ? Math.round(availableWidth * 0.05) : 0;
            
            // Calculate vertical spacing to distribute evenly
            let verticalSpacing;
            if (rows > 1) {
                // Calculate space needed for even distribution
                const estimatedCardHeight = 100; // Estimate for initial calculation
                const totalCardsHeight = estimatedCardHeight * rows;
                const remainingSpace = availableHeight - totalCardsHeight;
                verticalSpacing = Math.max(20, remainingSpace / (rows - 1));
            } else {
                verticalSpacing = 0;
            }
            
            // Calculate MAXIMUM card dimensions based on grid
            const maxCardWidth = (availableWidth - (horizontalSpacing * (columns - 1))) / columns;
            const maxCardHeight = (availableHeight - (verticalSpacing * (rows - 1))) / rows;
            
            // MAXIMIZE SCALE - make cards as large as possible
            let optimalScale = 999; // Start with very high scale
            
            // Find the maximum scale that fits all cards
            cards.forEach(card => {
                const widthScale = maxCardWidth / card.width;
                const heightScale = maxCardHeight / card.height;
                const cardScale = Math.min(widthScale, heightScale);
                optimalScale = Math.min(optimalScale, cardScale);
            });
            
            // Allow cards to be LARGER than original size if space permits
            const maxScale = 2.0; // Allow up to 2x original size
            const minScale = 0.3; // Minimum for readability
            optimalScale = Math.max(Math.min(optimalScale, maxScale), minScale);
            
            // Apply scaling to all cards
            cards.forEach(card => card.scale(optimalScale));
            
            // Get actual card dimensions after scaling
            const cardHeight = cards[0] ? cards[0].getScaledHeight() : 100;
            const cardWidth = cards[0] ? cards[0].getScaledWidth() : 300;
            
            // EVENLY DISTRIBUTE cards across the full page
            let cardIndex = 0;
            
            // Recalculate vertical spacing for actual card height
            const actualCardHeight = cardHeight;
            let finalVerticalSpacing;
            
            if (rows > 1) {
                // Calculate exact spacing to fill entire height
                const totalCardsHeight = actualCardHeight * rows;
                const availableForSpacing = availableHeight - totalCardsHeight;
                finalVerticalSpacing = availableForSpacing / (rows - 1);
                
                // Ensure minimum spacing
                if (finalVerticalSpacing < 10) {
                    finalVerticalSpacing = 10;
                }
            } else {
                // Single row - center vertically
                finalVerticalSpacing = 0;
            }
            
            // Calculate horizontal positioning
            const totalGridWidth = (cardWidth * columns) + (horizontalSpacing * (columns - 1));
            const startX = margin.left + Math.max(0, (availableWidth - totalGridWidth) / 2);
            
            // Start from top margin for even distribution
            let currentY = margin.top;
            
            // If single row, center it vertically
            if (rows === 1) {
                currentY = margin.top + (availableHeight - cardHeight) / 2;
            }
            
            // Position each card with EVEN DISTRIBUTION
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < columns && cardIndex < cards.length; col++) {
                    const card = cards[cardIndex];
                    
                    // Calculate position
                    const x = startX + (col * (cardWidth + horizontalSpacing));
                    const y = currentY;
                    
                    // Set card position
                    card.set({
                        left: x,
                        top: y,
                        selectable: true,
                        evented: true
                    });
                    card.setCoords();
                    
                    cardIndex++;
                }
                
                // Move to next row position
                currentY += cardHeight + finalVerticalSpacing;
            }
        }
        
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        async function downloadImageFile(canvasToExport, format = 'jpeg', filenamePrefix = 'download') {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                showMessage(`Cannot download, the selected page is empty.`, 'error');
                return;
            }
            showMessage(`Preparing ${format.toUpperCase()}...`, 'info', 0);
            
            try {
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, {
                    format: format,
                    quality: 1.0,
                    multiplier: downloadMultiplier,
                    applyGrayscale: ui.grayscaleToggle.checked
                });
                downloadDataURL(dataURL, `${filenamePrefix}.${format}`);
                showMessage('Download initiated!', 'success', 3000);
            } catch (err) {
                showMessage(`Error creating file: ${err.message}`, 'error');
            }
        }
        
        
    // Check if user is on free tier
    function isFreeTier() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('tier') === 'free';
    }

    // Add watermark to canvas before export
    function addWatermarkToCanvas(canvas) {
        if (!isFreeTier()) return;
        
        const watermarkText = new fabric.Text('FREE VERSION - LessonCraftStudio.com', {
            fontSize: 40,
            fill: 'rgba(0, 0, 0, 0.2)',
            angle: -45,
            left: canvas.width / 2,
            top: canvas.height / 2,
            originX: 'center',
            originY: 'center',
            selectable: false,
            evented: false,
            fontFamily: 'Arial, sans-serif',
            fontWeight: 'bold'
        });
        
        // Add multiple watermarks across the canvas
        const watermarks = [];
        const spacing = 250;
        for (let x = 0; x < canvas.width; x += spacing) {
            for (let y = 0; y < canvas.height; y += spacing) {
                const wm = new fabric.Text('FREE VERSION', {
                    fontSize: 20,
                    fill: 'rgba(0, 0, 0, 0.15)',
                    angle: -45,
                    left: x,
                    top: y,
                    selectable: false,
                    evented: false,
                    fontFamily: 'Arial, sans-serif'
                });
                watermarks.push(wm);
                canvas.add(wm);
            }
        }
        
        // Add main watermark
        canvas.add(watermarkText);
        canvas.renderAll();
        
        return { mainWatermark: watermarkText, watermarks };
    }

    // Remove watermark after export
    function removeWatermarkFromCanvas(canvas, watermarkData) {
        if (!watermarkData) return;
        
        if (watermarkData.mainWatermark) {
            canvas.remove(watermarkData.mainWatermark);
        }
        if (watermarkData.watermarks) {
            watermarkData.watermarks.forEach(wm => canvas.remove(wm));
        }
        canvas.renderAll();
    }

    // Override the original downloadPDF function
    const originalDownloadPDF = typeof downloadPDF !== 'undefined' ? downloadPDF : null;
    if (originalDownloadPDF) {
        window.downloadPDF = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage('Please generate content first.', 'error');
            }
            showMessage('Preparing PDF...', 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const { jsPDF } = window.jspdf;
                const orientation = canvasToExport.width > canvasToExport.height ? 'l' : 'p';
                const pdf = new jsPDF({ 
                    orientation, 
                    unit: 'pt', 
                    format: [canvasToExport.width, canvasToExport.height] 
                });

                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked 
                };
                
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                pdf.addImage(dataURL, 'JPEG', 0, 0, canvasToExport.width, canvasToExport.height);
                
                pdf.save(fileName);
                showMessage('PDF downloaded!', 'success');
            } catch(e) { 
                showMessage('Error creating PDF.', 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

    // Override the original downloadJPEG function if it exists
    const originalDownloadJPEG = typeof downloadJPEG !== 'undefined' ? downloadJPEG : null;
    if (originalDownloadJPEG) {
        window.downloadJPEG = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage('Please generate a worksheet first.', 'error');
            }
            showMessage('Preparing JPEG...', 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked 
                };
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = fileName;
                link.click();
                showMessage('JPEG download initiated!', 'success');
            } catch(e) { 
                showMessage('Error preparing JPEG.', 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

async function downloadPDF(canvasToExport, filename = 'download.pdf') {
             if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                showMessage(`Cannot download, the selected page is empty.`, 'error');
                return;
            }
            showMessage('Preparing PDF...', 'info', 0);

            try {
                const { jsPDF } = window.jspdf;
                const orientation = currentCanvasConfig.width > currentCanvasConfig.height ? 'landscape' : 'portrait';
                const pdf = new jsPDF({ 
                    orientation: orientation, 
                    unit: 'pt', 
                    format: [currentCanvasConfig.width, currentCanvasConfig.height] 
                });
                
                const imgData = await getCanvasDataURLWithOptions(canvasToExport, {
                    format: 'jpeg',
                    quality: 1.0,
                    multiplier: downloadMultiplier,
                    applyGrayscale: ui.grayscaleToggle.checked
                });
                
                pdf.addImage(imgData, 'JPEG', 0, 0, currentCanvasConfig.width, currentCanvasConfig.height);
                pdf.save(filename);
                showMessage('PDF Downloaded!', 'success', 3000);
            } catch (err) {
                showMessage(`Error creating PDF: ${err.message}`, "error");
            }
        }
        
        async function getCanvasDataURLWithOptions(canvasInstance, opts) {
            // Save current state
            const currentZoom = canvasInstance.getZoom();
            const currentWidth = canvasInstance.getWidth();
            const currentHeight = canvasInstance.getHeight();
            const originalBg = canvasInstance.backgroundColor;
            
            // Reset for export at actual dimensions
            canvasInstance.setZoom(1);
            canvasInstance.setDimensions({
                width: currentCanvasConfig.width,
                height: currentCanvasConfig.height
            });
            canvasInstance.backgroundColor = '#FFFFFF';
            canvasInstance.renderAll();

            const dataURL = canvasInstance.toDataURL({
                format: opts.format || 'jpeg',
                quality: opts.quality || 1.0,
                multiplier: opts.multiplier || 1
            });

            // Restore display state
            canvasInstance.setZoom(currentZoom);
            canvasInstance.setDimensions({
                width: currentWidth,
                height: currentHeight
            });
            canvasInstance.backgroundColor = originalBg;
            canvasInstance.renderAll();

            if (opts.applyGrayscale) {
                return applyGrayscaleToDataURL(dataURL, `image/${opts.format}`, opts.quality);
            }
            return dataURL;
        }

        function downloadDataURL(dataURL, filename) {
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        
        async function applyGrayscaleToDataURL(dataURL, outputFormat = 'image/jpeg', quality = 1.0) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width; tempCanvas.height = img.height;
                    const ctx = tempCanvas.getContext('2d');
                    if (!ctx) { reject(new Error("Failed to get 2D context.")); return; }
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = 0.2126 * data[i] + 0.7152 * data[i + 1] + 0.0722 * data[i + 2];
                        data[i] = data[i + 1] = data[i + 2] = gray;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(tempCanvas.toDataURL(outputFormat, quality));
                };
                img.onerror = (err) => reject(new Error('Image failed to load for grayscale conversion.'));
                img.src = dataURL;
            });
        }
        
        function updateCanvasDisplayDimensions(width, height) {
            currentCanvasConfig.width = width;
            currentCanvasConfig.height = height;

            const mainAreaStyle = getComputedStyle(document.querySelector('.tab-content-wrapper'));
            const availableWidth = parseFloat(mainAreaStyle.width) - parseFloat(mainAreaStyle.paddingLeft) - parseFloat(mainAreaStyle.paddingRight) - 50;
            const availableHeight = parseFloat(mainAreaStyle.height) - parseFloat(mainAreaStyle.paddingTop) - parseFloat(mainAreaStyle.paddingBottom) - 50;

            // Apply 25% scaling for better visibility
            const isLandscape = width > height;
            const baseScale = 1.25; // Base 25% larger for all
            const landscapeBonus = isLandscape ? 1.25 : 1.0; // Additional 25% for landscape
            const displayScale = baseScale * landscapeBonus;
            
            // Calculate display dimensions with scaling
            const scaledWidth = width * displayScale;
            const scaledHeight = height * displayScale;
            
            // Ensure it fits in available space
            const scaleRatio = Math.min(availableWidth / scaledWidth, availableHeight / scaledHeight, 1);
            const displayWidth = scaledWidth * scaleRatio;
            const displayHeight = scaledHeight * scaleRatio;
            
            [worksheetCanvas, answerKeyCanvas].forEach(c => {
                if (c) {
                    // Apply zoom for display scaling
                    const finalZoom = displayWidth / width;
                    c.setZoom(finalZoom);
                    
                    // CRITICAL: Set dimensions AFTER zoom to ensure viewport matches zoomed size
                    c.setDimensions({
                        width: displayWidth,
                        height: displayHeight
                    });
                    
                    c.calcOffset();
                    
                    // Update hit detection areas for all objects after zoom
                    c.getObjects().forEach(obj => {
                        obj.setCoords();
                    });
                    
                    c.renderAll();
                }
            });
            
            [ui.worksheetCanvasWrapper, ui.answerKeyCanvasWrapper].forEach(w => { 
                if(w) { 
                    w.style.width = displayWidth + 'px'; 
                    w.style.height = displayHeight + 'px'; 
                }
            });
            
            ui.pageWidth.value = width;
            ui.pageHeight.value = height;
        }
        function handlePageSizeChange() {
            if (this.value === 'custom') {
                ui.customPageSizeInputs.style.display = 'block';
            } else {
                ui.customPageSizeInputs.style.display = 'none';
                const [w, h] = this.value.split('x').map(Number);
                updateCanvasDisplayDimensions(w, h);
            }
        }
        function applyCustomPageSize() {
            const newWidth = parseInt(ui.pageWidth.value, 10) || currentCanvasConfig.width;
            const newHeight = parseInt(ui.pageHeight.value, 10) || currentCanvasConfig.height;
            updateCanvasDisplayDimensions(newWidth, newHeight);
        }
        function applyPageColor() {
            const newColor = ui.pageColor.value;
            [worksheetCanvas, answerKeyCanvas].forEach(c => { if(c) { c.backgroundColor = newColor; c.renderAll(); }});
        }
        function loadBorderImages() {
            loadAssetImages('border', ui.borderThemeSelect, ui.borderDictionary, ui.borderOpacitySlider, addBorderToCanvas);
        }
        function loadBackgroundImages() {
            loadAssetImages('background', ui.backgroundThemeSelect, ui.backgroundDictionary, ui.backgroundOpacitySlider, addBackgroundToCanvas);
        }
        async function loadAssetImages(type, themeSelect, dictionaryDiv, opacitySlider, addFunction) {
            const theme = themeSelect.value;
            const existingAsset = worksheetCanvas.getObjects().find(o => o[`is${type.charAt(0).toUpperCase() + type.slice(1)}`]);
            if (theme === 'none') {
                dictionaryDiv.innerHTML = `<p class="dictionary-message">Select a theme to see ${type}s.</p>`;
                if (existingAsset) worksheetCanvas.remove(existingAsset).renderAll();
                opacitySlider.disabled = true;
                return;
            }
            dictionaryDiv.innerHTML = `<p class="dictionary-message">Loading...</p>`;
            try {
                const res = await fetch(`/api/${type}s/images?theme=${theme}&locale=${currentLocale}`);
                if (!res.ok) throw new Error(`Failed to load ${type} images.`);
                const data = await res.json();
                const images = data.images || data[`${type}s`] || data || [];
                dictionaryDiv.innerHTML = "";
                images.forEach(imgData => {
                    const item = document.createElement("div");
                    item.className = "border-thumbnail-item";
                    const imgPath = imgData.url || imgData.path;
                    item.innerHTML = `<img src="${imgPath}" alt="${imgData.name}" loading="lazy" />`;
                    item.onclick = () => {
                        addFunction(imgPath);
                        dictionaryDiv.querySelectorAll('.selected').forEach(el => el.classList.remove('selected'));
                        item.classList.add('selected');
                    };
                    dictionaryDiv.appendChild(item);
                });
            } catch (err) {
                console.error(`Error loading ${type} images:`, err);
                dictionaryDiv.innerHTML = `<p class="dictionary-message">Error loading.</p>`;
            }
        }
        function addBorderToCanvas(path) {
            addCanvasAsset(path, 'isBorder', true, ui.borderOpacitySlider);
        }
        function addBackgroundToCanvas(path) {
            addCanvasAsset(path, 'isBackground', true, ui.backgroundOpacitySlider);
        }
        function addCanvasAsset(path, flag, isSelectable, opacitySlider) {
            const assetFlag = flag;
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;

            const existingAsset = activeCanvas.getObjects().find(obj => obj[assetFlag]);
            if (existingAsset) activeCanvas.remove(existingAsset);

            fabric.Image.fromURL(path, (img) => {
                if (!img) { showMessage(`Failed to load asset image.`, 'error'); return; }

                const commonConfig = {
                    left: currentCanvasConfig.width / 2, top: currentCanvasConfig.height / 2,
                    originX: 'center', originY: 'center',
                    selectable: isSelectable, evented: isSelectable,
                    opacity: parseFloat(opacitySlider.value),
                    [assetFlag]: true,
                };

                // Scale to 70% of actual canvas height (professional standard)
                const targetHeight = currentCanvasConfig.height * 0.7;
                img.scaleToHeight(targetHeight);
                img.set(commonConfig);

                activeCanvas.add(img);
                enforceZOrder(activeCanvas);
                activeCanvas.renderAll();

                opacitySlider.disabled = false;
            }, { crossOrigin: 'anonymous' });
        }
        function applyBorderOpacity() {
            applyAssetOpacity('isBorder', ui.borderOpacitySlider);
        }
        function applyBackgroundOpacity() {
            applyAssetOpacity('isBackground', ui.backgroundOpacitySlider);
        }
        function applyAssetOpacity(flag, slider) {
            const newOpacity = parseFloat(slider.value);
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const asset = activeCanvas.getObjects().find(obj => obj[flag]);
            if (asset) {
                asset.set('opacity', newOpacity);
                activeCanvas.renderAll();
            }
        }
        
        function addText() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const textContent = ui.textInput.value.trim() || 'New Text';
            const textObject = new fabric.Textbox(textContent, {
                left: (currentCanvasConfig.width - 250) / 2,
                top: (currentCanvasConfig.height - 100) / 2,
                fontSize: 48,
                fill: '#333333',
                fontFamily: 'Arial',
                width: 250,
                padding: 8,
                borderColor: 'var(--app-accent-primary)',
                cornerColor: 'var(--app-accent-primary)',
                cornerSize: 10,
                transparentCorners: false,
                cornerStyle: 'circle',
                stroke: '#000000',
                strokeWidth: 0,
                isUserText: true
            });
            activeCanvas.add(textObject).setActiveObject(textObject);
            activeCanvas.renderAll();
            ui.textInput.value = '';
        }
        
        function updateActiveTextObjectProperties() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (!activeObject || activeObject.type !== 'textbox' || !activeObject.isUserText) return;
            const newProps = {};
            let propsChanged = false;
            if (ui.textColor.value !== activeObject.fill) { newProps.fill = ui.textColor.value; propsChanged = true; }
            if (parseInt(ui.fontSize.value) !== activeObject.fontSize) { newProps.fontSize = parseInt(ui.fontSize.value); propsChanged = true; }
            if (ui.fontFamily.value !== activeObject.fontFamily) { newProps.fontFamily = ui.fontFamily.value; propsChanged = true; }
            if (ui.textStrokeColor.value !== activeObject.stroke) { newProps.stroke = ui.textStrokeColor.value; propsChanged = true; }
            if (parseFloat(ui.textStrokeWidth.value) !== activeObject.strokeWidth) { newProps.strokeWidth = parseFloat(ui.textStrokeWidth.value); propsChanged = true; }
            if (document.activeElement === ui.textInput && ui.textInput.value !== activeObject.text) { newProps.text = ui.textInput.value; propsChanged = true; }
            if (propsChanged) { activeObject.set(newProps); activeCanvas.renderAll(); }
        }
        
        function setupToolbarListeners() {
            ui.layersBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(ui.layersDropdown); });
            ui.alignBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(ui.alignDropdown); });
            ui.toolbarBringForwardBtn.addEventListener('click', bringObjectForward);
            ui.toolbarSendBackwardBtn.addEventListener('click', sendObjectBackward);
            ui.toolbarDeleteBtn.addEventListener('click', deleteSelectedObjects);
            document.querySelectorAll('#alignDropdown button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const type = e.currentTarget.id.replace('Btn', '');
                    alignObjects(type);
                });
            });
            window.addEventListener('click', (e) => {
                if(activePopover && !activePopover.contains(e.target) && !e.target.closest('.dropdown-container')) {
                    closeAllPopovers();
                }
            });
        }

        function setupGlobalKeydownListener() {
            window.addEventListener('keydown', function(e) {
                const activeEl = document.activeElement;
                if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) return;
                
                const activeCanvas = getActiveCanvas();
                if (!activeCanvas) return;
                const activeObject = activeCanvas.getActiveObject();
                if (activeObject && (e.key === 'Delete' || e.key === 'Backspace')) {
                    if (activeObject.isEditing) return;
                    deleteSelectedObjects();
                }
            });
        }
        
        function handleObjectSelection(e, canvas) {
            ui.objectContextToolbar.style.display = 'flex';
            const activeObject = canvas.getActiveObject();
            if (!activeObject) {
                 handleSelectionCleared(e, canvas);
                 return;
            }
            const isGroup = activeObject.type === 'activeSelection';
            const isSingleTextObject = !isGroup && activeObject.isUserText;
            const isGeneratedItem = activeObject.isWorksheetItem || activeObject.isAnswerKeyItem;

            ui.allToolbarButtons.forEach(btn => btn.disabled = false);
            ui.toolbarDeleteBtn.disabled = false;
            
            document.querySelectorAll('#alignDropdown button').forEach(btn => {
                 btn.id.includes('Canvas') ? btn.disabled = isGroup : btn.disabled = !isGroup;
            });
             
            [ui.textColor, ui.fontSize, ui.fontFamily, ui.textStrokeColor, ui.textStrokeWidth, ui.textInput].forEach(el => el.disabled = !isSingleTextObject);
            if (isSingleTextObject) {
                ui.textInput.value = activeObject.text || "";
                ui.textColor.value = activeObject.fill || '#333333';
                ui.fontSize.value = activeObject.fontSize || 48;
                ui.fontFamily.value = activeObject.fontFamily || '-apple-system...';
                ui.textStrokeColor.value = activeObject.stroke || '#000000';
                ui.textStrokeWidth.value = activeObject.strokeWidth || 0;
            }
        }

        function handleSelectionCleared(e, canvas) {
            ui.objectContextToolbar.style.display = 'none';
            // Do not call closeAllPopovers() here to allow dropdowns to stay open
            [ui.textColor, ui.fontSize, ui.fontFamily, ui.textStrokeColor, ui.textStrokeWidth].forEach(el => el.disabled = true);
            ui.textInput.disabled = false;
        }

        function togglePopover(popover) {
            const isOpening = popover.style.display !== 'block';
            closeAllPopovers();
            if (isOpening) {
                popover.style.display = 'block';
                activePopover = popover;
            }
        }

        function closeAllPopovers() {
            if (activePopover) {
                activePopover.style.display = 'none';
                activePopover = null;
            }
            if(ui.generateDropdownContent.style.display === 'block') ui.generateDropdownContent.style.display = 'none';
            if(ui.downloadDropdownContent.style.display === 'block') ui.downloadDropdownContent.style.display = 'none';
        }

        function bringObjectForward() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject) {
                activeCanvas.bringForward(activeObject);
                enforceZOrder(activeCanvas);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        function sendObjectBackward() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject && !activeObject.isBorder && !activeObject.isBackground) {
                activeCanvas.sendBackwards(activeObject);
                enforceZOrder(activeCanvas);
                activeCanvas.renderAll();
            }
            closeAllPopovers();
        }

        function deleteSelectedObjects() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObjects = activeCanvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => {
                    activeCanvas.remove(obj);
                });
                activeCanvas.discardActiveObject().renderAll();
            }
            closeAllPopovers();
        }

        function alignObjects(type) {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObj = activeCanvas.getActiveObject();
            if (!activeObj) { closeAllPopovers(); return; }
            
            if (type.includes('Canvas')) { // Align single object to canvas
                // Use actual page dimensions, not zoomed canvas dimensions
                const actualPageWidth = currentCanvasConfig.width;
                const actualPageHeight = currentCanvasConfig.height;
                
                if (type === 'centerHCanvas') {
                    const objWidth = activeObj.getScaledWidth();
                    activeObj.set('left', (actualPageWidth - objWidth) / 2);
                    activeObj.setCoords();
                }
                if (type === 'centerVCanvas') {
                    const objHeight = activeObj.getScaledHeight();
                    activeObj.set('top', (actualPageHeight - objHeight) / 2);
                    activeObj.setCoords();
                }
            } else if (activeObj.type === 'activeSelection') { // Align multiple objects to each other
                const group = activeObj;
                const groupCenter = group.getCenterPoint();
                const groupLeft = groupCenter.x - group.width / 2;
                const groupTop = groupCenter.y - group.height / 2;
                const groupRight = groupCenter.x + group.width / 2;
                const groupBottom = groupCenter.y + group.height / 2;
                
                group._objects.forEach(function(obj) {
                    const objBounds = obj.getBoundingRect(true, true);
                    switch (type) {
                        case 'alignLeft': 
                            obj.set('left', obj.left - (objBounds.left - groupLeft));
                            break;
                        case 'alignHCenter': 
                            const objCenterX = objBounds.left + objBounds.width / 2;
                            obj.set('left', obj.left + (groupCenter.x - objCenterX));
                            break;
                        case 'alignRight': 
                            const objRight = objBounds.left + objBounds.width;
                            obj.set('left', obj.left + (groupRight - objRight));
                            break;
                        case 'alignTop': 
                            obj.set('top', obj.top - (objBounds.top - groupTop));
                            break;
                        case 'alignVCenter': 
                            const objCenterY = objBounds.top + objBounds.height / 2;
                            obj.set('top', obj.top + (groupCenter.y - objCenterY));
                            break;
                        case 'alignBottom': 
                            const objBottom = objBounds.top + objBounds.height;
                            obj.set('top', obj.top + (groupBottom - objBottom));
                            break;
                    }
                    obj.setCoords();
                });
                group.setCoords();
            } else { // Single object alignment - align to canvas if not in a group
                // Use actual page dimensions from currentCanvasConfig
                const actualPageWidth = currentCanvasConfig.width;
                const actualPageHeight = currentCanvasConfig.height;
                
                switch (type) {
                    case 'alignLeft':
                        activeObj.set('left', 0);
                        break;
                    case 'alignHCenter':
                        const objWidth = activeObj.getScaledWidth();
                        activeObj.set('left', (actualPageWidth - objWidth) / 2);
                        break;
                    case 'alignRight':
                        const objRightWidth = activeObj.getScaledWidth();
                        activeObj.set('left', actualPageWidth - objRightWidth);
                        break;
                    case 'alignTop':
                        activeObj.set('top', 0);
                        break;
                    case 'alignVCenter':
                        const objHeight = activeObj.getScaledHeight();
                        activeObj.set('top', (actualPageHeight - objHeight) / 2);
                        break;
                    case 'alignBottom':
                        const objBottomHeight = activeObj.getScaledHeight();
                        activeObj.set('top', actualPageHeight - objBottomHeight);
                        break;
                }
                activeObj.setCoords();
            }
            activeCanvas.renderAll();
            closeAllPopovers();
        }

        initializeApp();

        // Initialize BulletproofLoader to handle border/background themes
        // EXACTLY like addition.html and picture path.html do it
        if (window.BulletproofLoader) {
            console.log('Initializing BulletproofLoader with locale:', currentLocale);

            window.BulletproofLoader.init({
                borderSelect: ui.borderThemeSelect,
                backgroundSelect: ui.backgroundThemeSelect,
                locale: currentLocale  // EXPLICITLY pass the locale
            }).then(() => {
                console.log('✅ BulletproofLoader initialized successfully');
            }).catch(err => {
                console.error('❌ BulletproofLoader failed:', err);
            });
        } else {
            console.warn('⚠️ BulletproofLoader not found');
        }
    });
  </script>
</body>
</html>