<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-translate="findobjects.page.title">SpotWorks - Find the Objects Generator</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="js/translations-find-objects.js"></script>
  <script src="js/bulletproof-loader.js"></script>
  <script src="js/unified-language-manager.js"></script>
  <script src="js/border-background-sizer.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Baloo+2:wght@400;700&family=Fredoka:wght@400;500;600&family=Lexend+Deca&family=Nunito:wght@400;700&family=Quicksand:wght@300..700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" xintegrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  <style>
    /* --- Standardized UI/UX Styles --- */
    :root {
        --app-font-stack: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --app-bg-dark: #2c2c2e;
        --app-surface-dark: #3a3a3e;
        --app-border-dark: #4a4a4a;
        --app-text-primary-dark-theme: #e0e0e0;
        --app-text-secondary-dark-theme: #a0a0a0;
        --app-bg-light: #f0f2f5;
        --app-surface-light: #ffffff;
        --app-border-light: #dce1e6;
        --app-text-primary-light-theme: #1c1c1e;
        --app-text-secondary-light-theme: #545458;
        --app-accent-primary: #007aff;
        --app-accent-primary-hover: #005ecb;
        --app-accent-danger: #ff3b30;
        --app-accent-danger-hover: #d92c23;
        --sidebar-width: 340px;
    }

    /* --- Global Reset & Layout --- */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--app-font-stack);
      display: flex;
      margin: 0;
      height: 100vh;
      background-color: var(--app-bg-light);
      overflow: hidden;
      color: var(--app-text-primary-light-theme);
    }
    .layout {
        display: flex;
        flex: 1;
        overflow: hidden;
        height: 100vh;
        position: relative;
    }

    /* --- Sidebar Panel --- */
    .panel {
      width: var(--sidebar-width);
      min-width: var(--sidebar-width);
      background-color: var(--app-bg-dark);
      color: var(--app-text-primary-dark-theme);
      box-shadow: 2px 0 8px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      overflow-y: hidden;
      z-index: 10;
      padding: 0;
      transition: transform 0.3s ease-in-out;
    }

    .panel-header {
        padding: 20px 25px;
        text-align: left;
        border-bottom: 1px solid var(--app-border-dark);
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    .panel-header h2 {
        font-size: 22px;
        font-weight: 600;
        color: var(--app-text-primary-dark-theme);
        margin: 0;
    }
    .panel-content {
        overflow-y: auto;
        flex-grow: 1;
        padding: 10px 15px;
    }

    /* --- Accordion Styles --- */
    .accordion-item {
        background-color: transparent; border: none;
        border-bottom: 1px solid var(--app-border-dark);
        margin-bottom: 0; border-radius: 0; overflow: hidden;
    }
    .accordion-item:last-child { border-bottom: none; }
    .accordion-button {
        background-color: transparent; color: var(--app-text-primary-dark-theme);
        width: 100%; border: none; text-align: left; padding: 18px 10px;
        font-size: 15px; font-weight: 500; cursor: pointer;
        display: flex; justify-content: space-between; align-items: center;
        transition: background-color 0.15s ease;
    }
    .accordion-button:hover {
        color: var(--app-text-primary-dark-theme);
        background-color: rgba(255,255,255,0.05);
    }
    .accordion-button::after {
        content: '\f078'; font-family: 'Font Awesome 5 Free';
        font-weight: 900; font-size: 12px;
        transition: transform 0.2s ease-in-out;
    }
    .accordion-button.active::after { transform: rotate(-180deg); }
    .accordion-content {
        padding: 10px 10px 20px 10px; display: none;
        background-color: transparent; border-top: none;
    }
    .accordion-content.active { display: block; }
     .accordion-content h4 {
        font-size: 13px; color: var(--app-text-secondary-dark-theme);
        margin-top: 15px; margin-bottom: 8px;
        border-bottom: 1px solid var(--app-border-dark); padding-bottom: 6px;
        font-weight: 500;
    }
     .accordion-content h4:first-child { margin-top: 0; }
    .accordion-content label {
        display: block; font-size: 13px; font-weight: 400;
        color: var(--app-text-secondary-dark-theme); margin-bottom: 6px;
    }
    .accordion-content input[type="text"],
    .accordion-content input[type="number"],
    .accordion-content textarea,
    .accordion-content select {
        width: 100%; padding: 8px 10px; font-size: 13px;
        border-radius: 5px; border: 1px solid var(--app-border-dark);
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        box-sizing: border-box; margin-bottom: 12px;
    }
     /* Style for the file input button */
    .accordion-content input[type="file"] {
      color: var(--app-text-secondary-dark-theme);
      background-color: var(--app-surface-dark);
      border: 1px solid var(--app-border-dark);
      border-radius: 5px;
      padding: 8px;
      font-size: 13px;
      margin-bottom: 12px;
      width: 100%;
    }
    .accordion-content input[type="file"]::file-selector-button {
        margin-right: 10px;
        border: 1px solid var(--app-border-dark);
        background: var(--app-bg-dark);
        padding: 4px 8px;
        border-radius: 3px;
        color: var(--app-text-primary-dark-theme);
        cursor: pointer;
     }
    .accordion-content input[type="color"] {
        width: 100%; padding: 2px; height: 38px; margin-bottom: 12px;
        border-radius: 5px; border-color: var(--app-border-dark);
    }
    .accordion-content input[type="range"] { width:100%; padding: 0; margin-bottom: 12px;}
    .accordion-content input[type="checkbox"] {
        width: auto; margin-right: 8px; vertical-align: middle;
        accent-color: var(--app-accent-primary);
    }
    .accordion-content label.checkbox-label {
        display: flex; align-items: center; font-size: 13px;
        font-weight: 400; margin-bottom: 12px; cursor: pointer;
        color: var(--app-text-secondary-dark-theme);
    }
    .accordion-content button {
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        border: 1px solid var(--app-border-dark); font-weight: 500;
        width: 100%; padding: 8px 12px; font-size: 13px;
        border-radius: 5px; margin-bottom: 10px;
    }
    .accordion-content button:hover {
        background-color: #48484a; border-color: #5d5d5f;
    }
     .accordion-content button:disabled {
        background-color: var(--app-surface-dark) !important;
        color: var(--app-text-secondary-dark-theme) !important;
        border-color: var(--app-border-dark) !important;
        opacity: 0.6; cursor: not-allowed;
     }

    /* --- Dictionary & Selection Styles --- */
    #dictionary, #borderDictionary, #backgroundDictionary, #uploadedImagesPreview, .selected-items {
        border: 1px solid var(--app-border-dark);
        padding: 10px;
        max-height: 180px;
        overflow-y:auto;
        background-color: var(--app-surface-dark);
        border-radius:5px;
        margin-bottom:10px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-content: flex-start;
    }
    #dictionary p.dictionary-message, #borderDictionary p.dictionary-message, #backgroundDictionary p.dictionary-message, #uploadedImagesPreview p.dictionary-message {
        width: 100%; text-align: center; padding: 10px;
        font-size:12px; color: var(--app-text-secondary-dark-theme);
        margin: 0; align-self: center;
    }
    .dictionary-item, .thumbnail-item {
        padding:8px; border: 1px solid transparent;
        font-size:13px; transition: background-color .15s ease, border-color .15s ease;
        display:flex; flex-direction: column; align-items:center;
        border-radius: 4px; background-color: rgba(255,255,255,0.05);
        position: relative; cursor: pointer;
    }
     .thumbnail-item { padding: 4px; }
     .dictionary-item:hover, .thumbnail-item:hover {
        border-color: var(--app-accent-primary);
     }
     .thumbnail-item.selected {
        border-color: var(--app-accent-primary);
        background-color: rgba(0, 122, 255, 0.2);
     }

    .dictionary-item img, .thumbnail-item img {
        width: 50px; height: 50px; object-fit: contain;
        border:1px solid var(--app-border-dark); border-radius:3px;
        background-color: var(--app-surface-light); margin-bottom: 5px;
    }
    .dictionary-item span {
        font-size: 10px; text-align: center; word-break: break-word; max-width: 50px;
        color: var(--app-text-secondary-dark-theme);
    }
    .dict-btns {
        display: flex; gap: 4px; margin-top: 5px; width: 100%; justify-content: space-around;
    }
    .dict-btns button {
        flex: 1; font-size: 10px; padding: 2px 4px; max-width: 60px;
        margin-bottom: 0; font-weight: 400; border-radius: 3px;
    }
    .selected-item {
        display: flex; flex-direction: column; align-items: center;
        gap: 4px; padding: 4px; border-radius: 4px;
        background-color: rgba(255,255,255,0.05);
        position: relative; width: 60px;
    }
    .selected-item img {
        width: 50px; height: 50px; object-fit: contain; border: 1px solid var(--app-border-dark);
        border-radius: 3px; background-color: var(--app-surface-light);
    }
    .selected-item .remove-btn {
        position: absolute; top: -5px; right: -5px;
        background-color: var(--app-accent-danger); color: white;
        border: 1px solid var(--app-bg-dark); border-radius: 50%;
        width: 20px; height: 20px; font-size: 14px; line-height: 18px;
        cursor: pointer; z-index: 10; padding: 0; display: flex;
        align-items: center; justify-content: center;
    }

    /* --- Panel Footer & Message Bar --- */
    .panel-footer {
        padding: 15px 25px; border-top: 1px solid var(--app-border-dark);
        margin-top: auto; background-color: var(--app-bg-dark);
    }
    #message {
        padding:10px 15px; border-radius:5px; font-size:13px; text-align:center;
        min-height:20px; font-weight:500; display:none; margin-bottom: 0;
        border-width: 1px; border-style: solid;
    }
    #message.error {background-color:rgba(255, 59, 48, 0.2); color: var(--app-accent-danger); border-color: var(--app-accent-danger);}
    #message.success {background-color:rgba(52, 199, 89, 0.2); color: #34c759; border-color: #34c759;}
    #message.info {background-color:rgba(0, 122, 255, 0.15); color:var(--app-accent-primary); border-color: var(--app-accent-primary);}

    /* --- Main Content Area --- */
    .main {
      flex-grow: 1; display: flex; flex-direction: column;
      position: relative; overflow: hidden; padding: 0;
      background-color: var(--app-bg-light);
    }

    /* --- Responsive Controls --- */
    .menu-toggle-btn {
        display: none; position: absolute; top: 12px; left: 20px;
        z-index: 20; background-color: var(--app-surface-light);
        color: var(--app-text-primary-light-theme); border: 1px solid var(--app-border-light);
        border-radius: 6px; width: 38px; height: 38px; font-size: 18px;
        cursor: pointer; align-items: center; justify-content: center;
    }
    .menu-toggle-btn:hover { background-color: #e8e8ed; }
    .menu-close-btn {
        display: none; background: none; border: none;
        color: var(--app-text-secondary-dark-theme);
        font-size: 28px; line-height: 1; cursor: pointer; padding: 0 5px;
    }
    .menu-close-btn:hover { color: var(--app-text-primary-dark-theme); }
    .menu-overlay {
        display: none; position: fixed; top: 0; left: 0;
        width: 100%; height: 100%; background-color: rgba(0,0,0,0.4);
        z-index: 998;
    }
    .menu-overlay.is-active { display: block; }

    /* --- Top Right Actions --- */
    .top-right-actions {
        position: absolute; top: 12px; right: 20px; z-index: 20;
        display: flex; gap: 10px; align-items: center;
    }
    .top-right-actions .action-button {
        padding: 7px 14px; font-size: 13px; font-weight: 500;
        border-radius: 6px; border: none; color: white; cursor: pointer;
        transition: background-color 0.2s ease, transform 0.1s ease;
    }
    .top-right-actions .action-button:active { transform: scale(0.98); }
    .top-right-actions .action-button.accent { background-color: var(--app-accent-primary); }
    .top-right-actions .action-button.accent:hover { background-color: var(--app-accent-primary-hover); }
    .top-right-actions .action-button.dark-style {
        background-color: var(--app-surface-dark);
        color: var(--app-text-primary-dark-theme);
        border: 1px solid var(--app-border-dark);
    }
    .top-right-actions .action-button.dark-style:hover {
        background-color: #48484a;
        border-color: #5d5d5f;
    }
    .top-right-actions .action-button.danger {
        background-color: var(--app-surface-light);
        color: var(--app-text-primary-light-theme);
        border: 1px solid var(--app-border-light);
    }
    .top-right-actions .action-button.danger:hover { background-color: #e8e8ed; }
    .top-right-actions .action-button:disabled {
        background-color: #cccccc !important; color: #888888 !important;
        border-color: #cccccc !important; cursor: not-allowed; transform: none;
    }

    /* --- Dropdowns --- */
    .dropdown-container { position: relative; display: inline-block; }
    .dropdown-content {
        display: none; position: absolute; right: 0; top: calc(100% + 5px);
        background-color: var(--app-surface-light); min-width: 200px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15); border: 1px solid var(--app-border-light);
        border-radius: 6px; padding: 8px; z-index: 25;
    }
    .dropdown-content button {
        width: 100%; padding: 8px 12px; font-size: 13px;
        border-radius: 4px; box-sizing: border-box; margin-bottom: 6px;
        background-color: transparent; color: var(--app-text-primary-light-theme);
        border: none; cursor: pointer; text-align: left; font-weight: 400;
        transition: background-color 0.15s ease;
    }
    .dropdown-content button:last-of-type { margin-bottom: 0; }
    .dropdown-content button:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content button:disabled {
        background-color: transparent !important;
        color: var(--app-text-secondary-light-theme) !important;
        opacity: 0.6; cursor: not-allowed;
    }
    .dropdown-content .checkbox-label {
        display: flex; align-items: center; font-size: 13px;
        font-weight: 400; padding: 6px 12px; margin-top: 4px;
        margin-bottom: 0; cursor: pointer; color: var(--app-text-primary-light-theme);
        border-radius: 4px;
    }
    .dropdown-content .checkbox-label:hover { background-color: rgba(0,0,0,0.05); }
    .dropdown-content .checkbox-label input[type="checkbox"] {
        width: auto; margin-right: 8px; vertical-align: middle;
        accent-color: var(--app-accent-primary);
    }

    /* --- Tabs --- */
    .tab-row {
      display: flex; gap: 0; justify-content: flex-start;
      padding: 0 20px; border-bottom: 1px solid var(--app-border-light);
      background-color: var(--app-surface-light); margin-top: 60px;
    }
    .tab-button {
      padding: 12px 18px; background: transparent; border: none;
      border-bottom: 2px solid transparent; color: var(--app-text-secondary-light-theme);
      font-size: 14px; font-weight: 500; border-radius: 0; cursor: pointer;
      transition: color 0.2s ease, border-color 0.2s ease;
      margin-right: 10px; margin-bottom: -1px;
    }
    .tab-button:hover { color: var(--app-text-primary-light-theme); }
    .tab-button.active {
        color: var(--app-accent-primary);
        border-bottom: 2px solid var(--app-accent-primary);
    }
    .tab-content-wrapper {
        flex-grow: 1;
        display: flex;
        align-items: flex-start;
        justify-content: center;
        padding: 25px;
        overflow-y: auto;
    }
    .tab { display: none; width: 100%; height: 100%; }
    .tab.active { display: flex; flex-direction: column; }
    .canvas-container-wrapper {
        border: none;
        background-color: var(--app-surface-light);
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        border-radius: 8px;
        overflow: visible;
        margin: auto;
        position: relative;
    }
    canvas { display: block; }
    #exportArea { position: absolute; left: -9999px; top: 0; width: auto; height: auto;}

    /* START: Contextual Toolbar CSS */
    #object-context-toolbar {
        position: absolute;
        top: 100px;
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--app-surface-light);
        border-radius: 6px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.15);
        padding: 5px;
        display: flex;
        flex-direction: row;
        gap: 4px;
        z-index: 100;
        align-items: center;
        border: 1px solid var(--app-border-light);
    }
    .toolbar-group {
        display: flex;
        gap: 2px;
        align-items: center;
        padding: 0 4px;
    }
    .toolbar-group + .toolbar-group {
        border-left: 1px solid var(--app-border-light);
    }
    .toolbar-item {
        position: relative;
    }
    .context-btn {
        background: none;
        border: 1px solid transparent;
        border-radius: 4px;
        padding: 5px 7px;
        cursor: pointer;
        font-size: 15px; 
        color: var(--app-text-secondary-light-theme);
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 32px;
        transition: background-color 0.2s, color 0.2s;
    }
    .context-btn:disabled {
        color: #c5c5c7;
        cursor: not-allowed;
    }
    .context-btn:not(:disabled):hover {
        background-color: #e8e8ed;
        color: var(--app-text-primary-light-theme);
    }
    .context-btn.active-dropdown {
        background-color: #ddeeff;
        color: var(--app-accent-primary);
    }
    #toolbarDeleteBtn:not(:disabled) {
        color: var(--app-accent-danger);
    }
    #object-context-toolbar .dropdown-content {
        display: none;
        position: absolute;
        top: calc(100% + 5px);
        left: 50%;
        transform: translateX(-50%);
        background-color: var(--app-surface-light);
        min-width: 150px;
        box-shadow: 0px 5px 15px rgba(0,0,0,0.15);
        border: 1px solid var(--app-border-light);
        border-radius: 6px;
        padding: 8px;
        z-index: 101;
    }
    #object-context-toolbar .dropdown-content
    button {
        width: 100%;
        padding: 8px 12px;
        font-size: 13px;
        border-radius: 4px;
        box-sizing: border-box;
        margin-bottom: 6px;
        background-color: transparent;
        color: var(--app-text-primary-light-theme);
        border: none;
        cursor: pointer;
        text-align: left;
        font-weight: 400;
        transition: background-color 0.15s ease;
    }
    #object-context-toolbar .dropdown-content
    button:last-of-type {
        margin-bottom: 0;
    }
    #object-context-toolbar .dropdown-content
    button:hover {
        background-color: rgba(0,0,0,0.05);
    }
    /* END: Contextual Toolbar CSS */
    
    /* --- Responsive Styles --- */
    @media (max-width: 1024px) {
        :root { --sidebar-width: 300px; }
        .panel {
            position: fixed; top: 0; left: 0; height: 100vh;
            z-index: 1000; transform: translateX(-100%);
        }
        .panel.is-open { transform: translateX(0); }
        .menu-toggle-btn { display: flex; }
        .menu-close-btn { display: block; }
        .tab-row { padding: 0 15px 0 70px; }
    }

    /* ============================================
       MODERN UNIFIED HEADER STYLES
       Exact implementation from wordsearch.html lines 251-450
       ============================================ */

    .tab-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 14px 24px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
        position: relative;
        z-index: 15;
        border-radius: 0;
        margin: 0;
        gap: 16px;
    }

    .tab-buttons-container {
        display: flex;
        gap: 8px;
        align-items: center;
    }

    .tab-button {
        padding: 10px 24px;
        font-size: 14px;
        font-weight: 600;
        border: none;
        background: rgba(255, 255, 255, 0.15);
        color: rgba(255, 255, 255, 0.8);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s ease;
        backdrop-filter: blur(10px);
        position: relative;
    }

    .tab-button:hover {
        background: rgba(255, 255, 255, 0.25);
        color: white;
        transform: translateY(-1px);
    }

    .tab-button.active {
        background: rgba(255, 255, 255, 0.95);
        color: #667eea;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    /* Header Actions Container */
    .header-actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-shrink: 0;
    }

    /* --- Zoom Controls --- */
    .zoom-controls {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 6px;
        padding: 5px 10px;
        backdrop-filter: blur(10px);
    }

    .zoom-btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        color: white;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .zoom-btn:hover {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .zoom-btn:active {
        background-color: rgba(255, 255, 255, 0.15);
    }

    .zoom-percentage {
        min-width: 45px;
        text-align: center;
        font-size: 13px;
        font-weight: 600;
        color: white;
        user-select: none;
    }

    /* --- Undo/Redo Controls --- */
    .history-controls {
        display: flex;
        align-items: center;
        gap: 6px;
        background-color: rgba(255, 255, 255, 0.15);
        border: 1px solid rgba(255, 255, 255, 0.25);
        border-radius: 6px;
        padding: 5px 10px;
        backdrop-filter: blur(10px);
    }

    .history-btn {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 4px;
        padding: 6px 10px;
        font-size: 14px;
        cursor: pointer;
        color: white;
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .history-btn:hover:not(:disabled) {
        background-color: rgba(255, 255, 255, 0.2);
        border-color: rgba(255, 255, 255, 0.4);
    }

    .history-btn:active:not(:disabled) {
        background-color: rgba(255, 255, 255, 0.15);
    }

    .history-btn:disabled {
        opacity: 0.4;
        cursor: not-allowed;
    }

    /* --- Dropdown Containers --- */
    .dropdown-container {
        position: relative;
        display: inline-block;
    }

    .dropdown-content {
        display: none;
        position: absolute;
        top: 100%;
        right: 0;
        background-color: white;
        min-width: 200px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        border-radius: 8px;
        z-index: 1000;
        margin-top: 8px;
        padding: 8px 0;
    }

    .dropdown-content.show {
        display: block;
    }

    .dropdown-content button {
        display: block;
        width: 100%;
        padding: 10px 16px;
        border: none;
        background: none;
        text-align: left;
        cursor: pointer;
        font-size: 14px;
        color: #333;
        transition: background-color 0.2s;
    }

    .dropdown-content button:hover:not(:disabled) {
        background-color: #f5f5f5;
    }

    .dropdown-content button:disabled {
        color: #ccc;
        cursor: not-allowed;
    }

    /* --- Action Buttons --- */
    .action-button {
        padding: 8px 16px;
        font-size: 13px;
        font-weight: 500;
        border-radius: 6px;
        border: none;
        cursor: pointer;
        transition: all 0.2s ease;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12);
        display: flex;
        align-items: center;
        gap: 6px;
    }

    .action-button.accent {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .action-button.accent:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }

    .action-button.download-btn {
        background: rgba(255, 255, 255, 0.95);
        color: #667eea;
        border: 2px solid rgba(255, 255, 255, 0.5);
    }

    .action-button.download-btn:hover {
        background: white;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
    }

    .action-button.danger {
        background: rgba(255, 255, 255, 0.2);
        color: white;
        border: 2px solid rgba(255, 255, 255, 0.3);
    }

    .action-button.danger:hover {
        background: rgba(255, 59, 48, 0.9);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(255, 59, 48, 0.3);
    }
  </style>
</head>
<body>
  <div class="layout">
    <div id="menuOverlay" class="menu-overlay"></div>
    <div class="panel">
        <div class="panel-header">
          <h2 data-translate="findobjects.title">SpotWorks</h2>
          <button id="menuCloseBtn" class="menu-close-btn">&times;</button>
        </div>
        <div class="panel-content">
            <div class="language-selector" style="margin: 10px 15px; padding-bottom: 10px; border-bottom: 1px solid var(--app-border-dark);">
                <label data-translate="imageLibraryLanguage" style="color: var(--app-text-secondary-dark-theme); font-size: 13px;">Image Library Language:</label>
                <select id="languageSelect" style="width: 100%; padding: 6px; background: var(--app-surface-dark); color: var(--app-text-primary-dark-theme); border: 1px solid var(--app-border-dark); border-radius: 5px; font-size: 13px;">
                    <option value="en" data-translate="language.english">English</option>
                    <option value="de" data-translate="language.german">Deutsch</option>
                    <option value="fr" data-translate="language.french">Français</option>
                    <option value="es" data-translate="language.spanish">Español</option>
                    <option value="pt" data-translate="language.portuguese">Português</option>
                    <option value="it" data-translate="language.italian">Italiano</option>
                    <option value="nl" data-translate="language.dutch">Nederlands</option>
                    <option value="sv" data-translate="language.swedish">Svenska</option>
                    <option value="da" data-translate="language.danish">Dansk</option>
                    <option value="no" data-translate="language.norwegian">Norsk</option>
                    <option value="fi" data-translate="language.finnish">Suomi</option>
                </select>
            </div>

            <div class="accordion-item">
                <button class="accordion-button" data-translate="findobjects.page.scene">Page & Scene</button>
                <div class="accordion-content">
                    <h4 data-translate="findobjects.page.setup">Page Setup</h4>
                    <label for="pageSizeSelect" data-translate="findobjects.page.size.label">Page Size:</label>
                    <select id="pageSizeSelect">
                        <option value="612x792" selected data-translate="page.size.letter.portrait">Letter Portrait (8.5×11")</option>
                        <option value="792x612" data-translate="page.size.letter.landscape">Letter Landscape (11×8.5")</option>
                        <option value="595x842" data-translate="page.size.a4.portrait">A4 Portrait (210×297mm)</option>
                        <option value="842x595" data-translate="page.size.a4.landscape">A4 Landscape (297×210mm)</option>
                        <option value="custom" data-translate="page.size.custom">Custom</option>
                    </select>
                    <div id="customPageSizeInputs" style="display:none;">
                        <label for="pageWidth" data-translate="findobjects.width.label">Width (px):</label>
                        <input type="number" id="pageWidth" value="612">
                        <label for="pageHeight" data-translate="findobjects.height.label">Height (px):</label>
                        <input type="number" id="pageHeight" value="792">
                    </div>
                     <button id="setPageSizeBtn" data-translate="findobjects.apply.size">Apply Size</button>

                    <h4 data-translate="findobjects.background.title">Background</h4>
                    <label for="useDefaultDecorations" class="checkbox-label">
                        <input type="checkbox" id="useDefaultDecorations" checked /><span data-translate="findobjects.use.decorations">Use Child-Friendly Decorations</span>
                    </label>
                    <label for="pageColor" data-translate="findobjects.fallback.color">Fallback Color:</label>
                    <input type="color" id="pageColor" value="#FFFFFF">
                    <label for="backgroundThemeSelect" data-translate="findobjects.background.theme">Background Theme:</label>
                    <select id="backgroundThemeSelect">
                        <option value="none" data-translate="findobjects.background.none">None (Use Fallback Color)</option>
                    </select>
                    <div id="backgroundDictionary"><p class="dictionary-message" data-translate="findobjects.background.message">Select a theme for backgrounds.</p></div>
                    <label for="backgroundOpacity" data-translate="findobjects.background.opacity">Background Opacity:</label>
                    <input type="range" id="backgroundOpacity" min="0" max="1" step="0.05" value="1" disabled>
                    
                    <h4 data-translate="findobjects.border.title">Border</h4>
                    <label for="borderThemeSelect" data-translate="findobjects.border.theme">Border Theme:</label>
                    <select id="borderThemeSelect">
                        <option value="none" data-translate="none">None</option>
                    </select>
                    <div id="borderDictionary"><p class="dictionary-message" data-translate="findobjects.border.message">Select a theme for borders.</p></div>
                    <label for="borderOpacity" data-translate="findobjects.border.opacity">Border Opacity:</label>
                    <input type="range" id="borderOpacity" min="0" max="1" step="0.05" value="1" disabled>
                </div>
            </div>

             <div class="accordion-item">
                <button class="accordion-button" data-translate="findobjects.text.content">Text & Content</button>
                <div class="accordion-content">
                    <h4 data-translate="findobjects.text.tools">Text Tools</h4>
                    <label for="textInput" data-translate="findobjects.text.add.label">Add New Text:</label><input type="text" id="textInput" placeholder="Find the hidden objects!">
                    <button id="addTextBtn" data-translate="findobjects.add.text">Add Text</button>
                    
                    <h4 data-translate="findobjects.text.properties">Selected Text Properties</h4>
                    <label for="textColor" data-translate="findobjects.text.color.label">Color:</label><input type="color" id="textColor" value="#333333" disabled>
                    <label for="fontSize" data-translate="findobjects.text.size.label">Size:</label><input type="number" id="fontSize" value="48" min="8" disabled>
                    <label for="fontFamily" data-translate="findobjects.text.font.label">Font:</label>
                    <select id="fontFamily" disabled>
                        <option value="Lexend Deca" data-translate="font.lexend">Lexend Deca</option>
                        <option value="Baloo 2" data-translate="font.baloo">Baloo 2</option>
                        <option value="Nunito" data-translate="font.nunito">Nunito</option>
                        <option value="Quicksand" data-translate="font.quicksand">Quicksand</option>
                        <option value="Fredoka" data-translate="font.fredoka">Fredoka</option>
                        <option value="Arial" data-translate="font.arial">Arial</option>
                        <option value="Verdana" data-translate="font.verdana">Verdana</option>
                    </select>
                    <label for="textStrokeColor" data-translate="findobjects.text.outline.color.label">Outline Color:</label><input type="color" id="textStrokeColor" value="#000000" disabled>
                    <label for="textStrokeWidth" data-translate="findobjects.text.outline.width.label">Outline (0-10):</label><input type="range" id="textStrokeWidth" min="0" max="10" value="0" step="0.5" disabled>

                    <h4 style="margin-top:20px;" data-translate="findobjects.other.content.label">Other Content</h4>
                     <label for="includeNameDate" class="checkbox-label">
                        <input type="checkbox" id="includeNameDate" /><span data-translate="findobjects.include.name.date.label">Include Name/Date Fields</span>
                    </label>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-button" data-translate="findobjects.image.library">Image Library</button>
                <div class="accordion-content">
                    <h4 data-translate="findobjects.search.library">Search Library</h4>
                    <label for="themeSelect" data-translate="findobjects.filter.theme">Filter by Theme:</label>
                    <select id="themeSelect">
                        <option value="all" data-translate="findobjects.all.themes">All Themes</option>
                    </select>
                    <label for="searchInput" data-translate="findobjects.search.label">Search Images:</label>
                    <input type="text" id="searchInput" placeholder="e.g., apple, car" data-translate-placeholder="findobjects.search.placeholder" />
                    <label data-translate="findobjects.available.images.label" data-translate="findobjects.available.images.label">Available Images</label>
                    <div id="dictionary"><p class='dictionary-message'>Loading images...</p></div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-button" data-translate="findobjects.upload.custom">Upload Custom Images</button>
                <div class="accordion-content">
                    <label for="imageUploadInput" data-translate="findobjects.upload.select">Select image(s) to upload:</label>
                    <input type="file" id="imageUploadInput" multiple accept="image/*" style="display: none;">
                    <label style="margin-top:10px;" data-translate="findobjects.upload.session">Your Uploaded Images (This Session):</label>
                    <div id="uploadedImagesPreview">
                        <p class="dictionary-message" data-translate="findobjects.upload.placeholder">Your uploaded images will appear here.</p>
                    </div>
                </div>
            </div>

            <div class="accordion-item">
                <button class="accordion-button" data-translate="findobjects.object.selection">Object Selection</button>
                <div class="accordion-content">
                    <!-- Activity Mode Selector -->
                    <label for="activityModeSelect" data-translate="activityMode.label">Activity Mode:</label>
                    <select id="activityModeSelect">
                        <option value="ispy" selected data-translate="activityMode.ispy">I Spy - Find Hidden Objects</option>
                        <option value="oddoneout" data-translate="activityMode.oddoneout">Odd One Out - Find Unpaired Images</option>
                    </select>

                    <!-- I Spy Mode Controls -->
                    <div id="ispyModeControls">
                        <h4 data-translate="findobjects.distractors.label">Distractors (Select 8–12)</h4>
                    <label for="distractorThemeSelect" data-translate="findobjects.distractors.theme.label" data-translate="findobjects.distractors.theme.label">Or Select Theme for Distractors:</label>
                    <select id="distractorThemeSelect">
                        <option value="" data-translate="findobjects.no.theme.manual">-- No Theme (Use Manual Selection) --</option>
                    </select>
                    <div class="selected-items" id="distractorItems"></div>

                    <h4 style="margin-top: 20px;" data-translate="findobjects.hidden.label">Hidden Objects (Select 1–5)</h4>
                    <label for="hiddenObjectThemeSelect" data-translate="findobjects.hidden.theme.label" data-translate="findobjects.hidden.theme.label">Or Select Theme for Hidden Objects:</label>
                    <select id="hiddenObjectThemeSelect">
                        <option value="" data-translate="findobjects.no.theme.manual">-- No Theme (Use Manual Selection) --</option>
                    </select>
                    <div class="selected-items" id="hiddenItems"></div>
                    </div>
                    <!-- End I Spy Mode Controls -->

                    <!-- Odd One Out Mode Controls -->
                    <div id="oddOneOutModeControls" style="display: none;">
                        <h4 data-translate="oddoneout.pairs.heading">Pairs</h4>
                        <label for="pairsCountSelect" data-translate="oddoneout.pairs.count.label">Number of Pairs:</label>
                        <select id="pairsCountSelect">
                            <option value="8" data-translate="oddoneout.pairs.count.8">8 pairs (16 images)</option>
                            <option value="9" data-translate="oddoneout.pairs.count.9">9 pairs (18 images)</option>
                            <option value="10" selected data-translate="oddoneout.pairs.count.10">10 pairs (20 images)</option>
                            <option value="11" data-translate="oddoneout.pairs.count.11">11 pairs (22 images)</option>
                            <option value="12" data-translate="oddoneout.pairs.count.12">12 pairs (24 images)</option>
                        </select>

                        <label for="pairsThemeSelect" data-translate="oddoneout.pairs.theme.label">Or Select Theme for Pairs:</label>
                        <select id="pairsThemeSelect">
                            <option value="" selected data-translate="oddoneout.theme.manual">-- No Theme (Use Manual Selection) --</option>
                        </select>
                        <div class="selected-items" id="pairsItems"></div>

                        <h4 style="margin-top: 20px;" data-translate="oddoneout.odd.images.heading">Odd Images (Unpaired)</h4>
                        <label for="oddImagesCountSelect" data-translate="oddoneout.odd.images.count.label">Number of Odd Images:</label>
                        <select id="oddImagesCountSelect">
                            <option value="1" data-translate="oddoneout.odd.count.1">1 odd image</option>
                            <option value="2" selected data-translate="oddoneout.odd.count.2">2 odd images</option>
                            <option value="3" data-translate="oddoneout.odd.count.3">3 odd images</option>
                        </select>

                        <label for="oddImagesThemeSelect" data-translate="oddoneout.odd.images.theme.label">Or Select Theme for Odd Images:</label>
                        <select id="oddImagesThemeSelect">
                            <option value="" selected data-translate="oddoneout.theme.manual">-- No Theme (Use Manual Selection) --</option>
                        </select>
                        <div class="selected-items" id="oddImagesItems"></div>
                    </div>
                    <!-- End Odd One Out Mode Controls -->
                </div>
            </div>
        </div>
        <div class="panel-footer">
            <div id="message"></div>
        </div>
    </div>

    <div class="main">
      <button id="menuToggleBtn" class="menu-toggle-btn"><i class="fas fa-bars"></i></button>
      <div id="object-context-toolbar" style="display:none;">
          <div class="toolbar-group">
              <div class="toolbar-item">
                  <button class="context-btn" id="layersBtn" data-title-translate="toolbar.layers" title="Layers"><i class="fas fa-layer-group"></i></button>
                  <div class="dropdown-content" id="layersDropdown">
                       <button id="toolbarBringToFrontBtn" data-translate="bringToFront">Bring to Front</button>
                       <button id="toolbarBringForwardBtn" data-translate="bringForward">Bring Forward</button>
                       <button id="toolbarSendBackwardBtn" data-translate="sendBackward">Send Backward</button>
                       <button id="toolbarSendToBackBtn" data-translate="sendToBack">Send to Back</button>
                  </div>
              </div>
          </div>
          <div class="toolbar-group">
              <div class="toolbar-item">
                  <button class="context-btn" id="alignBtn" data-title-translate="toolbar.align" title="Align"><i class="fas fa-th"></i></button>
                  <div class="dropdown-content" id="alignDropdown" style="min-width: 220px; padding: 12px;">
                       <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.align.selected">Align Selected:</p>
                       <div>
                           <button class="context-btn" id="alignLeftBtn" data-title-translate="toolbar.alignLeft" title="Align Left"><i class="fas fa-align-left"></i></button>
                           <button class="context-btn" id="alignHCenterBtn" data-title-translate="toolbar.centerH" title="Center Horizontally"><i class="fas fa-align-center"></i></button>
                           <button class="context-btn" id="alignRightBtn" data-title-translate="toolbar.alignRight" title="Align Right"><i class="fas fa-align-right"></i></button>
                       </div>
                       <div style="margin-top: 5px;">
                           <button class="context-btn" id="alignTopBtn" data-title-translate="toolbar.alignTop" title="Align Top"><i class="fas fa-long-arrow-alt-up"></i></button>
                           <button class="context-btn" id="alignVCenterBtn" data-title-translate="toolbar.centerV" title="Center Vertically"><i class="fas fa-grip-lines"></i></button>
                           <button class="context-btn" id="alignBottomBtn" data-title-translate="toolbar.alignBottom" title="Align Bottom"><i class="fas fa-long-arrow-alt-down"></i></button>
                       </div>
                       <hr style="margin:8px 0; border:none; border-top:1px solid #eee;">
                       <p style="font-size:11px; margin-bottom:5px; color:#555;" data-translate="toolbar.alignToPage">Align to Page:</p>
                       <div>
                           <button class="context-btn" id="centerHCanvasBtn" data-title-translate="toolbar.centerPageH" title="Center on Page Horizontally"><i class="fas fa-arrows-alt-h"></i></button>
                           <button class="context-btn" id="centerVCanvasBtn" data-title-translate="toolbar.centerPageV" title="Center on Page Vertically"><i class="fas fa-arrows-alt-v"></i></button>
                       </div>
                  </div>
              </div>
          </div>
          <div class="toolbar-group">
              <button class="context-btn" id="toolbarDeleteBtn" data-title-translate="toolbar.delete" title="Delete Selected"><i class="fas fa-trash-alt"></i></button>
          </div>
      </div>
      <!-- Modern Unified Header -->
      <div class="tab-row">
        <div class="tab-buttons-container">
          <button class="tab-button active" data-tab="worksheetTab" data-translate="findobjects.tab.worksheet">Worksheet</button>
          <button class="tab-button" data-tab="answerKeyTab" data-translate="findobjects.tab.answer">Answer Key</button>
        </div>
        <div class="header-actions">
          <div class="zoom-controls">
            <button id="zoomOutBtn" class="zoom-btn" data-title-translate="zoom.out" title="Zoom Out"><i class="fas fa-search-minus"></i></button>
            <span id="zoomPercentage" class="zoom-percentage">100%</span>
            <button id="zoomInBtn" class="zoom-btn" data-title-translate="zoom.in" title="Zoom In"><i class="fas fa-search-plus"></i></button>
            <button id="zoomResetBtn" class="zoom-btn" data-title-translate="zoom.reset" title="Reset Zoom"><i class="fas fa-compress-arrows-alt"></i></button>
          </div>
          <div class="history-controls">
            <button id="undoBtn" class="history-btn" data-title-translate="undo" title="Undo (Ctrl+Z)" disabled><i class="fas fa-undo"></i></button>
            <button id="redoBtn" class="history-btn" data-title-translate="redo" title="Redo (Ctrl+Y)" disabled><i class="fas fa-redo"></i></button>
          </div>
          <div class="dropdown-container">
            <button id="generateDropdownBtn" class="action-button accent"><span data-translate="findobjects.generate">Generate</span> <i class="fas fa-caret-down"></i></button>
            <div id="generateDropdownContent" class="dropdown-content">
              <button id="generateWorksheetBtn" data-translate="findobjects.generate.worksheet">New Worksheet</button>
              <button id="generateAnswerKeyBtn" disabled data-translate="findobjects.generate.answer">Answer Key</button>
            </div>
          </div>
          <div class="dropdown-container">
            <button id="downloadDropdownBtn" class="action-button download-btn"><span data-translate="findobjects.download">Download</span> <i class="fas fa-caret-down" style="margin-left: 5px;"></i></button>
            <div id="downloadDropdownContent" class="dropdown-content">
              <button id="downloadWorksheetJpegBtn" disabled data-translate="findobjects.download.worksheet.jpeg">Worksheet (JPEG)</button>
              <button id="downloadAnswerKeyJpegBtn" disabled data-translate="findobjects.download.answer.jpeg">Answer Key (JPEG)</button>
              <hr style="margin: 6px 0; border-color: #eee;">
              <button id="downloadWorksheetPdfBtn" disabled data-translate="findobjects.download.worksheet.pdf">Worksheet (PDF)</button>
              <button id="downloadAnswerKeyPdfBtn" disabled data-translate="findobjects.download.answer.pdf">Answer Key (PDF)</button>
              <hr style="margin: 6px 0; border-color: #eee;">
              <label class="checkbox-label" id="grayscaleLabel">
                <input type="checkbox" id="grayscaleToggle" /><span data-translate="common.grayscale">Grayscale</span>
              </label>
            </div>
          </div>
          <button id="clearBtn" class="action-button danger" data-translate="findobjects.clear.all">Clear All</button>
        </div>
      </div>
      <div class="tab-content-wrapper">
        <div class="tab active" id="worksheetTab">
            <div class="canvas-container-wrapper" id="worksheetCanvasWrapper">
                <canvas id="worksheetCanvasElement"></canvas>
            </div>
        </div>
        <div class="tab" id="answerKeyTab">
             <div class="canvas-container-wrapper" id="answerKeyCanvasWrapper">
                <canvas id="answerKeyCanvasElement"></canvas>
            </div>
        </div>
      </div>
    </div>
  </div>

  <div id="exportArea"></div>

  <script>
    // MUST BE FIRST - Before ANY DOM element references
    // Set locales globally BEFORE DOMContentLoaded (critical for enhancement scripts)
    // uiLocale = Interface language (from main app's language selector in header)
    // currentLocale = Content language for image library (from sidebar selector)
    const urlParams = new URLSearchParams(window.location.search);

    // UI locale comes from the main app (via URL parameter)
    window.uiLocale = urlParams.get('locale') || urlParams.get('ui') || 'en';

    // Content locale can be different (initially same as UI for simplicity)
    let currentLocale = urlParams.get('content') || window.uiLocale;
    window.currentLocale = currentLocale;

    console.log('Global uiLocale set to:', window.uiLocale);
    console.log('Global currentLocale set to:', currentLocale);


    // Function to update all elements with data-translate attribute
    
    // Update theme select options
    function updateThemeOptions() {
        // Update All Themes option if exists
        document.querySelectorAll('option[value=""]').forEach(option => {
            if (option.textContent === 'All Themes' || option.textContent.includes('All')) {
                option.textContent = t('findobjects.all.themes');
                option.setAttribute('data-translate', 'findobjects.all.themes');
            }
        });
    }

function updateTranslations() {
        // Update all elements with data-translate attribute
        document.querySelectorAll('[data-translate]').forEach(element => {
            const key = element.getAttribute('data-translate');
            if (key) {
                const translation = t(key);

                // For option elements and other elements with text content
                if (element.tagName === 'OPTION' || element.tagName === 'BUTTON' ||
                    element.tagName === 'LABEL' || element.tagName === 'H1' ||
                    element.tagName === 'H2' || element.tagName === 'H3' ||
                    element.tagName === 'H4' || element.tagName === 'SPAN' ||
                    element.tagName === 'P' || element.tagName === 'DIV') {
                    element.textContent = translation;
                } else if (element.tagName === 'TITLE') {
                    document.title = translation;
                }
            }
        });

        // Update placeholders
        document.querySelectorAll('[data-translate-placeholder]').forEach(element => {
            const key = element.getAttribute('data-translate-placeholder');
            if (key && element.placeholder !== undefined) {
                element.placeholder = t(key);
            }
        });

        // Also check for data-placeholder-translate for backwards compatibility
        document.querySelectorAll('[data-placeholder-translate]').forEach(element => {
            const key = element.getAttribute('data-placeholder-translate');
            if (key && element.placeholder !== undefined) {
                element.placeholder = t(key);
            }
        });

        // Translate title attributes (tooltips)
        document.querySelectorAll('[data-title-translate]').forEach(element => {
            const key = element.getAttribute('data-title-translate');
            if (key && typeof t !== 'undefined') {
                const translation = t(key);
                if (translation && translation !== key) {
                    element.title = translation;
                }
            }
        });
    }

    // Wrapper function for unified-language-manager.js compatibility
    // The unified-language-manager calls applyTranslations() when language changes
    function applyTranslations() {
        updateTranslations();
        updateThemeOptions();
    }

    // Handle file input translation
    function setupFileInputTranslation() {
        const fileInput = document.getElementById('imageUploadInput');
        if (fileInput && !fileInput.dataset.translated) {
            // Create custom button and label
            const wrapper = document.createElement('div');
            wrapper.className = 'custom-file-input-wrapper';
            wrapper.style.display = 'flex';
            wrapper.style.alignItems = 'center';
            wrapper.style.gap = '10px';

            const customButton = document.createElement('button');
            customButton.type = 'button';
            customButton.textContent = t('findobjects.choose.files');
            customButton.setAttribute('data-translate', 'findobjects.choose.files');
            customButton.className = 'file-input-button';
            customButton.style.padding = '5px 10px';
            customButton.style.cursor = 'pointer';

            const statusLabel = document.createElement('span');
            statusLabel.textContent = t('findobjects.no.file.chosen');
            statusLabel.setAttribute('data-translate', 'findobjects.no.file.chosen');
            statusLabel.className = 'file-input-status';
            statusLabel.style.color = '#666';

            // Hide original input
            fileInput.style.display = 'none';
            fileInput.dataset.translated = 'true';

            // Insert custom elements
            fileInput.parentNode.insertBefore(wrapper, fileInput.nextSibling);
            wrapper.appendChild(customButton);
            wrapper.appendChild(statusLabel);

            // Handle button click
            customButton.addEventListener('click', () => fileInput.click());

            // Handle file selection
            fileInput.addEventListener('change', function() {
                if (this.files.length > 0) {
                    statusLabel.textContent = this.files.length + ' ' + t('findobjects.files.selected');
                } else {
                    statusLabel.textContent = t('findobjects.no.file.chosen');
                }
            });
        }
    }

    // Update file input when language changes
    function updateFileInputTranslation() {
        const customButton = document.querySelector('.file-input-button');
        const statusLabel = document.querySelector('.file-input-status');
        const fileInput = document.getElementById('imageUploadInput');

        if (customButton) {
            customButton.textContent = t('findobjects.choose.files');
        }

        if (statusLabel && fileInput) {
            if (fileInput.files.length > 0) {
                statusLabel.textContent = fileInput.files.length + ' ' + t('findobjects.files.selected');
            } else {
                statusLabel.textContent = t('findobjects.no.file.chosen');
            }
        }
    }


    window.updateTranslations = updateTranslations;

    document.addEventListener("DOMContentLoaded", function() {
        // --- Globals & Constants ---
        const downloadMultiplier = 6;
        let selectedDistractors = [];
        let selectedHidden = [];
        let uploadedImages = []; // ADDED: For custom uploads
        let imageCache = {};
        let lastGeneratedLayout = null;
        let lastCanvasSize = { width: 612, height: 792 };

        let worksheetCanvas, answerKeyCanvas;
        let currentCanvasConfig = { width: 612, height: 792 };
        let userZoomLevel = 1.0; // User-controlled zoom level (100% = 1.0)

        // --- UNDO/REDO STATE MANAGEMENT ---
        let historyStack = [];
        let redoStack = [];
        const MAX_HISTORY = 20;
        let isRestoringState = false; // Flag to prevent saving state during restoration
        let isGenerating = false; // Flag to prevent saving state during bulk generation
        let justRestoredFromHistory = false; // Flag to prevent preserving transforms after undo/redo

        // --- Element References ---
        const getEl = (id) => document.getElementById(id);
        const worksheetCanvasEl = getEl('worksheetCanvasElement');
        const answerKeyCanvasEl = getEl('answerKeyCanvasElement');
        const worksheetWrapper = getEl('worksheetCanvasWrapper');
        const answerKeyWrapper = getEl('answerKeyCanvasWrapper');
        const messageDiv = getEl('message');
        const generateDropdownBtn = getEl('generateDropdownBtn');
        const generateWorksheetBtn = getEl('generateWorksheetBtn');
        const generateAnswerKeyBtn = getEl('generateAnswerKeyBtn');
        const downloadDropdownBtn = getEl('downloadDropdownBtn');
        const downloadWorksheetJpegBtn = getEl('downloadWorksheetJpegBtn');
        const downloadAnswerKeyJpegBtn = getEl('downloadAnswerKeyJpegBtn');
        const downloadWorksheetPdfBtn = getEl('downloadWorksheetPdfBtn');
        const downloadAnswerKeyPdfBtn = getEl('downloadAnswerKeyPdfBtn');
        const clearBtn = getEl('clearBtn');
        const grayscaleToggle = getEl('grayscaleToggle');
        const themeSelect = getEl('themeSelect');

        // Zoom controls
        const zoomInBtn = getEl('zoomInBtn');
        const zoomOutBtn = getEl('zoomOutBtn');
        const zoomResetBtn = getEl('zoomResetBtn');
        const zoomPercentage = getEl('zoomPercentage');
        // History controls
        const undoBtn = getEl('undoBtn');
        const redoBtn = getEl('redoBtn');
        const searchInput = getEl('searchInput');
        const dictionaryDiv = getEl('dictionary');
        const languageSelect = getEl('languageSelect');
        // ADDED: Custom upload elements
        const imageUploadInput = getEl('imageUploadInput');
        const uploadedImagesPreviewDiv = getEl('uploadedImagesPreview');
        const distractorThemeSelect = getEl('distractorThemeSelect');
        const hiddenObjectThemeSelect = getEl('hiddenObjectThemeSelect');

        // Odd One Out mode variables
        const activityModeSelect = getEl('activityModeSelect');
        const ispyModeControls = getEl('ispyModeControls');
        const oddOneOutModeControls = getEl('oddOneOutModeControls');
        const pairsCountSelect = getEl('pairsCountSelect');
        const pairsThemeSelect = getEl('pairsThemeSelect');
        const pairsItems = getEl('pairsItems');
        const oddImagesCountSelect = getEl('oddImagesCountSelect');
        const oddImagesThemeSelect = getEl('oddImagesThemeSelect');
        const oddImagesItems = getEl('oddImagesItems');

        let selectedPairs = [];
        let selectedOddImages = [];
        const distractorItemsDiv = getEl('distractorItems');
        const hiddenItemsDiv = getEl('hiddenItems');
        const includeNameDate = getEl('includeNameDate');
        const textInput = getEl('textInput');
        const textColorInput = getEl('textColor');
        const fontSizeInput = getEl('fontSize');
        const fontFamilySelect = getEl('fontFamily');
        const textStrokeColorInput = getEl('textStrokeColor');
        const textStrokeWidthInput = getEl('textStrokeWidth');
        const borderThemeSelect = getEl('borderThemeSelect');
        const borderDictionary = getEl('borderDictionary');
        const borderOpacitySlider = getEl('borderOpacity');
        const backgroundThemeSelect = getEl('backgroundThemeSelect');
        const backgroundDictionary = getEl('backgroundDictionary');
        const backgroundOpacitySlider = getEl('backgroundOpacity');

        // Toolbar References
        const objectContextToolbar = document.getElementById('object-context-toolbar');
        const layersBtn = document.getElementById('layersBtn');
        const layersDropdown = document.getElementById('layersDropdown');
        const toolbarBringToFrontBtn = document.getElementById('toolbarBringToFrontBtn');
        const toolbarBringForwardBtn = document.getElementById('toolbarBringForwardBtn');
        const toolbarSendBackwardBtn = document.getElementById('toolbarSendBackwardBtn');
        const toolbarSendToBackBtn = document.getElementById('toolbarSendToBackBtn');
        const alignBtn = document.getElementById('alignBtn');
        const alignDropdown = document.getElementById('alignDropdown');
        const toolbarDeleteBtn = document.getElementById('toolbarDeleteBtn');
        const allToolbarButtons = objectContextToolbar.querySelectorAll('.context-btn');


        // --- Initial Setup ---
        function initializeApp() {
            // Set language selector to current locale
            if (languageSelect && currentLocale) {
                languageSelect.value = currentLocale;
            }

            // Apply initial translations
            updateTranslations();

            setupAccordions();
            setupResponsiveMenu();
            setupDropdowns();
            
            worksheetCanvas = initializeCanvas(worksheetCanvasEl);
            answerKeyCanvas = initializeCanvas(answerKeyCanvasEl);

            const initialColor = getEl('pageColor').value;
            if (worksheetCanvas) worksheetCanvas.backgroundColor = initialColor;
            if (answerKeyCanvas) answerKeyCanvas.backgroundColor = initialColor;

            setupEventListeners();

            // Initialize zoom display
            updateZoomDisplay();

            // Initialize undo/redo button states (from wordsearch line 1546)
            updateUndoRedoButtons();

            loadAllThemes();

            // Generate initial worksheet with default settings
            async function generateInitialWorksheet() {
                try {
                    console.log('Starting initial worksheet generation...');

                    // Wait for themes to be loaded by polling
                    let attempts = 0;
                    const maxAttempts = 30; // Reduced from 50
                    while (distractorThemeSelect.options.length <= 1 && attempts < maxAttempts) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                        attempts++;
                    }

                    if (distractorThemeSelect.options.length <= 1) {
                        console.error('Failed to load themes for initial worksheet generation');
                        return;
                    }

                    console.log('Themes loaded, configuring worksheet...');

                    // Set page size to Letter portrait
                    getEl('pageSizeSelect').value = '612x792';
                    const [w, h] = getEl('pageSizeSelect').value.split('x').map(Number);
                    updateCanvasDisplayDimensions(w, h);

                    // Set distractor theme to animals
                    distractorThemeSelect.value = 'animals';

                    // Set hidden object theme to food
                    hiddenObjectThemeSelect.value = 'food';

                    // Update the generate button state
                    updateGenerateButton();

                    console.log('Configuration complete, generating worksheet...');

                    // Wait a bit more for everything to settle
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Check if button is enabled before generating
                    if (generateDropdownBtn.disabled) {
                        console.error('Generate button still disabled, cannot generate initial worksheet');
                        return;
                    }

                    // Trigger worksheet generation
                    await generateWorksheet();

                    console.log('Initial worksheet generated successfully');
                } catch (error) {
                    console.error('Error generating initial worksheet:', error);
                }
            }

            // Initialize BulletproofLoader AFTER core functionality is set up
            if (window.BulletproofLoader) {
                window.BulletproofLoader.init({
                    borderSelect: borderThemeSelect,
                    backgroundSelect: backgroundThemeSelect
                }).then(() => {
                    console.log('BulletproofLoader initialized successfully');
                    // BulletproofLoader handles theme loading, no need for manual loading
                    // Generate initial worksheet after BulletproofLoader initialization
                    setTimeout(() => generateInitialWorksheet(), 1000);
                }).catch(error => {
                    console.error('BulletproofLoader init failed:', error);
                    // Fallback to manual loading only on error
                    loadBorderThemes();
                    loadBackgroundThemes();
                    // Still generate initial worksheet even if BulletproofLoader fails
                    setTimeout(() => generateInitialWorksheet(), 1000);
                });
            } else {
                // Fallback if BulletproofLoader not available
                loadBorderThemes();
                loadBackgroundThemes();
                // Generate initial worksheet in fallback scenario
                setTimeout(() => generateInitialWorksheet(), 1000);
            }

            loadDictionary();
            updateSelectedPanels();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        // --- Setup Functions ---
        function setupAccordions() {
            document.querySelectorAll('.accordion-button').forEach(button => {
                // Accordions start closed - removed auto-open code
                button.addEventListener('click', () => {
                    const content = button.nextElementSibling;
                    const isActive = button.classList.toggle('active');
                    content.style.display = isActive ? 'block' : 'none';
                });
            });
        }

        function setupResponsiveMenu() {
            const panel = document.querySelector('.panel');
            const menuToggleBtn = getEl('menuToggleBtn');
            const menuCloseBtn = getEl('menuCloseBtn');
            const menuOverlay = getEl('menuOverlay');
            const openMenu = () => { panel.classList.add('is-open'); menuOverlay.classList.add('is-active'); };
            const closeMenu = () => { panel.classList.remove('is-open'); menuOverlay.classList.remove('is-active'); };
            menuToggleBtn.addEventListener('click', openMenu);
            menuCloseBtn.addEventListener('click', closeMenu);
            menuOverlay.addEventListener('click', closeMenu);
        }

        function setupDropdowns() {
            const generateDropdownContent = getEl('generateDropdownContent');
            const downloadDropdownContent = getEl('downloadDropdownContent');
            
            function setupDropdown(button, content) {
                if (!button || !content) return;
                button.addEventListener('click', (event) => {
                    content.style.display = content.style.display === 'block' ? 'none' : 'block';
                    event.stopPropagation();
                });
            }
            setupDropdown(generateDropdownBtn, generateDropdownContent);
            setupDropdown(downloadDropdownBtn, downloadDropdownContent);

            window.addEventListener('click', (event) => {
                 if (generateDropdownContent && generateDropdownContent.style.display === 'block' && !generateDropdownBtn.contains(event.target)) {
                    generateDropdownContent.style.display = 'none';
                }
                if (downloadDropdownContent && downloadDropdownContent.style.display === 'block' && !downloadDropdownContent.contains(event.target) && !downloadDropdownContent.contains(event.target) ) {
                    downloadDropdownContent.style.display = 'none';
                }
            });
        }
        
        function setupEventListeners() {
            // Language selector change handler (sidebar selector - ONLY changes image library language)
            // This selector ONLY changes the image library language, NOT the UI language
            languageSelect.addEventListener('change', function() {
                const newLocale = this.value;
                currentLocale = newLocale;
                window.currentLocale = newLocale;
                console.log('Image library language changed to:', currentLocale);

                // DO NOT call updateTranslations() - UI language is controlled by header selector

                // Clear image cache to reload with new translations
                imageCache = {};
                loadAllThemes(); // Reload themes with translations
                loadDictionary(); // Reload current images
                updateSelectedPanels(); // Update selected items display

                // Update URL with content parameter instead of locale
                const url = new URL(window.location);
                url.searchParams.set('content', newLocale);
                window.history.replaceState({}, '', url);
            });

            // Zoom Controls (from wordsearch lines 1520-1522)
            zoomInBtn.addEventListener('click', zoomIn);
            zoomOutBtn.addEventListener('click', zoomOut);
            zoomResetBtn.addEventListener('click', zoomReset);

            // History Controls (from wordsearch lines 1524-1525)
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);

            generateWorksheetBtn.addEventListener('click', generateWorksheet);
            generateAnswerKeyBtn.addEventListener('click', generateAnswerKey);

            // Refactored Download Listeners
            downloadWorksheetJpegBtn.addEventListener('click', () => downloadImageFile(worksheetCanvas, 'spotworks_worksheet'));
            downloadAnswerKeyJpegBtn.addEventListener('click', () => downloadImageFile(answerKeyCanvas, 'spotworks_answer_key'));
            downloadWorksheetPdfBtn.addEventListener('click', () => downloadPDF(worksheetCanvas, 'spotworks_worksheet.pdf'));
            downloadAnswerKeyPdfBtn.addEventListener('click', () => downloadPDF(answerKeyCanvas, 'spotworks_answer_key.pdf'));
            
            clearBtn.addEventListener('click', clearAll);
            themeSelect.addEventListener('change', loadDictionary);
            searchInput.addEventListener('input', () => {
                if(this.searchTimeout) clearTimeout(this.searchTimeout);
                this.searchTimeout = setTimeout(loadDictionary, 300);
            });
            imageUploadInput.addEventListener('change', handleImageUpload);
            distractorThemeSelect.addEventListener('change', handleThemeSelectionChange);
            hiddenObjectThemeSelect.addEventListener('change', handleThemeSelectionChange);

            // Activity mode switch handler
            activityModeSelect.addEventListener('change', function() {
                const isOddOneOut = activityModeSelect.value === 'oddoneout';
                ispyModeControls.style.display = isOddOneOut ? 'none' : 'block';
                oddOneOutModeControls.style.display = isOddOneOut ? 'block' : 'none';

                // Clear selections when switching modes
                selectedDistractors = [];
                selectedHidden = [];
                selectedPairs = [];
                selectedOddImages = [];
                updateSelectionDisplay('distractor');
                updateSelectionDisplay('hidden');
                updateSelectionDisplay('pairs');
                updateSelectionDisplay('oddImages');
                updateGenerateButtonState();

                // Update dictionary button labels
                updateDictionaryButtonLabels();

                // Also update uploaded images buttons
                if (uploadedImages.length > 0) {
                    renderUploadedImages();
                }
            });

            // Theme selection handlers for odd one out mode
            pairsThemeSelect.addEventListener('change', handleThemeSelectionChange);
            oddImagesThemeSelect.addEventListener('change', handleThemeSelectionChange);
            
            borderThemeSelect.addEventListener('change', loadBorderImages);
            borderOpacitySlider.addEventListener('input', applyBorderOpacity); 
            backgroundThemeSelect.addEventListener('change', loadBackgroundImages);
            backgroundOpacitySlider.addEventListener('input', applyBackgroundOpacity);
            
            // Set initial language selector value
            if (languageSelect) {
                languageSelect.value = currentLocale;
            }
            document.querySelector('#downloadDropdownContent .checkbox-label').addEventListener('click', (e) => e.stopPropagation());

            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.addEventListener('click', () => {
                    const activeCanvas = getActiveCanvas();
                    if (activeCanvas) {
                        activeCanvas.discardActiveObject().renderAll();
                        handleSelectionCleared(null, activeCanvas); 
                    }
                    
                    document.querySelectorAll('.tab-button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    getEl(btn.dataset.tab).classList.add('active');
                });
            });

            getEl('pageSizeSelect').addEventListener('change', handlePageSizeChange);
            getEl('setPageSizeBtn').addEventListener('click', applyCustomPageSize);
            getEl('pageColor').addEventListener('input', applyPageColor);
            
            getEl('addTextBtn').addEventListener('click', addTextToCanvas);
            textColorInput.addEventListener('input', updateActiveTextObjectProperties);
            fontSizeInput.addEventListener('input', updateActiveTextObjectProperties);
            fontFamilySelect.addEventListener('change', updateActiveTextObjectProperties);
            textStrokeColorInput.addEventListener('input', updateActiveTextObjectProperties);
            textStrokeWidthInput.addEventListener('input', updateActiveTextObjectProperties);
            
            setupCanvasEventListeners(worksheetCanvas);
            setupCanvasEventListeners(answerKeyCanvas);

            window.addEventListener('keydown', (e) => {
                // Undo/Redo keyboard shortcuts (from wordsearch lines 1527-1538)
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z' || e.key === 'Z') {
                        e.preventDefault();
                        undo();
                        return;
                    }
                    if (e.key === 'y' || e.key === 'Y') {
                        e.preventDefault();
                        redo();
                        return;
                    }
                }

                const activeCanvas = getActiveCanvas();
                if (!activeCanvas) return;
                const activeObject = activeCanvas.getActiveObject();
                if (activeObject && (e.key === 'Delete' || e.key === 'Backspace')) {
                     if (document.activeElement.tagName.toLowerCase().match(/input|textarea/)) return;
                     if (activeObject.isEditing) return;
                    activeCanvas.getActiveObjects().forEach(obj => activeCanvas.remove(obj));
                    activeCanvas.discardActiveObject().renderAll();
                }
            });

            // Toolbar Listeners
            layersBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(layersDropdown); });
            alignBtn.addEventListener('click', (e) => { e.stopPropagation(); togglePopover(alignDropdown); });

            // Layer Controls
            toolbarBringToFrontBtn.addEventListener('click', bringObjectToFront);
            toolbarBringForwardBtn.addEventListener('click', bringObjectForward);
            toolbarSendBackwardBtn.addEventListener('click', sendObjectBackward);
            toolbarSendToBackBtn.addEventListener('click', sendObjectToBack);

            toolbarDeleteBtn.addEventListener('click', deleteSelectedObjects);
            document.querySelectorAll('#alignDropdown button').forEach(button => {
                button.addEventListener('click', (e) => {
                    const type = e.currentTarget.id.replace('Btn', '');
                    alignObjects(type);
                });
            });
            window.addEventListener('click', () => {
                closeAllPopovers();
            });
        }
        
        function getActiveCanvas() {
            const activeTab = document.querySelector('.tab.active');
            return activeTab && activeTab.id === 'answerKeyTab' ? answerKeyCanvas : worksheetCanvas;
        }

        function setupCanvasEventListeners(canvas) {
            canvas.on({
                'mouse:down': function(e) { if (e.target) saveCanvasState(); },
                'object:added': function(e) {
                    // Only save state for user-added objects, not during bulk operations
                    if (!isRestoringState && !isGenerating) {
                        setTimeout(() => saveCanvasState(), 100);
                    }
                },
                'object:removed': function(e) {
                    if (!isRestoringState && !isGenerating) {
                        setTimeout(() => saveCanvasState(), 100);
                    }
                },
                'selection:created': function(e) { handleObjectSelection(e, this); },
                'selection:updated': function(e) { handleObjectSelection(e, this); },
                'selection:cleared': function(e) { handleSelectionCleared(e, this); },
                'object:moving': function(e) { constrainObjectMovement(e); },
                'object:scaling': function(e) {
                    // Update coordinates during scaling
                    if (e.target) {
                        e.target.setCoords();
                    }
                }
            });
        }
        
        // Update object coordinates during movement without constraints
        function constrainObjectMovement(e) {
            const obj = e.target;
            
            // Simply update coordinates for smooth movement
            // No constraints - let users move objects freely
            obj.setCoords();
            
            // Optional: If you want to keep objects generally on the page,
            // only apply very loose constraints at extreme positions
            const zoom = obj.canvas.getZoom();
            const actualWidth = currentCanvasConfig.width;
            const actualHeight = currentCanvasConfig.height;
            
            // Only constrain if object is way off the page (e.g., 200px beyond boundaries)
            const extremeMargin = -200;
            const maxRight = actualWidth + 200;
            const maxBottom = actualHeight + 200;
            
            if (obj.left < extremeMargin) {
                obj.left = extremeMargin;
            }
            if (obj.top < extremeMargin) {
                obj.top = extremeMargin;
            }
            if (obj.left > maxRight) {
                obj.left = maxRight;
            }
            if (obj.top > maxBottom) {
                obj.top = maxBottom;
            }
        }
        
        let activePopover = null;

        function togglePopover(popover) {
            const isOpening = popover.style.display !== 'block';
            closeAllPopovers();
            if (isOpening) {
                popover.style.display = 'block';
                activePopover = popover;
            }
        }

        function closeAllPopovers() {
            if (activePopover) {
                activePopover.style.display = 'none';
                activePopover = null;
            }
            if(document.getElementById('layersBtn')) document.getElementById('layersBtn').classList.remove('active-dropdown');
            if(document.getElementById('alignBtn')) document.getElementById('alignBtn').classList.remove('active-dropdown');
        }

        // ============================================
        // Z-ORDER FUNCTIONS
        // Enhanced with console logging for debugging
        // ============================================

        function bringObjectToFront() {
            const canvas = getActiveCanvas();
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const beforeIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] Bring to Front - Before index:', beforeIndex);

                canvas.bringToFront(activeObject);

                const afterIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] After index:', afterIndex);
                canvas.renderAll();
            }
            closeAllPopovers();
        }

        function bringObjectForward() {
            const canvas = getActiveCanvas();
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const beforeIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] Bring Forward - Before index:', beforeIndex);

                canvas.bringForward(activeObject);

                const afterIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] After index:', afterIndex);
                canvas.renderAll();
            }
            closeAllPopovers();
        }

        function sendObjectBackward() {
            const canvas = getActiveCanvas();
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const beforeIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] Send Backward - Before index:', beforeIndex);

                canvas.sendBackwards(activeObject);

                const afterIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] After index:', afterIndex);
                canvas.renderAll();
            }
            closeAllPopovers();
        }

        function sendObjectToBack() {
            const canvas = getActiveCanvas();
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                const beforeIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] Send to Back - Before index:', beforeIndex);

                canvas.sendToBack(activeObject);

                const afterIndex = canvas.getObjects().indexOf(activeObject);
                console.log('[Z-ORDER] After index:', afterIndex);
                canvas.renderAll();
            }
            closeAllPopovers();
        }

        function deleteSelectedObjects() {
            const activeCanvas = getActiveCanvas();
            const activeObjects = activeCanvas.getActiveObjects();
            if (activeObjects.length > 0) {
                activeObjects.forEach(obj => activeCanvas.remove(obj));
                activeCanvas.discardActiveObject().renderAll();
            }
            closeAllPopovers();
        }

        function alignObjects(type) {
            const activeCanvas = getActiveCanvas();
            const activeObj = activeCanvas.getActiveObject();
            if (!activeObj) {
                closeAllPopovers();
                return;
            }

            if (type.includes('Canvas')) {
                // Use actual page dimensions from currentCanvasConfig, not display dimensions
                const zoom = activeCanvas.getZoom();
                if (type === 'centerHCanvas') {
                    const centerX = currentCanvasConfig.width / 2;
                    activeObj.set('left', centerX - (activeObj.getScaledWidth() / zoom / 2));
                }
                if (type === 'centerVCanvas') {
                    const centerY = currentCanvasConfig.height / 2;
                    activeObj.set('top', centerY - (activeObj.getScaledHeight() / zoom / 2));
                }
                activeObj.setCoords();
            } else if (activeObj.type === 'activeSelection') {
                const group = activeObj;
                
                group.forEachObject(function(obj) {
                    switch (type) {
                        case 'alignLeft':
                            obj.set('left', -group.width / 2);
                            break;
                        case 'alignHCenter':
                            obj.set('left', 0 - obj.getScaledWidth() / 2);
                            break;
                        case 'alignRight':
                            obj.set('left', group.width / 2 - obj.getScaledWidth());
                            break;
                        case 'alignTop':
                            obj.set('top', -group.height / 2);
                            break;
                        case 'alignVCenter':
                            obj.set('top', 0 - obj.getScaledHeight() / 2);
                            break;
                        case 'alignBottom':
                            obj.set('top', group.height / 2 - obj.getScaledHeight());
                            break;
                    }
                });
            }
            
            activeCanvas.renderAll();
            closeAllPopovers();
        }
        
        function handleThemeSelectionChange(event) {
            const isDistractor = event.target.id === 'distractorThemeSelect';
            if (event.target.value) {
                if (isDistractor) selectedDistractors = [];
                else selectedHidden = [];
                updateSelectedPanels();
                showMessage(formatTranslation(t('findobjects.msg.theme.selected'), {type: isDistractor ? t('findobjects.distractors.label') : t('findobjects.hidden.label')}));
            }
            updateGenerateButton();
        }

        function initializeCanvas(canvasEl) {
            return new fabric.Canvas(canvasEl, {
                preserveObjectStacking: true,
                enableRetinaScaling: true 
            });
        }
        
        function updateCanvasDisplayDimensions(width, height) {
            currentCanvasConfig.width = width;
            currentCanvasConfig.height = height;

            const mainStyle = getEl('worksheetTab').parentElement;
            const availableWidth = mainStyle.clientWidth - 50;
            const availableHeight = mainStyle.clientHeight - 50;
            
            // Apply 25% scaling for better visibility
            // Extra 25% for landscape orientations
            const isLandscape = width > height;
            const baseScale = 1.25; // Base 25% larger for all
            const landscapeBonus = isLandscape ? 1.25 : 1.0; // Additional 25% for landscape
            const displayScale = baseScale * landscapeBonus;
            
            // Calculate display dimensions with scaling
            const scaledWidth = width * displayScale;
            const scaledHeight = height * displayScale;
            
            // Ensure it fits in available space
            const scaleRatio = Math.min(availableWidth / scaledWidth, availableHeight / scaledHeight, 1);

            // Apply user zoom level to the display dimensions (from wordsearch lines 1691-1693)
            const displayWidth = scaledWidth * scaleRatio * userZoomLevel;
            const displayHeight = scaledHeight * scaleRatio * userZoomLevel;

            [worksheetCanvas, answerKeyCanvas].forEach(c => {
                if (c) {
                    // Apply zoom to canvas
                    const finalZoom = displayWidth / width;
                    c.setZoom(finalZoom);
                    
                    // Set dimensions AFTER zoom to match viewport
                    c.setDimensions({
                        width: displayWidth,
                        height: displayHeight
                    });
                    
                    // Update all objects' coordinates after zoom
                    c.forEachObject(function(obj) {
                        obj.setCoords();
                    });
                    
                    c.renderAll();
                }
            });
            [worksheetWrapper, answerKeyWrapper].forEach(w => {
                if(w) {
                    w.style.width = displayWidth + 'px';
                    w.style.height = displayHeight + 'px';
                }
            });
        }

        // ============================================
        // ZOOM FUNCTIONALITY
        // Exact implementation from wordsearch.html lines 1745-1767
        // ============================================

        function zoomIn() {
            // Increase zoom by 25%, max 300%
            userZoomLevel = Math.min(userZoomLevel + 0.25, 3.0);
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function zoomOut() {
            // Decrease zoom by 25%, min 25%
            userZoomLevel = Math.max(userZoomLevel - 0.25, 0.25);
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function zoomReset() {
            // Reset to 100%
            userZoomLevel = 1.0;
            updateZoomDisplay();
            updateCanvasDisplayDimensions(currentCanvasConfig.width, currentCanvasConfig.height);
        }

        function updateZoomDisplay() {
            if (zoomPercentage) {
                zoomPercentage.textContent = Math.round(userZoomLevel * 100) + '%';
            }
        }

        // ============================================
        // UNDO/REDO FUNCTIONALITY
        // Exact implementation from wordsearch.html lines 1769-1867
        // ============================================

        function saveCanvasState() {
            if (isRestoringState || isGenerating) {
                return; // Don't save state during restoration or generation
            }

            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;

            // Create state object with all custom properties preserved (from wordsearch lines 1416-1420)
            const state = {
                canvasJSON: activeCanvas.toJSON(['isGenerated', 'isHidden', 'isOddImage', 'pairId', 'uniqueId', 'isLegend', 'isBorder', 'isNameDate', 'isBackground', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc', 'isAnswerKeyItem', 'isDecoration']),
                canvasType: activeCanvas === worksheetCanvas ? 'worksheet' : 'answerKey',
                timestamp: Date.now()
            };

            historyStack.push(state);

            // Limit history size
            if (historyStack.length > MAX_HISTORY) {
                historyStack.shift();
            }

            // Clear redo stack when new action is taken
            redoStack = [];

            updateUndoRedoButtons();
        }

        function undo() {
            if (historyStack.length === 0) return;

            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;

            // Save current state to redo stack before undoing (from wordsearch lines 1439-1443)
            const currentState = {
                canvasJSON: activeCanvas.toJSON(['isGenerated', 'isHidden', 'isOddImage', 'pairId', 'uniqueId', 'isLegend', 'isBorder', 'isNameDate', 'isBackground', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc', 'isAnswerKeyItem', 'isDecoration']),
                canvasType: activeCanvas === worksheetCanvas ? 'worksheet' : 'answerKey',
                timestamp: Date.now()
            };
            redoStack.push(currentState);

            // Get previous state
            const previousState = historyStack.pop();

            // Restore previous state
            restoreCanvasState(previousState);

            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;

            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;

            // Save current state to history stack (from wordsearch lines 1461-1465)
            const currentState = {
                canvasJSON: activeCanvas.toJSON(['isGenerated', 'isHidden', 'isOddImage', 'pairId', 'uniqueId', 'isLegend', 'isBorder', 'isNameDate', 'isBackground', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc', 'isAnswerKeyItem', 'isDecoration']),
                canvasType: activeCanvas === worksheetCanvas ? 'worksheet' : 'answerKey',
                timestamp: Date.now()
            };
            historyStack.push(currentState);

            // Get next state
            const nextState = redoStack.pop();

            // Restore next state
            restoreCanvasState(nextState);

            updateUndoRedoButtons();
        }

        function restoreCanvasState(state) {
            isRestoringState = true; // Prevent saving during restoration

            // Determine target canvas based on state (from wordsearch lines 1481-1485)
            const targetCanvas = state.canvasType === 'worksheet' ? worksheetCanvas : answerKeyCanvas;
            if (!targetCanvas) {
                isRestoringState = false;
                return;
            }

            targetCanvas.loadFromJSON(state.canvasJSON, function() {
                targetCanvas.renderAll();
                isRestoringState = false;
                // Set flag to prevent preserving transforms on next generation
                justRestoredFromHistory = true;
            });
        }

        function updateUndoRedoButtons() {
            if (undoBtn) {
                undoBtn.disabled = historyStack.length === 0;
            }
            if (redoBtn) {
                redoBtn.disabled = redoStack.length === 0;
            }
        }

        function handlePageSizeChange() {
            const select = getEl('pageSizeSelect');
            if (select.value === 'custom') {
                getEl('customPageSizeInputs').style.display = 'block';
            } else {
                getEl('customPageSizeInputs').style.display = 'none';
                const [w, h] = select.value.split('x').map(Number);
                getEl('pageWidth').value = w;
                getEl('pageHeight').value = h;
                updateCanvasDisplayDimensions(w, h);

                // Auto-regenerate worksheet and answer key if they exist
                if (lastGeneratedLayout) {
                    const hasAnswerKey = answerKeyCanvas.getObjects().some(o => o.isAnswerKeyItem);
                    setTimeout(async () => {
                        await generateWorksheet();
                        // Regenerate answer key if it existed
                        if (hasAnswerKey) {
                            await generateAnswerKey();
                        }
                    }, 100);
                }
            }
        }

        function applyCustomPageSize() {
             const w = parseInt(getEl('pageWidth').value, 10) || currentCanvasConfig.width;
             const h = parseInt(getEl('pageHeight').value, 10) || currentCanvasConfig.height;
             updateCanvasDisplayDimensions(w, h);

             // Auto-regenerate worksheet and answer key if they exist
             if (lastGeneratedLayout) {
                 const hasAnswerKey = answerKeyCanvas.getObjects().some(o => o.isAnswerKeyItem);
                 setTimeout(async () => {
                     await generateWorksheet();
                     // Regenerate answer key if it existed
                     if (hasAnswerKey) {
                         await generateAnswerKey();
                     }
                 }, 100);
             }
        }

        function applyPageColor() {
             const activeCanvas = getActiveCanvas();
             const color = getEl('pageColor').value;
             if(activeCanvas) {
                activeCanvas.backgroundColor = color;
                const bgImg = activeCanvas.getObjects().find(o => o.isBackground);
                if(bgImg) {
                    activeCanvas.remove(bgImg);
                    backgroundThemeSelect.value = 'none';
                    document.querySelectorAll('#backgroundDictionary .thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
                    backgroundOpacitySlider.value = 1;
                    backgroundOpacitySlider.disabled = true;
                }
                activeCanvas.renderAll();
            }
        }

        function applyBorderOpacity() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const borderImg = activeCanvas.getObjects().find(o => o.isBorder);
            if (borderImg) {
                borderImg.set('opacity', parseFloat(borderOpacitySlider.value));
                activeCanvas.renderAll();
            }
        }
        
        function applyBackgroundOpacity() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const bgImg = activeCanvas.getObjects().find(o => o.isBackground);
            if (bgImg) {
                bgImg.set('opacity', parseFloat(backgroundOpacitySlider.value));
                activeCanvas.renderAll();
            }
        }

        function addTextToCanvas() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const textContent = textInput.value.trim() || 'New Text';

            const textObject = new fabric.Textbox(textContent, {
                left: (currentCanvasConfig.width - 250) / 2,
                top: (currentCanvasConfig.height - 100) / 2,
                fontSize: 48,
                fill: '#333333',
                fontFamily: 'Arial',
                width: 250,
                padding: 8,
                borderColor: 'var(--app-accent-primary)',
                cornerColor: 'var(--app-accent-primary)',
                cornerSize: 10,
                transparentCorners: false,
                cornerStyle: 'circle',
                stroke: '#000000',
                strokeWidth: 0
            });
            activeCanvas.add(textObject);
            activeCanvas.setActiveObject(textObject);
            activeCanvas.renderAll();
            textInput.value = '';
        }
        
        function updateActiveTextObjectProperties() {
            const activeCanvas = getActiveCanvas();
            if (!activeCanvas) return;
            const activeObject = activeCanvas.getActiveObject();
            if (activeObject && (activeObject.type === 'textbox' || activeObject.type === 'i-text')) {
                activeObject.set({
                    fill: textColorInput.value,
                    fontSize: parseInt(fontSizeInput.value, 10),
                    fontFamily: fontFamilySelect.value,
                    stroke: textStrokeColorInput.value,
                    strokeWidth: parseFloat(textStrokeWidthInput.value)
                });
                activeCanvas.renderAll();
            }
        }
        
        function handleObjectSelection(e, canvas) {
            objectContextToolbar.style.display = 'flex';
            const activeObject = canvas.getActiveObject();
            
            if (!activeObject) {
                 handleSelectionCleared(null, canvas);
                 return;
            }

            const isGroup = activeObject.type === 'activeSelection';
            allToolbarButtons.forEach(btn => btn.disabled = false);
            document.querySelectorAll('#alignDropdown button').forEach(btn => {
                if (btn.id.includes('Canvas')) {
                    btn.disabled = isGroup; 
                } else {
                    btn.disabled = !isGroup;
                }
            });

            const isSingleTextObject = activeObject.type !== 'activeSelection' && (activeObject.type === 'textbox' || activeObject.type === 'i-text' || activeObject.type === 'text');
            const textInputs = [textColorInput, fontSizeInput, fontFamilySelect, textStrokeColorInput, textStrokeWidthInput];
            
            textInputs.forEach(input => input.disabled = !isSingleTextObject);
            
            if(isSingleTextObject) {
                textColorInput.value = activeObject.fill || '#333333';
                fontSizeInput.value = activeObject.fontSize || 48;
                fontFamilySelect.value = activeObject.fontFamily || '-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif';
                textStrokeColorInput.value = activeObject.stroke || '#000000';
                textStrokeWidthInput.value = activeObject.strokeWidth || 0;
            }
        }
        
        function handleSelectionCleared(e, canvas) {
            objectContextToolbar.style.display = 'none';
            closeAllPopovers();

            const textInputs = [textColorInput, fontSizeInput, fontFamilySelect, textStrokeColorInput, textStrokeWidthInput];
            textInputs.forEach(input => {
                input.disabled = true;
            });
        }
        
        async function loadAllThemes() {
            try {
                const res = await fetch(`/api/themes-translated?locale=${currentLocale}`);
                if (!res.ok) throw new Error('Failed to fetch themes');
                const themes = await res.json();
                
                const themeDropdowns = [
                    {el: themeSelect, staticHtml: `<option value="all" data-translate="findobjects.themes.all">${t('findobjects.themes.all')}</option>`},
                    {el: distractorThemeSelect, staticHtml: `<option value="" data-translate="findobjects.no.theme.manual">${t('findobjects.no.theme.manual')}</option>`},
                    {el: hiddenObjectThemeSelect, staticHtml: `<option value="" data-translate="findobjects.no.theme.manual">${t('findobjects.no.theme.manual')}</option>`},
                    {el: pairsThemeSelect, staticHtml: `<option value="" data-translate="oddoneout.theme.manual">${t('oddoneout.theme.manual')}</option>`},
                    {el: oddImagesThemeSelect, staticHtml: `<option value="" data-translate="oddoneout.theme.manual">${t('oddoneout.theme.manual')}</option>`}
                ];
                
                themeDropdowns.forEach(dd => {
                    dd.el.innerHTML = dd.staticHtml;
                    themes.forEach(theme => {
                        const opt = document.createElement('option');
                        opt.value = theme.value;
                        opt.textContent = theme.displayName;
                        dd.el.appendChild(opt);
                    });
                });
            } catch (err) {
                showMessage(t('findobjects.msg.themes.error'), 'error');
                console.error(err);
            }
        }

        async function loadDictionary() {
            let theme = themeSelect.value;  // Changed from const to let
            const query = searchInput.value.trim().toLowerCase();
            dictionaryDiv.innerHTML = '';

            let imagesToDisplay = [];

            if (theme === 'all') {
                if (!query) {
                    // Load animals theme by default when "All Themes" is selected with no search
                    theme = 'animals';
                } else {
                    // Search across all themes
                    dictionaryDiv.innerHTML = `<p class="dictionary-message">Searching...</p>`;
                    try {
                        const res = await fetch(`/api/images?search=${encodeURIComponent(query)}&locale=${currentLocale}`);
                        if (!res.ok) throw new Error(`Failed to search for "${query}"`);
                        const searchData = await res.json();
                        imagesToDisplay = searchData.images || searchData; // Handle both new and old API formats
                    } catch (err) {
                        showMessage(formatTranslation(t('findobjects.msg.search.error'), {query: query}), 'error');
                        console.error(err);
                    }
                }
            }
            
            if (theme !== 'all' && !imagesToDisplay.length) {
                // Include locale in cache key to ensure correct language names
                const cacheKey = `${theme}-${currentLocale}`;
                if (!imageCache[cacheKey]) {
                    dictionaryDiv.innerHTML = `<p class="dictionary-message">Loading theme: ${theme}...</p>`;
                    try {
                        const res = await fetch(`/api/images?theme=${encodeURIComponent(theme)}&locale=${currentLocale}`);
                        if (!res.ok) throw new Error(`Failed to load theme: ${theme}`);
                        const themeData = await res.json();
                        imageCache[cacheKey] = themeData.images || themeData; // Handle both new and old API formats
                    } catch (err) {
                        showMessage(formatTranslation(t('findobjects.msg.theme.error'), {theme: theme}), 'error');
                        console.error(err);
                        dictionaryDiv.innerHTML = `<p class="dictionary-message">Failed to load theme.</p>`;
                        return;
                    }
                }

                const source = imageCache[cacheKey] || [];
                imagesToDisplay = query ? source.filter(img => {
                    const searchName = (img.name || img.word).toLowerCase();
                    return searchName.includes(query);
                }) : source;
            }
            
            renderImageThumbnails(dictionaryDiv, imagesToDisplay, query);
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if(!files || files.length === 0) return;

            let filesToLoad = Array.from(files).filter(f => f.type.startsWith('image/')).length;
            if(filesToLoad === 0) return;
            
            uploadedImagesPreviewDiv.innerHTML = `<p class='dictionary-message'>Loading ${filesToLoad} image(s)...</p>`;
            
            let loadedCount = 0;
            for(const file of files) {
                if(!file.type.startsWith('image/')) continue;
                const reader = new FileReader();
                reader.onload = (event) => {
                    const word = file.name.split('.').slice(0, -1).join('.');
                    if (!uploadedImages.some(img => img.path === event.target.result)) {
                        uploadedImages.push({word: word, path: event.target.result});
                    }
                    loadedCount++;
                    if (loadedCount === filesToLoad) {
                        renderUploadedImages();
                        showMessage(formatTranslation(t('findobjects.msg.uploads.available'), {count: loadedCount}), 'success');
                    }
                };
                reader.onerror = () => {
                    filesToLoad--; 
                    showMessage(formatTranslation(t('findobjects.msg.file.error'), {filename: file.name}), 'error');
                };
                reader.readAsDataURL(file);
            }
            imageUploadInput.value = ''; 
        }
        
        function renderUploadedImages() {
            renderImageThumbnails(uploadedImagesPreviewDiv, uploadedImages, '');
        }

        function renderImageThumbnails(container, images, query) {
            const isOddOneOut = activityModeSelect.value === 'oddoneout';
            container.innerHTML = '';
            if (images.length === 0) {
                container.innerHTML = `<p class="dictionary-message">No images found${query ? ` matching "${query}"` : ''}.</p>`;
                return;
            }

            images.forEach((imgData) => {
                const displayName = imgData.name || imgData.word;
                const item = document.createElement('div');
                item.className = 'dictionary-item';
                item.innerHTML = `
                    <img src="${imgData.path}" alt="${displayName}" loading="lazy"/>
                    <span>${displayName}</span>
                    <div class="dict-btns">
                        <button data-action="${isOddOneOut ? 'pairs' : 'distractor'}">${isOddOneOut ? 'Pair' : t("findobjects.distractor.button")}</button>
                        <button data-action="${isOddOneOut ? 'oddImages' : 'hidden'}">${isOddOneOut ? 'Odd' : t("findobjects.hidden.button")}</button>
                    </div>`;
                item.querySelector('.dict-btns').addEventListener('click', (e) => {
                    if (e.target.tagName === 'BUTTON') {
                        addImage(e.target.dataset.action, imgData);
                    }
                    e.stopPropagation(); 
                });
                container.appendChild(item);
            });
        }
        
        function addImage(category, imgData) {
            // Determine target array, limit, and theme select based on category
            let targetArray, limit, themeSelect;

            if (category === 'distractor') {
                targetArray = selectedDistractors;
                limit = 12;
                themeSelect = distractorThemeSelect;
            } else if (category === 'hidden') {
                targetArray = selectedHidden;
                limit = 5;
                themeSelect = hiddenObjectThemeSelect;
            } else if (category === 'pairs') {
                targetArray = selectedPairs;
                limit = 24; // 12 pairs = 24 images max
                themeSelect = pairsThemeSelect;
            } else if (category === 'oddImages') {
                targetArray = selectedOddImages;
                limit = 5;
                themeSelect = oddImagesThemeSelect;
            } else {
                console.error('Unknown category:', category);
                return;
            }

            // Check if already selected in ANY category
            const isAlreadySelected = selectedDistractors.some(i => i.path === imgData.path) ||
                                       selectedHidden.some(i => i.path === imgData.path) ||
                                       selectedPairs.some(i => i.path === imgData.path) ||
                                       selectedOddImages.some(i => i.path === imgData.path);
            if (isAlreadySelected) {
                showMessage(t('findobjects.msg.already.selected'), 'info');
                return;
            }

            if (targetArray.length >= limit) {
                showMessage(formatTranslation(t('findobjects.msg.selection.limit'), {limit: limit, category: category}), 'info');
                return;
            }

            targetArray.push(imgData);
            themeSelect.value = ""; // Clear theme when manually selecting

            updateSelectedPanels();
        }

        function updateSelectedPanels() {
            const renderPanel = (container, items, category) => {
                container.innerHTML = '';
                items.forEach((item, index) => {
                    const displayName = item.name || item.word;
                    const div = document.createElement('div');
                    div.className = 'selected-item';
                    div.innerHTML = `<img src="${item.path}" alt="${displayName}" />`;
                    const removeBtn = document.createElement('button');
                    removeBtn.innerHTML = '&times;';
                    removeBtn.className = 'remove-btn';
                    removeBtn.onclick = () => {
                        items.splice(index, 1);
                        if(category === 'distractor') distractorThemeSelect.value = "";
                        else if (category === 'hidden') hiddenObjectThemeSelect.value = "";
                        else if (category === 'pairs') pairsThemeSelect.value = "";
                        else if (category === 'oddImages') oddImagesThemeSelect.value = "";
                        updateSelectedPanels();
                    };
                    div.appendChild(removeBtn);
                    container.appendChild(div);
                });
            };
            renderPanel(distractorItemsDiv, selectedDistractors, 'distractor');
            renderPanel(hiddenItemsDiv, selectedHidden, 'hidden');
            renderPanel(pairsItems, selectedPairs, 'pairs');
            renderPanel(oddImagesItems, selectedOddImages, 'oddImages');
            updateGenerateButton();
        }

        function updateGenerateButton() {
            const distractorThemeSelected = !!distractorThemeSelect.value;
            const manualDistractorsOk = selectedDistractors.length >= 8;
            const distractorsReady = distractorThemeSelected || manualDistractorsOk;

            const hiddenObjectThemeSelected = !!hiddenObjectThemeSelect.value;
            const manualHiddenOk = selectedHidden.length >= 1 && selectedHidden.length <= 5;
            const hiddenReady = hiddenObjectThemeSelected || manualHiddenOk;

            // Check odd one out mode requirements
            const isOddOneOut = activityModeSelect.value === 'oddoneout';
            let oddOneOutReady = true;

            if (isOddOneOut) {
                const pairsCount = parseInt(pairsCountSelect.value);
                const oddCount = parseInt(oddImagesCountSelect.value);

                const pairsThemeSelected = !!pairsThemeSelect.value;
                const manualPairsOk = selectedPairs.length >= pairsCount;
                const pairsReady = pairsThemeSelected || manualPairsOk;

                const oddThemeSelected = !!oddImagesThemeSelect.value;
                const manualOddOk = selectedOddImages.length >= oddCount;
                const oddReady = oddThemeSelected || manualOddOk;

                oddOneOutReady = pairsReady && oddReady;
            }

            generateDropdownBtn.disabled = !(distractorsReady && hiddenReady);
        }


        function updateDictionaryButtonLabels() {
            // Re-render dictionary to update button actions and labels
            loadDictionary();
        }
        async function generateWorksheet() {
            // Set flag to prevent object:added events from saving during generation (from wordsearch line 1766)
            isGenerating = true;

            generateDropdownBtn.disabled = true;
            showMessage(t('findobjects.msg.generating'), 'info');
            try {
                const images = await prepareImagesForGeneration();
                if (!images) {
                    showMessage(t('findobjects.msg.prep.failed'), 'error');
                    isGenerating = false;
                    return;
                }

                lastGeneratedLayout = await generateScene(worksheetCanvas, images);
                // Store mode and odd images info for answer key generation
                if (images.mode) {
                    lastGeneratedLayout.mode = images.mode;
                    if (images.oddImages) {
                        lastGeneratedLayout.oddImages = images.oddImages;
                    }
                }

                downloadDropdownBtn.disabled = false;
                downloadWorksheetJpegBtn.disabled = false;
                downloadWorksheetPdfBtn.disabled = false;
                generateAnswerKeyBtn.disabled = false;
                showMessage(t('findobjects.msg.worksheet.success'), 'success');
            } catch (error) {
                console.error("A critical error occurred during generation:", error);
                showMessage(t('findobjects.msg.unexpected.error'), 'error');
            } finally {
                generateDropdownBtn.disabled = false;
                // Reset generating flag and save the completed worksheet state (from wordsearch lines 1821-1823)
                isGenerating = false;
                saveCanvasState();
            }
        }
        
        async function generateAnswerKey() {
            if (!lastGeneratedLayout) {
                showMessage(t('findobjects.msg.generate.first'), 'error');
                return;
            }
            // Prevent state saving during answer key generation (from wordsearch line 2419)
            isGenerating = true;
            showMessage(t('findobjects.msg.generating.answer'), 'info');

            // Canvas size change detection for answer key
            const canvasSizeChanged = lastCanvasSize.width !== currentCanvasConfig.width ||
                                     lastCanvasSize.height !== currentCanvasConfig.height;

            const oldTransforms = {};
            answerKeyCanvas.getObjects().forEach(obj => {
                // Never save transforms for legend - it should always be repositioned based on canvas size
                if (obj.isAnswerKeyItem && !obj.isLegend && !canvasSizeChanged) {
                    oldTransforms[obj.uniqueId] = {
                        left: obj.left, top: obj.top, scaleX: obj.scaleX, scaleY: obj.scaleY, angle: obj.angle
                    };
                }
            });
            const userAddedObjects = answerKeyCanvas.getObjects().filter(o => !o.isAnswerKeyItem && !o.isBorder && !o.isBackground && !o.isGenerated && !o.isPageBorder && !o.isHeaderElement && !o.isHeaderDesc);

            answerKeyCanvas.clear();
            answerKeyCanvas.backgroundColor = worksheetCanvas.backgroundColor;

            const propertiesToPreserve = ['backgroundColor', 'isGenerated', 'isHidden', 'isOddImage', 'pairId', 'uniqueId', 'isLegend', 'isBorder', 'isNameDate', 'isBackground', 'opacity', 'selectable', 'evented', 'isPageBorder', 'isHeaderElement', 'isHeaderDesc'];
            await new Promise(resolve => {
                worksheetCanvas.clone(clonedCanvas => {
                    answerKeyCanvas.loadFromJSON(clonedCanvas.toJSON(propertiesToPreserve), () => {
                        answerKeyCanvas.renderAll();
                        resolve();
                    });
                }, propertiesToPreserve);
            });

            // After cloning, remove any user-added text that was transferred from the worksheet.
            // BUT keep header title and description
            const userTextFromWorksheet = answerKeyCanvas.getObjects().filter(obj =>
                (obj.type === 'textbox' || obj.type === 'i-text' || obj.type === 'text') &&
                !obj.isGenerated &&
                !obj.isHeaderElement &&
                !obj.isHeaderDesc
            );
            userTextFromWorksheet.forEach(obj => answerKeyCanvas.remove(obj));

            const worksheetLegend = answerKeyCanvas.getObjects().find(o => o.isLegend);
            if (worksheetLegend) {
                answerKeyCanvas.remove(worksheetLegend);
            }

            // Check if this is odd one out mode or I spy mode
            const isOddOneOut = lastGeneratedLayout && lastGeneratedLayout.mode === 'oddoneout';

            if (isOddOneOut) {
                // For odd one out mode: circle the odd images (unpaired)
                const oddImagesOnCanvas = answerKeyCanvas.getObjects().filter(obj => obj.isGenerated && obj.isOddImage);
                oddImagesOnCanvas.forEach(item => {
                    const uniqueId = `ak-circle-${item.uniqueId}`;
                    const center = item.getCenterPoint();
                    // Create a circle around the odd image
                    const width = item.getScaledWidth();
                    const height = item.getScaledHeight();
                    const smallerDim = Math.min(width, height);
                    const radius = (smallerDim + 8) / 2; // Slightly larger for visibility
                    const circle = new fabric.Circle({
                        left: center.x, top: center.y, radius: radius,
                        fill: 'transparent', stroke: 'red', strokeWidth: 2,
                        originX: 'center', originY: 'center',
                        selectable: false, evented: false,
                        isAnswerKeyItem: true, uniqueId: uniqueId
                    });
                    answerKeyCanvas.add(circle);
                });
            } else {
                // For I spy mode: circle the hidden objects
                const hiddenObjectsOnCanvas = answerKeyCanvas.getObjects().filter(obj => obj.isGenerated && obj.isHidden);
                hiddenObjectsOnCanvas.forEach(item => {
                    const uniqueId = `ak-circle-${item.uniqueId}`;
                    const center = item.getCenterPoint();
                    // Create a very tight circle - just 3-5 pixels larger than the object
                    const width = item.getScaledWidth();
                    const height = item.getScaledHeight();
                    // For circular fit, use the smaller dimension plus small padding
                    const smallerDim = Math.min(width, height);
                    // Add just 6 pixels total (3 pixels on each side)
                    const radius = (smallerDim + 6) / 2;
                    const circle = new fabric.Circle({
                        left: center.x, top: center.y, radius: radius,
                        fill: 'transparent', stroke: 'red', strokeWidth: 1.5,
                        originX: 'center', originY: 'center',
                        selectable: false, evented: false,
                        isAnswerKeyItem: true, uniqueId: uniqueId
                    });
                    answerKeyCanvas.add(circle);
                });
            }

            // Skip legend for odd one out mode in answer key too
            const isOddOneOutMode = lastGeneratedLayout && lastGeneratedLayout.mode === 'oddoneout';
            const answerKeyLegend = isOddOneOutMode ? null : await createLegendGroup(true, lastGeneratedLayout);
            if (answerKeyLegend) {
                const uniqueId = 'ak-legend';
                // Position legend at the bottom with proper spacing
                const canvasWidth = currentCanvasConfig.width;
                const canvasHeight = currentCanvasConfig.height;
                const isLandscape = canvasWidth > canvasHeight;

                // Use the header's border margin (34px from createHeaderGroup)
                const borderMargin = 34;
                const legendHeight = answerKeyLegend.getScaledHeight();

                // Position legend so it sits above the bottom border with adequate spacing
                // Add extra spacing (15px) from the border edge for better visibility
                const legendTop = canvasHeight - borderMargin - legendHeight / 2 - 15;

                answerKeyLegend.set({
                    left: canvasWidth / 2,
                    top: legendTop,
                    originX: 'center',
                    originY: 'center',
                    isAnswerKeyItem: true,
                    uniqueId: uniqueId,
                    isLegend: true
                });
                // NEVER restore old transforms for legend - always position it fresh
                // The legend position is deterministic based on canvas size
                answerKeyCanvas.add(answerKeyLegend);
                answerKeyCanvas.bringToFront(answerKeyLegend); // Ensure legend is visible
            }

            enforceZOrder(answerKeyCanvas);
            userAddedObjects.forEach(o => answerKeyCanvas.add(o).bringToFront(o));
            answerKeyCanvas.renderAll();

            downloadAnswerKeyJpegBtn.disabled = false;
            downloadAnswerKeyPdfBtn.disabled = false;
            document.querySelector('.tab-button[data-tab="answerKeyTab"]').click();
            showMessage(t('findobjects.msg.answer.generated'), 'success');

            // Reset generating flag and save state (from wordsearch lines 1937-1940)
            isGenerating = false;
            saveCanvasState();
        }


        async function prepareImagesForGeneration() {
            const isOddOneOut = activityModeSelect.value === 'oddoneout';

            if (isOddOneOut) {
                return await prepareOddOneOutImages();
            } else {
                return await prepareISpyImages();
            }
        }

        async function prepareISpyImages() {
            let dists = [...selectedDistractors];
            let hidden = [...hiddenObjectThemeSelect.value ? [] : selectedHidden];

            async function getImagesFromTheme(themeName, type) {
                if (imageCache[themeName]) return imageCache[themeName];
                try {
                    const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
                    if (!res.ok) throw new Error(`Fetch failed for theme ${themeName}`);
                    const data = await res.json();
                    const images = data.images || data;
                    imageCache[themeName] = images;
                    return images;
                } catch (err) {
                    showMessage(formatTranslation(t('findobjects.msg.theme.load.error'), {type: type}), 'error');
                    return null;
                }
            }

            if (distractorThemeSelect.value) {
                const themeImages = await getImagesFromTheme(distractorThemeSelect.value, 'distractor');
                if (!themeImages || themeImages.length < 8) {
                     showMessage(t('findobjects.msg.distractor.insufficient'), 'error'); return null;
                }
                dists = getRandomSubset(themeImages, Math.floor(Math.random() * (Math.min(12, themeImages.length) - 8 + 1)) + 8);
            }

            if (hiddenObjectThemeSelect.value) {
                const themeImages = await getImagesFromTheme(hiddenObjectThemeSelect.value, 'hidden object');
                 if (!themeImages || themeImages.length < 1) {
                    showMessage(t('findobjects.msg.hidden.empty'), 'error'); return null;
                }
                hidden = getRandomSubset(themeImages, Math.floor(Math.random() * (Math.min(5, themeImages.length) - 1 + 1)) + 1);
            }

            const uniqueHidden = [...hidden];
            if (uniqueHidden.length < 1 || uniqueHidden.length > 5) { showMessage(`Hidden object count must be 1-5. You have ${uniqueHidden.length}.`, 'error'); return null; }
            if (dists.length < 8) { showMessage(t('findobjects.msg.min.distractors'), 'error'); return null;}

            let allDistractors = [...dists];
            if (allDistractors.length > 0) {
                while(allDistractors.length < 30) {
                    allDistractors.push(dists[Math.floor(Math.random() * dists.length)]);
                }
            }

            // CRITICAL: Create clean copies to prevent property pollution from previous generations
            // Strip any properties like isPair, targetSize, etc that might cause mode misdetection
            allDistractors = allDistractors.map(img => ({
                path: img.path,
                name: img.name
            }));

            let finalHidden = [];
            if (uniqueHidden.length > 0) {
                const hiddenCount = Math.floor(Math.random() * 6) + 5;
                 for (let i = 0; i < hiddenCount; i++) {
                    finalHidden.push(uniqueHidden[Math.floor(Math.random() * uniqueHidden.length)]);
                }
            }

            // Clean finalHidden and uniqueHidden as well
            finalHidden = finalHidden.map(img => ({ path: img.path, name: img.name }));
            const cleanUniqueHidden = uniqueHidden.map(img => ({ path: img.path, name: img.name }));

            return { allDistractors, finalHidden, uniqueHidden: cleanUniqueHidden, mode: 'ispy' };
        }

        async function prepareOddOneOutImages() {
            const pairsCount = parseInt(pairsCountSelect.value);
            const oddCount = parseInt(oddImagesCountSelect.value);

            let pairs = [...selectedPairs];
            let oddImages = [...selectedOddImages];

            async function getImagesFromTheme(themeName, type) {
                if (imageCache[themeName]) return imageCache[themeName];
                try {
                    const res = await fetch(`/api/images?theme=${encodeURIComponent(themeName)}&locale=${currentLocale}`);
                    if (!res.ok) throw new Error(`Fetch failed for theme ${themeName}`);
                    const data = await res.json();
                    const images = data.images || data;
                    imageCache[themeName] = images;
                    return images;
                } catch (err) {
                    showMessage(`Failed to load ${type} theme images`, 'error');
                    return null;
                }
            }

            // If theme selected for pairs, get random images
            if (pairsThemeSelect.value) {
                const themeImages = await getImagesFromTheme(pairsThemeSelect.value, 'pairs');
                if (!themeImages || themeImages.length < pairsCount) {
                    showMessage(`Not enough images in theme for ${pairsCount} pairs. Need at least ${pairsCount} images.`, 'error');
                    return null;
                }
                pairs = getRandomSubset(themeImages, pairsCount);
            }

            // If theme selected for odd images, get random images
            if (oddImagesThemeSelect.value) {
                const themeImages = await getImagesFromTheme(oddImagesThemeSelect.value, 'odd images');
                if (!themeImages || themeImages.length < oddCount) {
                    showMessage(`Not enough images in theme for ${oddCount} odd images.`, 'error');
                    return null;
                }
                oddImages = getRandomSubset(themeImages, oddCount);
            }

            // Validation
            if (pairs.length < pairsCount) {
                showMessage(`Please select at least ${pairsCount} images for pairs.`, 'error');
                return null;
            }
            if (oddImages.length < oddCount) {
                showMessage(`Please select at least ${oddCount} odd images.`, 'error');
                return null;
            }

            // Create the final image list: each pair appears twice + odd images appear once
            let allImages = [];

            // Add pairs (each image twice)
            // IMPORTANT: Mark each pair with a unique pairId so we can track them
            for (let i = 0; i < pairsCount; i++) {
                allImages.push({ ...pairs[i], isPair: true, isOdd: false, pairId: `pair-${i}` });
                allImages.push({ ...pairs[i], isPair: true, isOdd: false, pairId: `pair-${i}` });
            }

            // Add odd images (each appears once)
            for (let i = 0; i < oddCount; i++) {
                allImages.push({
                    ...oddImages[i],
                    isPair: false,
                    isOdd: true,
                    oddImageIndex: i  // Track which odd image this is
                });
            }

            // Shuffle the images
            allImages = allImages.sort(() => Math.random() - 0.5);

            return {
                allDistractors: allImages, // Use same structure as I spy mode
                finalHidden: [], // No hidden objects in odd one out mode
                uniqueHidden: [], // No unique hidden
                mode: 'oddoneout',
                oddImages: oddImages.slice(0, oddCount) // Store the actual odd images for answer key
            };
        }
        
        function getRandomSubset(array, count) {
            return [...array].sort(() => 0.5 - Math.random()).slice(0, count);
        }
        
        // Create default child-friendly background - with proper coordinate handling
        async function addDefaultBackground(canvas) {
            // Load Alphabet.png from Summer background theme
            return new Promise((resolve) => {
                fabric.Image.fromURL('/images/backgrounds/summer/Alphabet.png', (img) => {
                    if (!img) {
                        // Fallback to solid color if image fails to load
                        const background = new fabric.Rect({
                            left: 0,
                            top: 0,
                            width: currentCanvasConfig.width,
                            height: currentCanvasConfig.height,
                            fill: '#FFF5E6',
                            originX: 'left',
                            originY: 'top',
                            selectable: true,
                            evented: true,
                            hasControls: true,
                            hasBorders: true,
                            isBackground: true,
                            opacity: 0.35,
                            uniqueId: 'default-background'
                        });
                        canvas.add(background);
                        background.setCoords();
                        canvas.renderAll();
                        resolve();
                        return;
                    }

                    // Scale image to cover the entire canvas while maintaining aspect ratio
                    const scaleX = currentCanvasConfig.width / img.width;
                    const scaleY = currentCanvasConfig.height / img.height;
                    // Use the larger scale to ensure full coverage
                    const scale = Math.max(scaleX, scaleY);

                    // Center the image
                    const scaledWidth = img.width * scale;
                    const scaledHeight = img.height * scale;
                    const left = (currentCanvasConfig.width - scaledWidth) / 2;
                    const top = (currentCanvasConfig.height - scaledHeight) / 2;

                    img.set({
                        left: left,
                        top: top,
                        scaleX: scale,
                        scaleY: scale,
                        originX: 'left',
                        originY: 'top',
                        selectable: true,
                        evented: true,
                        hasControls: true,
                        hasBorders: true,
                        isBackground: true,
                        opacity: 0.35,
                        uniqueId: 'default-background'
                    });

                    canvas.add(img);
                    img.setCoords();
                    canvas.renderAll();
                    resolve();
                }, { crossOrigin: 'anonymous' });
            });
        }
        
        // Create simple, stable border - with proper coordinate handling
        async function addDefaultBorder(canvas) {
            // Calculate border position with half-inch margin (36 points = 0.5 inch)
            const margin = 36; // Half inch margin on all sides
            const strokeWidth = 3;
            const borderOffset = margin + (strokeWidth / 2);

            const border = new fabric.Rect({
                left: borderOffset,
                top: borderOffset,
                width: currentCanvasConfig.width - (2 * margin) - strokeWidth,
                height: currentCanvasConfig.height - (2 * margin) - strokeWidth,
                fill: 'transparent',
                stroke: '#4A90E2',
                strokeWidth: strokeWidth,
                strokeDashArray: [15, 8],
                rx: 20,
                ry: 20,
                originX: 'left',  // Use default origins
                originY: 'top',   // Avoid coordinate issues
                selectable: true,
                evented: true,
                hasControls: true,
                hasBorders: true,
                isBorder: true,
                opacity: 0.9,
                uniqueId: 'default-border'
            });

            canvas.add(border);
            border.setCoords();  // Update coordinates after adding

            // Add decorative corners with proper positioning (accounting for margin)
            const cornerSize = 20;
            const corners = [
                { x: margin + cornerSize, y: margin + cornerSize },
                { x: currentCanvasConfig.width - margin - cornerSize, y: margin + cornerSize },
                { x: margin + cornerSize, y: currentCanvasConfig.height - margin - cornerSize },
                { x: currentCanvasConfig.width - margin - cornerSize, y: currentCanvasConfig.height - margin - cornerSize }
            ];
            
            corners.forEach((pos, i) => {
                const star = new fabric.Polygon([
                    {x: 0, y: -15}, {x: 5, y: -5}, {x: 15, y: -3},
                    {x: 7, y: 5}, {x: 10, y: 15}, {x: 0, y: 10},
                    {x: -10, y: 15}, {x: -7, y: 5}, {x: -15, y: -3},
                    {x: -5, y: -5}
                ], {
                    left: pos.x,
                    top: pos.y,
                    fill: '#FFD700',
                    stroke: '#FFA500',
                    strokeWidth: 1,
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    evented: true,
                    hasControls: true,
                    lockRotation: false,
                    isDecoration: true,
                    uniqueId: `corner-star-${i}`
                });
                canvas.add(star);
                star.setCoords();  // Update star coordinates
            });
            
            canvas.renderAll();
        }


        // Specialized placement for odd one out mode with pair constraints
        async function placeOddOneOutImages(canvas, images, contentRect, baseSize, minSize, maxSize, isLandscape) {
            const placedObjects = [];
            let generatedItemCounter = 0;

            // Separate pairs and odd images
            // IMPORTANT: Create copies to avoid mutating cached theme objects
            const pairImages = images.filter(img => img.isPair).map(img => ({ ...img }));
            const oddImages = images.filter(img => img.isOdd).map(img => ({ ...img }));

            // Group pairs by pairId
            const pairGroups = {};
            pairImages.forEach(img => {
                if (!pairGroups[img.pairId]) {
                    pairGroups[img.pairId] = [];
                }
                pairGroups[img.pairId].push(img);
            });

            // Assign different sizes and angles to each member of a pair
            Object.keys(pairGroups).forEach(pairId => {
                const pairMembers = pairGroups[pairId];

                // Assign different sizes (one larger, one smaller)
                const size1 = minSize * (1.3 + Math.random() * 0.5); // 1.3x - 1.8x
                const size2 = minSize * (0.9 + Math.random() * 0.4); // 0.9x - 1.3x
                pairMembers[0].targetSize = Math.min(size1, maxSize);
                pairMembers[1].targetSize = Math.min(size2, maxSize);

                // Assign different angles (ensure at least 20 degrees difference)
                const angle1 = (Math.random() - 0.5) * 20; // -10 to +10
                const angle2 = angle1 + (20 + Math.random() * 20) * (Math.random() > 0.5 ? 1 : -1); // +/- 20-40 degrees different
                pairMembers[0].targetAngle = angle1;
                pairMembers[1].targetAngle = angle2;

                // Assign to different layers (one background, one foreground for separation)
                pairMembers[0].layerIndex = 0; // Background
                pairMembers[1].layerIndex = 2; // Foreground
            });

            // Assign sizes and angles to odd images
            oddImages.forEach(img => {
                const size = minSize * (1.1 + Math.random() * 0.6);
                img.targetSize = Math.min(size, maxSize);
                img.targetAngle = (Math.random() - 0.5) * 20;
                img.layerIndex = 1; // Middle layer
            });

            // Combine all images
            const allImagesWithProps = [...pairImages, ...oddImages];

            // Function to check if position is too close to pair member
            const isTooCloseToPartner = (img, x, y, imgWidth, imgHeight) => {
                if (!img.isPair) return false; // Odd images don't have partners

                const centerX = x + imgWidth / 2;
                const centerY = y + imgHeight / 2;

                // Find the partner (same pairId but different object)
                for (const existing of placedObjects) {
                    if (existing.pairId === img.pairId && existing !== img) {
                        // This is the partner - check distance
                        const partnerCenterX = existing.left;
                        const partnerCenterY = existing.top;

                        const dx = Math.abs(centerX - partnerCenterX);
                        const dy = Math.abs(centerY - partnerCenterY);

                        const partnerWidth = existing.getScaledWidth();
                        const partnerHeight = existing.getScaledHeight();

                        // Check if horizontally adjacent (same row, side by side)
                        // Horizontal adjacency: vertical distance small AND horizontal distance is about sum of half-widths
                        const horizontallyAdjacent = dy < Math.max(imgHeight, partnerHeight) * 0.6 &&
                                                     dx < (imgWidth + partnerWidth) / 2 + 100; // 100px minimum separation

                        // Check if vertically adjacent (same column, stacked)
                        // Vertical adjacency: horizontal distance small AND vertical distance is about sum of half-heights
                        const verticallyAdjacent = dx < Math.max(imgWidth, partnerWidth) * 0.6 &&
                                                   dy < (imgHeight + partnerHeight) / 2 + 100; // 100px minimum separation

                        if (horizontallyAdjacent || verticallyAdjacent) {
                            return true; // Too close to partner
                        }
                    }
                }

                return false; // Not too close
            };

            // Place items with constraints
            const placeItem = (itemInfo) => {
                return new Promise(resolve => {
                    fabric.Image.fromURL(itemInfo.path, (img) => {
                        if (!img) { resolve(); return; }

                        const uniqueId = `gen-item-${generatedItemCounter++}`;
                        img.scaleToWidth(itemInfo.targetSize);

                        const imgWidth = img.getScaledWidth();
                        const imgHeight = img.getScaledHeight();

                        // Find position with MINIMAL overlap (prefer zero, but track best option)
                        let bestPosition = null;
                        let bestOverlapPenalty = Infinity;

                        // Try up to 300 positions for pairs, 200 for odd images
                        const maxAttempts = itemInfo.isPair ? 300 : 200;

                        for (let attempt = 0; attempt < maxAttempts; attempt++) {
                            const x = contentRect.x + Math.random() * Math.max(1, contentRect.width - imgWidth);
                            const y = contentRect.y + Math.random() * Math.max(1, contentRect.height - imgHeight);

                            const centerX = x + imgWidth / 2;
                            const centerY = y + imgHeight / 2;

                            // Check pair adjacency constraint
                            if (isTooCloseToPartner(itemInfo, x, y, imgWidth, imgHeight)) {
                                continue; // Skip this position - too close to partner
                            }

                            // Calculate overlap penalty for this position
                            let overlapPenalty = 0;

                            for (const existing of placedObjects) {
                                const dx = centerX - existing.left;
                                const dy = centerY - existing.top;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                // Minimum distance with buffer to ensure no visual overlap
                                const minDistance = (imgWidth + existing.getScaledWidth()) / 2 + 30;

                                if (distance < minDistance) {
                                    // Calculate how much they overlap
                                    const overlap = minDistance - distance;
                                    overlapPenalty += overlap;
                                }
                            }

                            // Track the best position (lowest overlap)
                            if (overlapPenalty < bestOverlapPenalty) {
                                bestOverlapPenalty = overlapPenalty;
                                bestPosition = { x: centerX, y: centerY };

                                // If we found zero overlap, use it immediately
                                if (overlapPenalty === 0) {
                                    break;
                                }
                            }
                        }

                        // If no good position found, try with slightly smaller image
                        if (bestOverlapPenalty > 100) {
                            // Reduce size by 10% and try again
                            img.scaleToWidth(itemInfo.targetSize * 0.9);
                            const reducedWidth = img.getScaledWidth();
                            const reducedHeight = img.getScaledHeight();

                            let reducedBestPosition = null;
                            let reducedBestPenalty = Infinity;

                            for (let attempt = 0; attempt < 100; attempt++) {
                                const x = contentRect.x + Math.random() * Math.max(1, contentRect.width - reducedWidth);
                                const y = contentRect.y + Math.random() * Math.max(1, contentRect.height - reducedHeight);

                                const centerX = x + reducedWidth / 2;
                                const centerY = y + reducedHeight / 2;

                                if (isTooCloseToPartner(itemInfo, x, y, reducedWidth, reducedHeight)) {
                                    continue;
                                }

                                let overlapPenalty = 0;
                                for (const existing of placedObjects) {
                                    const dx = centerX - existing.left;
                                    const dy = centerY - existing.top;
                                    const distance = Math.sqrt(dx * dx + dy * dy);
                                    const minDistance = (reducedWidth + existing.getScaledWidth()) / 2 + 30;

                                    if (distance < minDistance) {
                                        const overlap = minDistance - distance;
                                        overlapPenalty += overlap;
                                    }
                                }

                                if (overlapPenalty < reducedBestPenalty) {
                                    reducedBestPenalty = overlapPenalty;
                                    reducedBestPosition = { x: centerX, y: centerY };

                                    if (overlapPenalty === 0) break;
                                }
                            }

                            // Use reduced size position if it's better
                            if (reducedBestPenalty < bestOverlapPenalty) {
                                bestPosition = reducedBestPosition;
                                bestOverlapPenalty = reducedBestPenalty;
                            } else {
                                // Restore original size if reduced didn't help
                                img.scaleToWidth(itemInfo.targetSize);
                            }
                        }

                        // Use the best position found (guaranteed to have minimal overlap)
                        const finalPosition = bestPosition || {
                            x: contentRect.x + contentRect.width / 2,
                            y: contentRect.y + contentRect.height / 2
                        };

                        img.set({
                            left: finalPosition.x,
                            top: finalPosition.y,
                            angle: itemInfo.targetAngle,
                            originX: 'center',
                            originY: 'center',
                            selectable: true,
                            evented: true,
                            hasControls: true,
                            hasBorders: true,
                            isGenerated: true,
                            isHidden: itemInfo.isHidden || false,
                            isOddImage: itemInfo.isOdd || false,
                            pairId: itemInfo.pairId || null, // Store pairId for partner tracking
                            uniqueId: uniqueId
                        });

                        // Layer ordering
                        canvas.add(img);
                        if (itemInfo.layerIndex === 0) {
                            canvas.sendBackwards(img);
                        } else if (itemInfo.layerIndex === 2) {
                            canvas.bringForward(img);
                        }

                        placedObjects.push(img);
                        resolve();
                    }, { crossOrigin: 'anonymous' });
                });
            };

            // Place items layer by layer to maintain proper z-ordering
            // Layer 0: First members of pairs (background)
            const layer0Items = allImagesWithProps.filter(img => img.layerIndex === 0);
            for (const item of layer0Items) {
                await placeItem(item);
            }

            // Layer 1: Odd images (middle)
            const layer1Items = allImagesWithProps.filter(img => img.layerIndex === 1);
            for (const item of layer1Items) {
                await placeItem(item);
            }

            // Layer 2: Second members of pairs (foreground)
            const layer2Items = allImagesWithProps.filter(img => img.layerIndex === 2);
            for (const item of layer2Items) {
                await placeItem(item);
            }

            return placedObjects;
        }
        async function generateScene(canvas, { allDistractors, finalHidden, uniqueHidden }) {
            // Canvas size change detection
            const canvasSizeChanged = lastCanvasSize.width !== currentCanvasConfig.width ||
                                     lastCanvasSize.height !== currentCanvasConfig.height;

            const oldTransforms = {};
            // Don't preserve transforms if we just restored from history (undo/redo)
            if (!justRestoredFromHistory) {
                canvas.getObjects().forEach(obj => {
                    if (obj.isGenerated || obj.isBorder || obj.isBackground || obj.isDecoration || obj.isPageBorder || obj.isHeaderElement) {
                        // Only restore transforms if canvas size hasn't changed
                        // IMPORTANT: Don't save scaleX/scaleY for generated images - they get new sizes each generation
                        if (!canvasSizeChanged) {
                            oldTransforms[obj.uniqueId] = {
                                left: obj.left, top: obj.top, angle: obj.angle
                                // scaleX and scaleY deliberately excluded for isGenerated objects
                            };
                        }
                    }
                });
            }
            // Clear the flag after checking
            justRestoredFromHistory = false;

            const userAddedObjects = canvas.getObjects().filter(o => !o.isGenerated && !o.isBorder && !o.isBackground && !o.isDecoration && !o.isPageBorder && !o.isHeaderElement && !o.isHeaderDesc);

            const oldGeneratedItems = canvas.getObjects().filter(o => o.isGenerated || o.isPageBorder || o.isHeaderElement || o.isHeaderDesc);

            oldGeneratedItems.forEach(o => canvas.remove(o));

            // Use actual canvas dimensions from currentCanvasConfig
            const canvasWidth = currentCanvasConfig.width;
            const canvasHeight = currentCanvasConfig.height;
            const isLandscape = canvasWidth > canvasHeight;

            // Update last canvas size
            lastCanvasSize = { width: canvasWidth, height: canvasHeight };

            // Add responsive header and border
            const headerObjects = createHeaderGroup(canvas);
            if (headerObjects && headerObjects.length > 0) {
                headerObjects.forEach(obj => {
                    canvas.add(obj);
                    if (obj.isPageBorder) {
                        canvas.sendToBack(obj);
                    }
                });
            }

            // Add default child-friendly decorations if enabled and none exist
            const useDefaultDecorations = document.getElementById('useDefaultDecorations');
            if (useDefaultDecorations && useDefaultDecorations.checked) {
                // Only add if they don't already exist
                if (!canvas.getObjects().find(o => o.isBackground)) {
                    await addDefaultBackground(canvas);
                }

                // Don't add default border if we have header borders
                if (!canvas.getObjects().find(o => o.isBorder || o.isPageBorder)) {
                    await addDefaultBorder(canvas);
                }

                // Enforce z-order after adding decorations
                enforceZOrder(canvas);
            }

            // Professional margins - account for header height
            const headerHeight = isLandscape ? 145 : 220;
            const topMargin = headerHeight + (includeNameDate.checked ? 20 : 10);
            const bottomMargin = 120; // Space for legend
            const sideMargin = isLandscape ? 60 : 50;
            
            // Content area with proper boundaries
            const contentRect = {
                x: sideMargin,
                y: topMargin,
                width: canvasWidth - (sideMargin * 2),
                height: canvasHeight - topMargin - bottomMargin
            };
            
            const placedObjects = [];
            
            // Natural scattered layout with better spacing
            const totalItems = allDistractors.length + finalHidden.length;
            const minDimension = Math.min(contentRect.width, contentRect.height);

            // Reduced density - fewer items per area
            const avgItemsPerRow = isLandscape ? 5 : 4;
            const avgItemsPerCol = isLandscape ? 4 : 5;
            const baseSize = minDimension / Math.max(avgItemsPerRow, avgItemsPerCol);

            // Create layers for natural depth
            const layers = {
                background: [],  // Large distractors
                middle: [],      // Hidden objects and medium items
                foreground: []   // Small distractors for fill
            };

            // More controlled size variation - prevent huge objects
            // I spy mode uses original sizes
            const minSize = baseSize * 0.7;  // Minimum size
            const relativeMaxSize = minSize * 2.5;   // Maximum size (2.5x ratio instead of 4x)
            const absoluteMaxSize = isLandscape ? 180 : 150; // Absolute maximum to prevent huge images
            const maxSize = Math.min(relativeMaxSize, absoluteMaxSize); // Use the smaller of the two

            allDistractors.forEach((item, index) => {
                if (index < allDistractors.length * 0.3) {
                    // 30% large background items (1.8x to 2.5x of minimum)
                    const size = minSize * (1.8 + Math.random() * 0.7);
                    layers.background.push({ ...item, targetSize: Math.min(size, maxSize), isHidden: false });
                } else if (index < allDistractors.length * 0.7) {
                    // 40% medium items (1.2x to 1.8x of minimum)
                    const size = minSize * (1.2 + Math.random() * 0.6);
                    layers.middle.push({ ...item, targetSize: Math.min(size, maxSize), isHidden: false });
                } else {
                    // 30% small fill items (0.9x to 1.3x of minimum)
                    const size = minSize * (0.9 + Math.random() * 0.4);
                    layers.foreground.push({ ...item, targetSize: Math.min(Math.max(size, minSize * 0.9), maxSize), isHidden: false });
                }
            });

            // Hidden objects in middle layer with medium sizes
            finalHidden.forEach(item => {
                const size = minSize * (1.3 + Math.random() * 0.5);
                layers.middle.push({ ...item, targetSize: Math.min(size, maxSize), isHidden: true });
            });



            // Assign different angles to duplicate images (same path) - like Odd One Out pairs
            const allLayerItems = [...layers.background, ...layers.middle, ...layers.foreground];
            const imageGroups = {};

            // Group images by path
            allLayerItems.forEach(item => {
                if (!imageGroups[item.path]) {
                    imageGroups[item.path] = [];
                }
                imageGroups[item.path].push(item);
            });

            // Assign different angles to same images (like Odd One Out does for pairs)
            Object.keys(imageGroups).forEach(path => {
                const group = imageGroups[path];
                if (group.length > 1) {
                    // Multiple instances - assign angles that differ by 20-40 degrees
                    group.forEach((item, index) => {
                        if (index === 0) {
                            // First instance: random base angle
                            item.targetAngle = (Math.random() - 0.5) * 20; // -10 to +10
                        } else {
                            // Subsequent instances: differ by 20-40 degrees from previous
                            const prevAngle = group[index - 1].targetAngle;
                            const angleDiff = 20 + Math.random() * 20; // 20-40 degrees
                            const direction = Math.random() > 0.5 ? 1 : -1;
                            item.targetAngle = prevAngle + (angleDiff * direction);
                        }
                    });
                } else {
                    // Single instance - random angle
                    group[0].targetAngle = (Math.random() - 0.5) * 20;
                }
            });

            // Shuffle each layer
            Object.keys(layers).forEach(key => {
                layers[key].sort(() => Math.random() - 0.5);
            });

            let generatedItemCounter = 0;

            // Check if this is odd one out mode
            const isOddOneOutMode = allDistractors.length > 0 && allDistractors[0].isPair !== undefined;

            if (isOddOneOutMode) {

                // Odd one out mode uses LARGER sizes (50% bigger than I spy)
                const oddMinSize = baseSize * 1.05;  // 50% larger minimum
                const oddRelativeMaxSize = oddMinSize * 2.5;
                const oddAbsoluteMaxSize = isLandscape ? 270 : 225; // 50% larger maximum
                const oddMaxSize = Math.min(oddRelativeMaxSize, oddAbsoluteMaxSize);

                // Use specialized placement for odd one out with pair constraints
                const placedOddOneOutObjects = await placeOddOneOutImages(
                    canvas,
                    allDistractors,
                    contentRect,
                    baseSize,
                    oddMinSize,  // Use larger minimum
                    oddMaxSize,  // Use larger maximum
                    isLandscape
                );
                // Skip to legend creation - placement done
            } else {

            // Normal I Spy placement

            // Check if position is too close to same image (horizontally or vertically adjacent)
            const isTooCloseToSameImage = (itemInfo, x, y, imgWidth, imgHeight, placedObjects) => {
                const centerX = x + imgWidth / 2;
                const centerY = y + imgHeight / 2;

                for (const existing of placedObjects) {
                    // Check if this is the same image (same path)
                    if (existing.imagePath === itemInfo.path) {
                        const existingCenterX = existing.left;
                        const existingCenterY = existing.top;

                        const dx = Math.abs(centerX - existingCenterX);
                        const dy = Math.abs(centerY - existingCenterY);

                        const existingWidth = existing.getScaledWidth();
                        const existingHeight = existing.getScaledHeight();

                        // Check horizontal adjacency (same row, side by side)
                        const horizontallyAdjacent = dy < Math.max(imgHeight, existingHeight) * 0.6 &&
                                                     dx < (imgWidth + existingWidth) / 2 + 100; // 100px separation

                        // Check vertical adjacency (same column, stacked)
                        const verticallyAdjacent = dx < Math.max(imgWidth, existingWidth) * 0.6 &&
                                                   dy < (imgHeight + existingHeight) / 2 + 100; // 100px separation

                        if (horizontallyAdjacent || verticallyAdjacent) {
                            return true; // Too close - reject position
                        }
                    }
                }

                return false; // OK to place
            };

            // Natural scattered placement with improved spacing
            const placeItem = (itemInfo, layerIndex) => {
                return new Promise(resolve => {
                    fabric.Image.fromURL(itemInfo.path, (img) => {
                        if (!img) { resolve(); return; }

                        const uniqueId = `gen-item-${generatedItemCounter++}`;
                        img.scaleToWidth(itemInfo.targetSize);

                        const imgWidth = img.getScaledWidth();
                        const imgHeight = img.getScaledHeight();

                        // Find best position with minimal overlap
                        let bestPosition = null;
                        let bestOverlap = Infinity;

                        // Try 80 positions to find one with least overlap
                        for (let attempt = 0; attempt < 80; attempt++) {
                            const x = contentRect.x + Math.random() * Math.max(1, contentRect.width - imgWidth);
                            const y = contentRect.y + Math.random() * Math.max(1, contentRect.height - imgHeight);

                            const centerX = x + imgWidth / 2;
                            const centerY = y + imgHeight / 2;

                            // Check same-image adjacency constraint (like Odd One Out pairs)
                            if (isTooCloseToSameImage(itemInfo, x, y, imgWidth, imgHeight, placedObjects)) {
                                continue; // Skip this position - too close to same image
                            }

                            // Calculate total overlap penalty for this position
                            let overlapPenalty = 0;

                            for (const existing of placedObjects) {
                                const dx = centerX - existing.left;
                                const dy = centerY - existing.top;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                // Minimum desired distance between centers (with extra spacing)
                                let minDistance = (imgWidth + existing.getScaledWidth()) / 2 + 25; // 25px buffer



                                if (distance < minDistance) {
                                    // Objects are overlapping - add penalty based on how much
                                    const overlapAmount = minDistance - distance;
                                    overlapPenalty += overlapAmount;
                                }
                            }

                            // Track best position (least overlap)
                            if (overlapPenalty < bestOverlap) {
                                bestOverlap = overlapPenalty;
                                bestPosition = { x: centerX, y: centerY };

                                // If we found a position with no overlap, use it immediately
                                if (overlapPenalty === 0) break;
                            }
                        }

                        // Use best position found (or random if none found)
                        const finalPosition = bestPosition || {
                            x: contentRect.x + Math.random() * Math.max(1, contentRect.width - imgWidth) + imgWidth / 2,
                            y: contentRect.y + Math.random() * Math.max(1, contentRect.height - imgHeight) + imgHeight / 2
                        };

                        // Use assigned angle (different for same images)
                        const rotation = itemInfo.targetAngle || (Math.random() - 0.5) * 20; // Use assigned angle (different for same images)

                        img.set({
                            left: finalPosition.x,
                            top: finalPosition.y,
                            angle: rotation,
                            originX: 'center',
                            originY: 'center',
                            selectable: true,
                            evented: true,
                            hasControls: true,
                            hasBorders: true,
                            isGenerated: true,
                            isHidden: itemInfo.isHidden,
                            imagePath: itemInfo.path,  // Store for same-image adjacency checking
                            isOddImage: itemInfo.isOdd || false,  // Mark if this is an odd image
                            uniqueId: uniqueId
                        });

                        if(oldTransforms[uniqueId]) img.set(oldTransforms[uniqueId]);

                        // Layer ordering - background items go to back
                        canvas.add(img);
                        if (layerIndex === 0) {
                            canvas.sendBackwards(img);
                        } else if (layerIndex === 2) {
                            canvas.bringForward(img);
                        }

                        placedObjects.push(img);
                        resolve();
                    }, { crossOrigin: 'anonymous' });
                });
            };
            
            // Place items layer by layer
            // 1. Place large background items first
            for (const item of layers.background) {
                await placeItem(item, 0);
            }
            
            // 2. Place middle layer (hidden objects and medium items)
            for (const item of layers.middle) {
                await placeItem(item, 1);
            }
            
            // 3. Place small foreground items to fill gaps
            for (const item of layers.foreground) {
                await placeItem(item, 2);
            }
            } // End else - normal I Spy placement

            const layoutData = { uniqueHidden, finalHidden };
            // Skip legend for odd one out mode
            const isOddOneOut = activityModeSelect.value === 'oddoneout';
            const legendGroup = isOddOneOut ? null : await createLegendGroup(false, layoutData);
            if (legendGroup) {
                const uniqueId = 'worksheet-legend';
                // Position legend so its bottom aligns with the bottom of the border
                // Border bottom is at: canvasHeight - 36 (half-inch margin)
                const borderMargin = 36; // Half inch margin
                const legendHeight = legendGroup.getScaledHeight();
                const legendTop = canvasHeight - borderMargin - legendHeight / 2;

                legendGroup.set({
                    left: canvasWidth / 2,
                    top: legendTop,
                    originX: 'center',
                    originY: 'center',
                    isGenerated: true,
                    isLegend: true,
                    uniqueId: uniqueId
                });
                if(oldTransforms[uniqueId]) legendGroup.set(oldTransforms[uniqueId]);
                canvas.add(legendGroup);
            }
            
            if (includeNameDate.checked) {
                const uniqueId = 'name-date-field';
                const nameDateGroup = new fabric.Group([
                    new fabric.Textbox(t("findobjects.name.field"), { 
                        fontSize: 18, 
                        fontFamily: 'Fredoka', 
                        left: 0, 
                        top: 0 
                    }),
                    new fabric.Textbox(t("findobjects.date.field"), { 
                        fontSize: 18, 
                        fontFamily: 'Fredoka', 
                        left: 300, 
                        top: 0 
                    })
                ], { 
                    left: sideMargin, 
                    top: 30, 
                    isGenerated: true, 
                    isNameDate: true, 
                    selectable: true, 
                    evented: true, 
                    uniqueId: uniqueId 
                });
                if(oldTransforms[uniqueId]) nameDateGroup.set(oldTransforms[uniqueId]);
                canvas.add(nameDateGroup);
            }
            
            enforceZOrder(canvas);
            userAddedObjects.forEach(obj => canvas.bringToFront(obj));
            canvas.renderAll();
            return layoutData;
        }

        function enforceZOrder(canvas) {
            if (!canvas) return;

            // REMOVED: Automatic z-order enforcement for backgrounds and borders
            // Users should have full control over these elements via layer controls

            // Update coordinates for all objects (for proper interaction)
            canvas.getObjects().forEach(obj => {
                obj.setCoords();
            });
        }

        function createImagePromise(url, options) {
            return new Promise((resolve) => {
                fabric.Image.fromURL(url, (img) => {
                    if (img) {
                        if (options.targetWidth)  img.scaleToWidth(options.targetWidth);
                        else if (options.targetHeight) img.scaleToHeight(options.targetHeight);
                        img.set({ ...options, selectable: true, hasControls: true});
                        resolve(img);
                    } else {
                        console.error(`Failed to load image: ${url}`);
                        resolve(null);
                    }
                }, { crossOrigin: 'anonymous' });
            });
        }

        // --- HEADER & BORDER FUNCTIONS ---
        function createHeaderGroup(canvas) {
            // Get activity mode
            const isOddOneOut = activityModeSelect.value === 'oddoneout';

            const defaultHeaders = isOddOneOut ? {
                en: { title: 'Find the Odd One Out', description: 'Find the images that don\'t have a matching pair!' },
                de: { title: 'Finde das Unpassende', description: 'Finde die Bilder, die kein passendes Paar haben!' },
                fr: { title: 'Trouve l\'Intrus', description: 'Trouve les images qui n\'ont pas de paire!' },
                es: { title: 'Encuentra el Diferente', description: '¡Encuentra las imágenes que no tienen pareja!' },
                it: { title: 'Trova il Diverso', description: 'Trova le immagini che non hanno una coppia!' },
                pt: { title: 'Encontra o Diferente', description: 'Encontra as imagens que não têm par!' },
                nl: { title: 'Vind de Vreemde Eend', description: 'Vind de plaatjes zonder match!' },
                sv: { title: 'Hitta den Udda', description: 'Hitta bilderna som inte har en match!' },
                da: { title: 'Find den Ulige', description: 'Find billederne uden match!' },
                no: { title: 'Finn den Merkelige', description: 'Finn bildene uten match!' },
                fi: { title: 'Löydä Outo', description: 'Löydä kuvat ilman paria!' }
            } : {
                en: { title: 'Find the Hidden Objects', description: 'Look carefully and find all the hidden pictures!' },
                de: { title: 'Finde die versteckten Objekte', description: 'Schau genau hin und finde alle versteckten Bilder!' },
                fr: { title: 'Trouve les Objets Cachés', description: 'Regarde bien et trouve toutes les images cachées!' },
                es: { title: 'Encuentra los Objetos Ocultos', description: '¡Mira con atención y encuentra todas las imágenes!' },
                it: { title: 'Trova gli Oggetti Nascosti', description: 'Guarda bene e trova tutte le immagini nascoste!' },
                pt: { title: 'Encontra os Objetos Escondidos', description: 'Olha bem e encontra todas as imagens escondidas!' },
                nl: { title: 'Vind de Verborgen Voorwerpen', description: 'Kijk goed en vind alle verborgen plaatjes!' },
                sv: { title: 'Hitta de Gömda Objekten', description: 'Titta noga och hitta alla gömda bilder!' },
                da: { title: 'Find de Skjulte Objekter', description: 'Kig nøje og find alle de skjulte billeder!' },
                no: { title: 'Finn de Skjulte Objektene', description: 'Se nøye og finn alle de skjulte bildene!' },
                fi: { title: 'Löydä Piilotetut Esineet', description: 'Katso tarkkaan ja löydä kaikki piilotetut kuvat!' }
            };

            const locale = currentLocale || 'en';
            const defaults = defaultHeaders[locale] || defaultHeaders.en;
            const title = defaults.title;
            const description = defaults.description;

            // Get current canvas dimensions for responsive design
            const pageWidth = currentCanvasConfig.width;
            const pageHeight = currentCanvasConfig.height;
            const isLandscape = pageWidth > pageHeight;

            const objects = [];

            // Responsive borders - Bright teal (discovery, exploration, search)
            const margin = 34;
            const strokeWidth = 8;
            const borderWidth = pageWidth - (margin * 2);
            const borderHeight = pageHeight - (margin * 2);

            const outerBorder = new fabric.Rect({
                left: margin,
                top: margin,
                width: borderWidth,
                height: borderHeight,
                fill: 'transparent',
                stroke: '#14B8A6',
                strokeWidth: strokeWidth,
                rx: 12,
                ry: 12,
                selectable: true,
                hasControls: true,
                isPageBorder: true
            });
            objects.push(outerBorder);

            // LANDSCAPE MODE: Compact, centered header (145px total height)
            if (isLandscape) {
                const maxHeaderWidth = Math.min(500, pageWidth * 0.6);
                const headerHeight = 70;
                const centerX = pageWidth / 2;
                const headerTop = 60;

                // Teal background - compact
                const bgRect = new fabric.Rect({
                    left: centerX - maxHeaderWidth / 2,
                    top: headerTop,
                    width: maxHeaderWidth,
                    height: headerHeight,
                    fill: '#14B8A6',
                    rx: 35,
                    ry: 35,
                    selectable: true,
                    isHeaderElement: true
                });
                objects.push(bgRect);

                // White pill for title - compact
                const whitePill = new fabric.Rect({
                    left: centerX - (maxHeaderWidth - 40) / 2,
                    top: headerTop + 10,
                    width: maxHeaderWidth - 40,
                    height: 50,
                    fill: '#FFFFFF',
                    rx: 25,
                    ry: 25,
                    selectable: true,
                    isHeaderElement: true
                });
                objects.push(whitePill);

                // Title - Compact size for landscape
                let titleFontSize = 32;
                if (title.length > 12) titleFontSize = 28;
                if (title.length > 15) titleFontSize = 24;
                if (title.length > 18) titleFontSize = 20;
                if (title.length > 22) titleFontSize = 18;

                const titleText = new fabric.IText(title, {
                    left: centerX,
                    top: headerTop + 35,
                    fontSize: titleFontSize,
                    fontFamily: 'Fredoka, sans-serif',
                    fontWeight: '700',
                    fill: '#0F766E',
                    textAlign: 'center',
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    editable: true,
                    isHeaderElement: true
                });
                objects.push(titleText);

                // Description - compact
                const descText = new fabric.Textbox(description, {
                    left: centerX,
                    top: headerTop + headerHeight + 5,
                    width: maxHeaderWidth - 20,
                    fontSize: 14,
                    fontFamily: 'Quicksand, sans-serif',
                    fontWeight: '500',
                    fill: '#4A4A4A',
                    textAlign: 'center',
                    originX: 'center',
                    originY: 'top',
                    selectable: true,
                    editable: true,
                    hasControls: true,
                    isHeaderDesc: true
                });
                objects.push(descText);

            } else {
                // PORTRAIT MODE: Full-width professional header (220px total height)
                const headerMargin = 70;
                const headerWidth = pageWidth - (headerMargin * 2);
                const centerX = pageWidth / 2;

                // Header background - Bright teal (discovery, search)
                const bgRect = new fabric.Rect({
                    left: headerMargin,
                    top: 70,
                    width: headerWidth,
                    height: 100,
                    fill: '#14B8A6',
                    rx: 15,
                    ry: 15,
                    selectable: true,
                    isHeaderElement: true
                });
                objects.push(bgRect);

                // White pill for title
                const whitePill = new fabric.Rect({
                    left: headerMargin + 20,
                    top: 85,
                    width: headerWidth - 40,
                    height: 70,
                    fill: '#FFFFFF',
                    rx: 35,
                    ry: 35,
                    selectable: true,
                    isHeaderElement: true
                });
                objects.push(whitePill);

                // Title - Dynamic size based on length
                let titleFontSize = 48;
                if (title.length > 12) titleFontSize = 40;
                if (title.length > 15) titleFontSize = 36;
                if (title.length > 18) titleFontSize = 32;
                if (title.length > 22) titleFontSize = 28;

                // Title text - Deep teal (focus, attention)
                const titleText = new fabric.IText(title, {
                    left: centerX,
                    top: 120,
                    fontSize: titleFontSize,
                    fontFamily: 'Fredoka, sans-serif',
                    fontWeight: '700',
                    fill: '#0F766E',
                    textAlign: 'center',
                    originX: 'center',
                    originY: 'center',
                    selectable: true,
                    editable: true,
                    isHeaderElement: true
                });
                objects.push(titleText);

                // Description text - Dark gray (readable)
                const descText = new fabric.Textbox(description, {
                    left: centerX,
                    top: 190,
                    width: Math.min(450, pageWidth - 150),
                    fontSize: 20,
                    fontFamily: 'Quicksand, sans-serif',
                    fontWeight: '500',
                    fill: '#4A4A4A',
                    textAlign: 'center',
                    originX: 'center',
                    originY: 'top',
                    selectable: true,
                    editable: true,
                    hasControls: true,
                    isHeaderDesc: true
                });
                objects.push(descText);
            }

            return objects;
        }

        async function createLegendGroup(isAnswerKey, layoutData) {
            if (!layoutData || !layoutData.uniqueHidden || layoutData.uniqueHidden.length === 0) return null;
            
            const { uniqueHidden, finalHidden } = layoutData;
            const legendElements = [];
            
            const legendItemsPromises = uniqueHidden.map(async (item) => {
                const count = finalHidden.filter(h => h.path === item.path).length;
                if (count === 0) return null;

                const itemGroupElements = [];
                const img = await createImagePromise(item.path, { targetHeight: 40 });
                itemGroupElements.push(img);
                
                const box = new fabric.Rect({
                    top: img.getScaledHeight() + 5, 
                    left: (img.getScaledWidth() - 50) / 2,
                    width: 50, 
                    height: 25, 
                    fill: 'transparent',
                    stroke: '#333', 
                    strokeWidth: 2
                });
                itemGroupElements.push(box);
                
                if(isAnswerKey) {
                    const countText = new fabric.Text(String(count), {
                        top: box.top + box.height/2, 
                        left: box.left + box.width/2,
                        originX: 'center', 
                        originY: 'center', 
                        fontSize: 18,
                        fontWeight: 'normal',
                        fill: '#333'
                    });
                    itemGroupElements.push(countText);
                }
                
                return new fabric.Group(itemGroupElements, {});
            });

            const legendItems = (await Promise.all(legendItemsPromises)).filter(i => i);
            if(legendItems.length === 0) return null;
            
            // Arrange items horizontally
            let currentX = 0;
            legendItems.forEach((item, index) => {
                item.set({ left: currentX, top: 0 });
                currentX += item.getScaledWidth() + 20;
            });
            
            return new fabric.Group(legendItems, {
                objectCaching: false, 
                selectable: true, 
                hasControls: true
            });
        }

        function clearAll() {
            distractorThemeSelect.value = '';
            hiddenObjectThemeSelect.value = '';
            selectedDistractors = [];
            selectedHidden = [];
            uploadedImages = [];
            lastGeneratedLayout = null;
            
            borderThemeSelect.value = "none";
            borderDictionary.innerHTML = '<p class="dictionary-message">Select a theme to see borders.</p>';
            borderOpacitySlider.value = 1;
            borderOpacitySlider.disabled = true;
            backgroundThemeSelect.value = "none";
            backgroundDictionary.innerHTML = '<p class="dictionary-message">Select a theme for backgrounds.</p>';
            backgroundOpacitySlider.value = 1;
            backgroundOpacitySlider.disabled = true;

            if (worksheetCanvas) {
                // Remove only generated objects, keep user customizations
                const objectsToRemove = worksheetCanvas.getObjects().filter(o => 
                    o.isGenerated || o.isBorder || o.isBackground
                );
                objectsToRemove.forEach(obj => worksheetCanvas.remove(obj));
                worksheetCanvas.backgroundColor = '#FFFFFF';
                worksheetCanvas.renderAll();
            }
            if (answerKeyCanvas) {
                const objectsToRemove = answerKeyCanvas.getObjects().filter(o => 
                    o.isGenerated || o.isBorder || o.isBackground
                );
                objectsToRemove.forEach(obj => answerKeyCanvas.remove(obj));
                answerKeyCanvas.backgroundColor = '#FFFFFF';
                answerKeyCanvas.renderAll();
            }
            
            updateSelectedPanels();
            renderUploadedImages();
            generateDropdownBtn.disabled = true;
            generateAnswerKeyBtn.disabled = true;
            downloadDropdownBtn.disabled = true;
            downloadWorksheetJpegBtn.disabled = true;
            downloadAnswerKeyJpegBtn.disabled = true;
            downloadWorksheetPdfBtn.disabled = true;
            downloadAnswerKeyPdfBtn.disabled = true;
            showMessage(t('findobjects.msg.cleared'), 'success');
        }


// Translation function (uses uiLocale for UI translations)
function t(key, params = {}) {
    if (typeof translations === 'undefined') return key;
    const locale = window.uiLocale || 'en';  // Use uiLocale for UI translations
    const translation = (translations[locale] && translations[locale][key]) ||
                       (translations.en && translations.en[key]) ||
                       key;
    return formatTranslation(translation, params);
}
window.t = t;

function formatTranslation(text, params) {
    let formatted = text;
    for (const [key, value] of Object.entries(params)) {
        formatted = formatted.replace(new RegExp(`\{${key}\}`, 'g'), value);
    }
    return formatted;
}
window.formatTranslation = formatTranslation;

function showMessage(msg, type = 'info', duration = 3000) {
            messageDiv.textContent = msg;
            messageDiv.className = `message ${type}`;
            messageDiv.style.display = 'block';
            if (duration > 0) {
                setTimeout(() => { messageDiv.style.display = 'none'; }, duration);
            }
        }

        async function loadAssetThemes(type, selectEl) {
            try {
                selectEl.innerHTML = `<option value="none" data-translate="none">${t('none')}</option>`;
                const response = await fetch(`/api/${type}/themes?locale=${currentLocale}`);
                if (!response.ok) {
                    console.error(`Failed to load ${type} themes`);
                    return;
                }
                const themes = await response.json();
                themes.forEach(theme => {
                    // Handle both object format {value, displayName} and string format
                    const value = theme.value || theme;
                    const displayName = theme.displayName || (typeof theme === 'string' ? theme.charAt(0).toUpperCase() + theme.slice(1) : value);
                    selectEl.innerHTML += `<option value="${value}">${displayName}</option>`;
                });
            } catch (error) {
                console.error(`Error loading ${type} themes:`, error);
            }
        }
        
        function loadAssetImages(type, theme, dictionaryEl, addFunc) {
            const assetType = type.slice(0, -1); 
            const propName = `is${assetType.charAt(0).toUpperCase() + assetType.slice(1)}`;

            if (theme === 'none') {
                dictionaryEl.innerHTML = `<p class="dictionary-message">Select a theme to see ${type}.</p>`;
                const activeCanvas = getActiveCanvas();
                const existingAsset = activeCanvas.getObjects().find(obj => obj[propName]);
                if (existingAsset) activeCanvas.remove(existingAsset).renderAll();
                dictionaryEl.querySelectorAll('.thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
                 if (type === 'backgrounds') {
                    backgroundOpacitySlider.value = 1;
                    backgroundOpacitySlider.disabled = true;
                }
                if (type === 'borders') { 
                    borderOpacitySlider.value = 1;
                    borderOpacitySlider.disabled = true;
                }
                return;
            }
            dictionaryEl.innerHTML = `<p class="dictionary-message">Loading ${theme} ${type}...</p>`;
            // Use filesystem endpoints only
            const apiUrl = `/api/${type}/images?theme=${theme}&locale=${currentLocale}`;
            fetch(apiUrl)
                .then(res => { if (!res.ok) throw new Error(`Failed to load images for ${type} theme`); return res.json(); })
                .then(data => {
                    const images = data.images || data;
                    dictionaryEl.innerHTML = "";
                    if (images.length === 0) { dictionaryEl.innerHTML = `<p class="dictionary-message">No ${type} in this theme.</p>`; return; }
                    images.forEach(asset => {
                        const item = document.createElement("div"); item.className = "thumbnail-item";
                        item.innerHTML = `<img src="${asset.path}" alt="${asset.name}" loading="lazy" />`;
                        item.onclick = () => {
                            addFunc(asset.path);
                             dictionaryEl.querySelectorAll('.thumbnail-item.selected').forEach(el => el.classList.remove('selected'));
                            item.classList.add('selected');
                        };
                        dictionaryEl.appendChild(item);
                    });
                })
                .catch(err => { console.error(`Error loading ${type} images:`, err); dictionaryEl.innerHTML = `<p class="dictionary-message">Error loading ${type}.</p>`; });
        }

        function loadBorderThemes() { loadAssetThemes('borders', borderThemeSelect); }
        function loadBackgroundThemes() { loadAssetThemes('backgrounds', backgroundThemeSelect); }

        function loadBorderImages() { loadAssetImages('borders', borderThemeSelect.value, borderDictionary, addBorderToCanvas); }
        function loadBackgroundImages() { loadAssetImages('backgrounds', backgroundThemeSelect.value, backgroundDictionary, addBackgroundToCanvas); }
        
        function addBorderToCanvas(path) {
            const activeCanvas = getActiveCanvas();
            const propName = 'isBorder';
            const existing = activeCanvas.getObjects().find(obj => obj[propName]);
            if (existing) activeCanvas.remove(existing);

            fabric.Image.fromURL(path, (img) => {
                if (!img) return;
                // Scale to 70% of actual canvas height (professional standard)
                const targetHeight = currentCanvasConfig.height * 0.7;
                img.scaleToHeight(targetHeight);
                img.set({
                    left: currentCanvasConfig.width / 2, top: currentCanvasConfig.height / 2, originX: 'center', originY: 'center',
                    selectable: true, evented: true, [propName]: true,
                    opacity: parseFloat(borderOpacitySlider.value)
                });
                activeCanvas.add(img);
                img.bringToFront(); // Bring to top so user can select it
                enforceZOrder(activeCanvas);
                activeCanvas.renderAll();
                borderOpacitySlider.disabled = false;
            }, { crossOrigin: 'anonymous' });
        }
        
        function addBackgroundToCanvas(path) {
            const activeCanvas = getActiveCanvas();
            const propName = 'isBackground';
            const existing = activeCanvas.getObjects().find(obj => obj[propName]);
            if (existing) activeCanvas.remove(existing);
            activeCanvas.backgroundColor = getEl('pageColor').value; 

            fabric.Image.fromURL(path, (img) => {
                if (!img) return;
                // Scale to 70% of actual canvas height (professional standard)
                const targetHeight = currentCanvasConfig.height * 0.7;
                img.scaleToHeight(targetHeight);
                img.set({
                    left: currentCanvasConfig.width / 2,
                    top: currentCanvasConfig.height / 2,
                    originX: 'center', originY: 'center',
                    selectable: true, evented: true, [propName]: true,
                    opacity: parseFloat(backgroundOpacitySlider.value)
                });
                activeCanvas.add(img);
                img.bringToFront(); // Bring to top so user can select it
                enforceZOrder(activeCanvas);
                activeCanvas.renderAll();
                backgroundOpacitySlider.disabled = false;
            }, { crossOrigin: 'anonymous' });
        }
        
        async function getCanvasDataURL(canvasInstance, exportOpts) {
            // Save current state
            const currentZoom = canvasInstance.getZoom();
            const currentWidth = canvasInstance.getWidth();
            const currentHeight = canvasInstance.getHeight();
            
            // Reset for export at actual dimensions
            canvasInstance.setZoom(1);
            canvasInstance.setDimensions({
                width: currentCanvasConfig.width,
                height: currentCanvasConfig.height
            });
            
            const format = 'jpeg';
            let dataURL = canvasInstance.toDataURL({ format: format, quality: 1.0, multiplier: exportOpts.multiplier, backgroundColor: canvasInstance.backgroundColor });
            
            // Restore display state
            canvasInstance.setZoom(currentZoom);
            canvasInstance.setDimensions({
                width: currentWidth,
                height: currentHeight
            });
            
            if (exportOpts.grayscale) {
                try { dataURL = await applyGrayscaleToDataURL(dataURL, `image/${format}`); }
                catch (error) { console.error("Grayscale failed:", error); }
            }
            return dataURL;
        }

        async function applyGrayscaleToDataURL(dataURL, outputFormat = 'image/jpeg') {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width; tempCanvas.height = img.height;
                    const ctx = tempCanvas.getContext('2d');
                    if (!ctx) { reject(new Error("Failed to get 2D context.")); return; }
                    ctx.drawImage(img, 0, 0);
                    const imageData = ctx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const data = imageData.data;
                    for (let i = 0; i < data.length; i += 4) {
                        const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                        data[i] = data[i + 1] = data[i + 2] = gray;
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(tempCanvas.toDataURL(outputFormat, 1.0));
                };
                img.onerror = (err) => reject(err);
                img.src = dataURL;
            });
        }

        async function downloadImageFile(canvasToExport, baseFileName) {
            showMessage(`Preparing ${baseFileName}.jpeg...`, 'info', 0);
            const exportOptions = { multiplier: downloadMultiplier, grayscale: grayscaleToggle.checked };
            try {
                const dataURL = await getCanvasDataURL(canvasToExport, exportOptions);
                const link = document.createElement('a');
                link.download = `${baseFileName}.jpeg`;
                link.href = dataURL;
                link.click();
                showMessage(t('findobjects.msg.download.initiated'), 'success');
            } catch (error) {
                showMessage(`Error preparing JPEG: ${error.message}`, 'error');
            }
        }

        
    // Check if user is on free tier
    function isFreeTier() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get('tier') === 'free';
    }

    // Create custom file input UI
    function createCustomFileInput() {
        const fileInput = document.getElementById('imageUploadInput');
        if (!fileInput) return;

        // Check if already customized
        if (fileInput.parentNode.querySelector('.custom-file-wrapper')) return;

        // Create wrapper
        const wrapper = document.createElement('div');
        wrapper.className = 'custom-file-wrapper';
        wrapper.style.cssText = 'display: flex; align-items: center; gap: 10px; margin-top: 10px;';

        // Create custom button
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'custom-file-button';
        button.textContent = t('findobjects.choose.files');
        button.setAttribute('data-translate', 'findobjects.choose.files');
        button.style.cssText = 'padding: 6px 12px; background: #4a4a4a; color: white; border: none; border-radius: 4px; cursor: pointer;';

        // Create status label
        const label = document.createElement('span');
        label.className = 'custom-file-label';
        label.textContent = t('findobjects.no.file.chosen');
        label.setAttribute('data-translate', 'findobjects.no.file.chosen');
        label.style.cssText = 'color: #888;';

        // Insert wrapper after the file input
        fileInput.parentNode.insertBefore(wrapper, fileInput.nextSibling);
        wrapper.appendChild(button);
        wrapper.appendChild(label);

        // Handle button click
        button.onclick = () => fileInput.click();

        // Handle file selection
        fileInput.onchange = function() {
            if (this.files.length > 0) {
                label.textContent = this.files.length + ' ' + t('findobjects.files.selected');
                label.removeAttribute('data-translate');
            } else {
                label.textContent = t('findobjects.no.file.chosen');
                label.setAttribute('data-translate', 'findobjects.no.file.chosen');
            }
        };
    }

    // Update custom file input when language changes
    function updateCustomFileInput() {
        const button = document.querySelector('.custom-file-button');
        const label = document.querySelector('.custom-file-label');
        const fileInput = document.getElementById('imageUploadInput');

        if (button) {
            button.textContent = t('findobjects.choose.files');
        }

        if (label && fileInput) {
            if (fileInput.files.length === 0) {
                label.textContent = t('findobjects.no.file.chosen');
            } else {
                label.textContent = fileInput.files.length + ' ' + t('findobjects.files.selected');
            }
        }
    }



    // Add watermark to canvas before export
    function addWatermarkToCanvas(canvas) {
        if (!isFreeTier()) return;
        
        const watermarkText = new fabric.Text('FREE VERSION - LessonCraftStudio.com', {
            fontSize: 40,
            fill: 'rgba(0, 0, 0, 0.2)',
            angle: -45,
            left: canvas.width / 2,
            top: canvas.height / 2,
            originX: 'center',
            originY: 'center',
            selectable: false,
            evented: false,
            fontFamily: 'Arial, sans-serif',
            fontWeight: 'bold'
        });
        
        // Add multiple watermarks across the canvas
        const watermarks = [];
        const spacing = 250;
        for (let x = 0; x < canvas.width; x += spacing) {
            for (let y = 0; y < canvas.height; y += spacing) {
                const wm = new fabric.Text('FREE VERSION', {
                    fontSize: 20,
                    fill: 'rgba(0, 0, 0, 0.15)',
                    angle: -45,
                    left: x,
                    top: y,
                    selectable: false,
                    evented: false,
                    fontFamily: 'Arial, sans-serif'
                });
                watermarks.push(wm);
                canvas.add(wm);
            }
        }
        
        // Add main watermark
        canvas.add(watermarkText);
        canvas.renderAll();
        
        return { mainWatermark: watermarkText, watermarks };
    }

    // Remove watermark after export
    function removeWatermarkFromCanvas(canvas, watermarkData) {
        if (!watermarkData) return;
        
        if (watermarkData.mainWatermark) {
            canvas.remove(watermarkData.mainWatermark);
        }
        if (watermarkData.watermarks) {
            watermarkData.watermarks.forEach(wm => canvas.remove(wm));
        }
        canvas.renderAll();
    }

    // Override the original downloadPDF function
    const originalDownloadPDF = typeof downloadPDF !== 'undefined' ? downloadPDF : null;
    if (originalDownloadPDF) {
        window.downloadPDF = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('findobjects.msg.generate.first'), 'error');
            }
            showMessage(t('findobjects.msg.preparing.pdf'), 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const { jsPDF } = window.jspdf;
                const orientation = canvasToExport.width > canvasToExport.height ? 'l' : 'p';
                const pdf = new jsPDF({ 
                    orientation, 
                    unit: 'pt', 
                    format: [canvasToExport.width, canvasToExport.height] 
                });

                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked 
                };
                
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                pdf.addImage(dataURL, 'JPEG', 0, 0, canvasToExport.width, canvasToExport.height);
                
                pdf.save(fileName);
                showMessage(t('findobjects.msg.pdf.downloaded'), 'success');
            } catch(e) { 
                showMessage(t('findobjects.msg.pdf.error'), 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

    // Override the original downloadJPEG function if it exists
    const originalDownloadJPEG = typeof downloadJPEG !== 'undefined' ? downloadJPEG : null;
    if (originalDownloadJPEG) {
        window.downloadJPEG = async function(canvasToExport, fileName) {
            if (!canvasToExport || canvasToExport.getObjects().length === 0) {
                return showMessage(t('findobjects.msg.generate.first'), 'error');
            }
            showMessage('Preparing JPEG...', 'info', 0);
            
            // Add watermark if free tier
            const watermarkData = addWatermarkToCanvas(canvasToExport);
            
            try {
                const exportOptions = { 
                    multiplier: typeof downloadMultiplier !== 'undefined' ? downloadMultiplier : 6, 
                    applyGrayscale: typeof grayscaleToggle !== 'undefined' && grayscaleToggle.checked 
                };
                const dataURL = await getCanvasDataURLWithOptions(canvasToExport, exportOptions);
                
                const link = document.createElement('a');
                link.href = dataURL;
                link.download = fileName;
                link.click();
                showMessage('JPEG download initiated!', 'success');
            } catch(e) { 
                showMessage(t('findobjects.msg.jpeg.error'), 'error'); 
                console.error(e); 
            } finally {
                // Remove watermark after export
                removeWatermarkFromCanvas(canvasToExport, watermarkData);
            }
        };
    }

async function downloadPDF(canvasToExport, fileName) {
            showMessage(`Preparing ${fileName}...`, 'info', 0);
            const exportOptions = { multiplier: downloadMultiplier, grayscale: grayscaleToggle.checked };
            try {
                const { jsPDF } = window.jspdf;
                const orientation = currentCanvasConfig.width > currentCanvasConfig.height ? 'l' : 'p';
                const pdf = new jsPDF({ orientation, unit: 'pt', format: [currentCanvasConfig.width, currentCanvasConfig.height] });
                
                const imgData = await getCanvasDataURL(canvasToExport, exportOptions);
                pdf.addImage(imgData, 'JPEG', 0, 0, currentCanvasConfig.width, currentCanvasConfig.height);
                
                pdf.save(fileName);
                showMessage('PDF Downloaded!', 'success');
            } catch (error) {
                showMessage(`Error creating PDF: ${error.message}`, "error");
            }
        }

        initializeApp();
    });
  </script>
</body>
</html>